module.exports = {

"[project]/node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ __turbopack_context__.s({
    "__addDisposableResource": (()=>__addDisposableResource),
    "__assign": (()=>__assign),
    "__asyncDelegator": (()=>__asyncDelegator),
    "__asyncGenerator": (()=>__asyncGenerator),
    "__asyncValues": (()=>__asyncValues),
    "__await": (()=>__await),
    "__awaiter": (()=>__awaiter),
    "__classPrivateFieldGet": (()=>__classPrivateFieldGet),
    "__classPrivateFieldIn": (()=>__classPrivateFieldIn),
    "__classPrivateFieldSet": (()=>__classPrivateFieldSet),
    "__createBinding": (()=>__createBinding),
    "__decorate": (()=>__decorate),
    "__disposeResources": (()=>__disposeResources),
    "__esDecorate": (()=>__esDecorate),
    "__exportStar": (()=>__exportStar),
    "__extends": (()=>__extends),
    "__generator": (()=>__generator),
    "__importDefault": (()=>__importDefault),
    "__importStar": (()=>__importStar),
    "__makeTemplateObject": (()=>__makeTemplateObject),
    "__metadata": (()=>__metadata),
    "__param": (()=>__param),
    "__propKey": (()=>__propKey),
    "__read": (()=>__read),
    "__rest": (()=>__rest),
    "__rewriteRelativeImportExtension": (()=>__rewriteRelativeImportExtension),
    "__runInitializers": (()=>__runInitializers),
    "__setFunctionName": (()=>__setFunctionName),
    "__spread": (()=>__spread),
    "__spreadArray": (()=>__spreadArray),
    "__spreadArrays": (()=>__spreadArrays),
    "__values": (()=>__values),
    "default": (()=>__TURBOPACK__default__export__)
});
var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return extendStatics(d, b);
};
function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __rest(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
        if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
        return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for(var i = decorators.length - 1; i >= 0; i--){
        var context = {};
        for(var p in contextIn)context[p] = p === "access" ? {} : contextIn[p];
        for(var p in contextIn.access)context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
            if (done) throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? {
            get: descriptor.get,
            set: descriptor.set
        } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        } else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
}
;
function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for(var i = 0; i < initializers.length; i++){
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
}
;
function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
}
;
function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", {
        configurable: true,
        value: prefix ? "".concat(prefix, " ", name) : name
    });
}
;
function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    "TURBOPACK unreachable";
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var __createBinding = Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
};
function __exportStar(m, o) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
}
function __spread() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
}
function __spreadArrays() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
}
function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    "TURBOPACK unreachable";
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
}
function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
        return this;
    }, i;
    "TURBOPACK unreachable";
    function verb(n, f) {
        i[n] = o[n] ? function(v) {
            return (p = !p) ? {
                value: __await(o[n](v)),
                done: false
            } : f ? f(v) : v;
        } : f;
    }
}
function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    "TURBOPACK unreachable";
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
}
function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", {
            value: raw
        });
    } else {
        cooked.raw = raw;
    }
    return cooked;
}
;
var __setModuleDefault = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
};
var ownKeys = function(o) {
    ownKeys = Object.getOwnPropertyNames || function(o) {
        var ar = [];
        for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
    };
    return ownKeys(o);
};
function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
    }
    __setModuleDefault(result, mod);
    return result;
}
function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() {
            try {
                inner.call(this);
            } catch (e) {
                return Promise.reject(e);
            }
        };
        env.stack.push({
            value: value,
            dispose: dispose,
            async: async
        });
    } else if (async) {
        env.stack.push({
            async: true
        });
    }
    return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
    function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
    }
    var r, s = 0;
    function next() {
        while(r = env.stack.pop()){
            try {
                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                if (r.dispose) {
                    var result = r.dispose.call(r.value);
                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                        fail(e);
                        return next();
                    });
                } else s |= 1;
            } catch (e) {
                fail(e);
            }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
    }
    return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
    if (typeof path === "string" && /^\.\.?\//.test(path)) {
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
            return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
    }
    return path;
}
const __TURBOPACK__default__export__ = {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __esDecorate,
    __runInitializers,
    __propKey,
    __setFunctionName,
    __metadata,
    __awaiter,
    __generator,
    __createBinding,
    __exportStar,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn,
    __addDisposableResource,
    __disposeResources,
    __rewriteRelativeImportExtension
};
}}),
"[project]/node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
    }
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength){
        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }
    return parts.join('');
}
}}),
"[project]/node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8){}
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8){}
    if (e === 0) {
        e = 1 - eBias;
    } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) {
            value += rt / c;
        } else {
            value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8){}
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8){}
    buffer[offset + i - d] |= s * 128;
};
}}),
"[project]/node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ 'use strict';
const base64 = __turbopack_context__.r("[project]/node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js [app-ssr] (ecmascript)");
const ieee754 = __turbopack_context__.r("[project]/node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js [app-ssr] (ecmascript)");
const customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
            throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') {
        return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
    }
    if (value == null) {
        throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === 'number') {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length);
    }
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
        return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    }
    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
        return createBuffer(size);
    }
    if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpreted as a start offset.
        return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
    }
    if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1){
        buf[i] = array[i] & 255;
    }
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === undefined && length === undefined) {
        buf = new Uint8Array(array);
    } else if (length === undefined) {
        buf = new Uint8Array(array, byteOffset);
    } else {
        buf = new Uint8Array(array, byteOffset, length);
    }
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
            return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
            return createBuffer(0);
        }
        return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
    }
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
    }
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) {
        length = 0;
    }
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i){
        if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
        }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
        return Buffer.alloc(0);
    }
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i){
            length += list[i].length;
        }
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else {
                Uint8Array.prototype.set.call(buffer, buf, pos);
            }
        } else if (!Buffer.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
            buf.copy(buffer, pos);
        }
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) {
        return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
    }
    if (typeof string !== 'string') {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;){
        switch(encoding){
            case 'ascii':
            case 'latin1':
            case 'binary':
                return len;
            case 'utf8':
            case 'utf-8':
                return utf8ToBytes(string).length;
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                return len * 2;
            case 'hex':
                return len >>> 1;
            case 'base64':
                return base64ToBytes(string).length;
            default:
                if (loweredCase) {
                    return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
                    ;
                }
                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
        }
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
        start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
        return '';
    }
    if (end === undefined || end > this.length) {
        end = this.length;
    }
    if (end <= 0) {
        return '';
    }
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
        return '';
    }
    if (!encoding) encoding = 'utf8';
    while(true){
        switch(encoding){
            case 'hex':
                return hexSlice(this, start, end);
            case 'utf8':
            case 'utf-8':
                return utf8Slice(this, start, end);
            case 'ascii':
                return asciiSlice(this, start, end);
            case 'latin1':
            case 'binary':
                return latin1Slice(this, start, end);
            case 'base64':
                return base64Slice(this, start, end);
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                return utf16leSlice(this, start, end);
            default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                encoding = (encoding + '').toLowerCase();
                loweredCase = true;
        }
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits');
    }
    for(let i = 0; i < len; i += 2){
        swap(this, i, i + 1);
    }
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits');
    }
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits');
    }
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = '';
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
};
if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);
    }
    if (start === undefined) {
        start = 0;
    }
    if (end === undefined) {
        end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
        thisStart = 0;
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index');
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i){
        if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
        }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : buffer.length - 1;
    }
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
    }
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
            return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) {
                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) {
                return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) {
            return buf[i];
        } else {
            return buf.readUInt16BE(i * indexSize);
        }
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++){
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                if (foundIndex === -1) foundIndex = i;
                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
                if (foundIndex !== -1) i -= i - foundIndex;
                foundIndex = -1;
            }
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++){
                if (read(arr, i + j) !== read(val, j)) {
                    found = false;
                    break;
                }
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
        length = remaining;
    } else {
        length = Number(length);
        if (length > remaining) {
            length = remaining;
        }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
        length = strLen / 2;
    }
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else {
        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    }
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds');
    }
    if (!encoding) encoding = 'utf8';
    let loweredCase = false;
    for(;;){
        switch(encoding){
            case 'hex':
                return hexWrite(this, string, offset, length);
            case 'utf8':
            case 'utf-8':
                return utf8Write(this, string, offset, length);
            case 'ascii':
            case 'latin1':
            case 'binary':
                return asciiWrite(this, string, offset, length);
            case 'base64':
                // Warning: maxLength not taken into account in base64Write
                return base64Write(this, string, offset, length);
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                return ucs2Write(this, string, offset, length);
            default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
        }
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
    } else {
        return base64.fromByteArray(buf.slice(start, end));
    }
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
        ;
    }
    // Decode in chunks to avoid "call stack size exceeded".
    let res = '';
    let i = 0;
    while(i < len){
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i]);
    }
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = '';
    for(let i = start; i < end; ++i){
        out += hexSliceLookupTable[buf[i]];
    }
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2){
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) {
        end = len;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100)){
        val += this[offset + i] * mul;
    }
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
    }
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100)){
        val += this[offset + --byteLength] * mul;
    }
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100)){
        val += this[offset + i] * mul;
    }
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100)){
        val += this[offset + --i] * mul;
    }
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24) // Overflow
    ;
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        this[offset + i] = value / mul & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        this[offset + i] = value / mul & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
        // Use built-in when available, missing from IE11
        this.copyWithin(targetStart, start, end);
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
            throw new TypeError('encoding must be a string');
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
            throw new TypeError('Unknown encoding: ' + encoding);
        }
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
                // Fast path: If `val` fits into a single byte, use that numeric value.
                val = code;
            }
        }
    } else if (typeof val === 'number') {
        val = val & 255;
    } else if (typeof val === 'boolean') {
        val = Number(val);
    }
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index');
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === 'number') {
        for(i = start; i < end; ++i){
            this[i] = val;
        }
    } else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for(i = 0; i < end - start; ++i){
            this[i + start] = bytes[i % len];
        }
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, 'message', {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, 'code', {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E('ERR_BUFFER_OUT_OF_BOUNDS', function(name) {
    if (name) {
        return `${name} is outside of buffer bounds`;
    }
    return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INVALID_ARG_TYPE', function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E('ERR_OUT_OF_RANGE', function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
    } else if (typeof input === 'bigint') {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
        }
        received += 'n';
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = '';
    let i = val.length;
    const start = val[0] === '-' ? 1 : 0;
    for(; i >= start + 4; i -= 3){
        res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, 'offset');
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
        boundsError(offset, buf.length - (byteLength + 1));
    }
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === 'bigint' ? 'n' : '';
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE('value', range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== 'number') {
        throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
    }
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
    }
    if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0){
        str = str + '=';
    }
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
            // valid bmp char, but last char was a lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else {
            throw new Error('Invalid code point');
        }
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = '0123456789abcdef';
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j){
            table[i16 + j] = alphabet[i] + alphabet[j];
        }
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error('BigInt not supported');
}
}}),
"[project]/node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)").createHash;
}}),
"[project]/node_modules/.pnpm/bs58check@2.1.2/node_modules/bs58check/base.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var base58 = __turbopack_context__.r("[project]/node_modules/.pnpm/bs58@4.0.1/node_modules/bs58/index.js [app-ssr] (ecmascript)");
var Buffer = __turbopack_context__.r("[project]/node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js [app-ssr] (ecmascript)").Buffer;
module.exports = function(checksumFn) {
    // Encode a buffer as a base58-check encoded string
    function encode(payload) {
        var checksum = checksumFn(payload);
        return base58.encode(Buffer.concat([
            payload,
            checksum
        ], payload.length + 4));
    }
    function decodeRaw(buffer) {
        var payload = buffer.slice(0, -4);
        var checksum = buffer.slice(-4);
        var newChecksum = checksumFn(payload);
        if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;
        return payload;
    }
    // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
    function decodeUnsafe(string) {
        var buffer = base58.decodeUnsafe(string);
        if (!buffer) return;
        return decodeRaw(buffer);
    }
    function decode(string) {
        var buffer = base58.decode(string);
        var payload = decodeRaw(buffer, checksumFn);
        if (!payload) throw new Error('Invalid checksum');
        return payload;
    }
    return {
        encode: encode,
        decode: decode,
        decodeUnsafe: decodeUnsafe
    };
};
}}),
"[project]/node_modules/.pnpm/bs58check@2.1.2/node_modules/bs58check/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var createHash = __turbopack_context__.r("[project]/node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/index.js [app-ssr] (ecmascript)");
var bs58checkBase = __turbopack_context__.r("[project]/node_modules/.pnpm/bs58check@2.1.2/node_modules/bs58check/base.js [app-ssr] (ecmascript)");
// SHA256(SHA256(buffer))
function sha256x2(buffer) {
    var tmp = createHash('sha256').update(buffer).digest();
    return createHash('sha256').update(tmp).digest();
}
module.exports = bs58checkBase(sha256x2);
}}),
"[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/errors.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidChecksumError = exports.InvalidSequenceComponentError = exports.InvalidTypeError = exports.InvalidPathLengthError = exports.InvalidSchemeError = void 0;
class InvalidSchemeError extends Error {
    constructor(){
        super('Invalid Scheme');
        this.name = 'InvalidSchemeError';
    }
}
exports.InvalidSchemeError = InvalidSchemeError;
class InvalidPathLengthError extends Error {
    constructor(){
        super('Invalid Path');
        this.name = 'InvalidPathLengthError';
    }
}
exports.InvalidPathLengthError = InvalidPathLengthError;
class InvalidTypeError extends Error {
    constructor(){
        super('Invalid Type');
        this.name = 'InvalidTypeError';
    }
}
exports.InvalidTypeError = InvalidTypeError;
class InvalidSequenceComponentError extends Error {
    constructor(){
        super('Invalid Sequence Component');
        this.name = 'InvalidSequenceComponentError';
    }
}
exports.InvalidSequenceComponentError = InvalidSequenceComponentError;
class InvalidChecksumError extends Error {
    constructor(){
        super('Invalid Checksum');
        this.name = 'InvalidChecksumError';
    }
}
exports.InvalidChecksumError = InvalidChecksumError; //# sourceMappingURL=errors.js.map
}}),
"[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/utils.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bufferXOR = exports.setDifference = exports.arrayContains = exports.arraysEqual = exports.hasPrefix = exports.isURType = exports.intToBytes = exports.toUint32 = exports.getCRCHex = exports.getCRC = exports.split = exports.partition = exports.sha256Hash = void 0;
const sha_js_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/index.js [app-ssr] (ecmascript)"));
const crc_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/index.js [app-ssr] (ecmascript)");
const sha256Hash = (data)=>sha_js_1.default('sha256').update(data).digest();
exports.sha256Hash = sha256Hash;
const partition = (s, n)=>s.match(new RegExp('.{1,' + n + '}', 'g')) || [
        s
    ];
exports.partition = partition;
const split = (s, length)=>[
        s.slice(0, -length),
        s.slice(-length)
    ];
exports.split = split;
const getCRC = (message)=>crc_1.crc32(message);
exports.getCRC = getCRC;
const getCRCHex = (message)=>crc_1.crc32(message).toString(16).padStart(8, '0');
exports.getCRCHex = getCRCHex;
const toUint32 = (number)=>number >>> 0;
exports.toUint32 = toUint32;
const intToBytes = (num)=>{
    const arr = new ArrayBuffer(4); // an Int32 takes 4 bytes
    const view = new DataView(arr);
    view.setUint32(0, num, false); // byteOffset = 0; litteEndian = false
    return Buffer.from(arr);
};
exports.intToBytes = intToBytes;
const isURType = (type)=>{
    return type.split('').every((_, index)=>{
        let c = type.charCodeAt(index);
        if ('a'.charCodeAt(0) <= c && c <= 'z'.charCodeAt(0)) return true;
        if ('0'.charCodeAt(0) <= c && c <= '9'.charCodeAt(0)) return true;
        if (c === '-'.charCodeAt(0)) return true;
        return false;
    });
};
exports.isURType = isURType;
const hasPrefix = (s, prefix)=>s.indexOf(prefix) === 0;
exports.hasPrefix = hasPrefix;
const arraysEqual = (ar1, ar2)=>{
    if (ar1.length !== ar2.length) {
        return false;
    }
    return ar1.every((el)=>ar2.includes(el));
};
exports.arraysEqual = arraysEqual;
/**
 * Checks if ar1 contains all elements of ar2
 * @param ar1 the outer array
 * @param ar2 the array to be contained in ar1
 */ const arrayContains = (ar1, ar2)=>{
    return ar2.every((v)=>ar1.includes(v));
};
exports.arrayContains = arrayContains;
/**
 * Returns the difference array of  `ar1` - `ar2`
 */ const setDifference = (ar1, ar2)=>{
    return ar1.filter((x)=>ar2.indexOf(x) < 0);
};
exports.setDifference = setDifference;
const bufferXOR = (a, b)=>{
    const length = Math.max(a.length, b.length);
    const buffer = Buffer.allocUnsafe(length);
    for(let i = 0; i < length; ++i){
        buffer[i] = a[i] ^ b[i];
    }
    return buffer;
};
exports.bufferXOR = bufferXOR; //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/cbor.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.cborDecode = exports.cborEncode = void 0;
const cbor = __turbopack_context__.r("[project]/node_modules/.pnpm/cbor-sync@1.0.4/node_modules/cbor-sync/main.js [app-ssr] (ecmascript)");
const cborEncode = (data)=>{
    return cbor.encode(data);
};
exports.cborEncode = cborEncode;
const cborDecode = (data)=>{
    return cbor.decode(Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex'));
};
exports.cborDecode = cborDecode; //# sourceMappingURL=cbor.js.map
}}),
"[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/ur.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const errors_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/errors.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/utils.js [app-ssr] (ecmascript)");
const cbor_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/cbor.js [app-ssr] (ecmascript)");
class UR {
    constructor(_cborPayload, _type = 'bytes'){
        this._cborPayload = _cborPayload;
        this._type = _type;
        if (!utils_1.isURType(this._type)) {
            throw new errors_1.InvalidTypeError();
        }
    }
    static fromBuffer(buf) {
        return new UR(cbor_1.cborEncode(buf));
    }
    static from(value, encoding) {
        return UR.fromBuffer(Buffer.from(value, encoding));
    }
    decodeCBOR() {
        return cbor_1.cborDecode(this._cborPayload);
    }
    get type() {
        return this._type;
    }
    get cbor() {
        return this._cborPayload;
    }
    equals(ur2) {
        return this.type === ur2.type && this.cbor.equals(ur2.cbor);
    }
}
exports.default = UR; //# sourceMappingURL=ur.js.map
}}),
"[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/xoshiro.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const utils_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/utils.js [app-ssr] (ecmascript)");
const bignumber_js_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.js [app-ssr] (ecmascript)"));
const jsbi_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/jsbi@3.2.5/node_modules/jsbi/dist/jsbi.mjs [app-ssr] (ecmascript)"));
const MAX_UINT64 = 0xFFFFFFFFFFFFFFFF;
const rotl = (x, k)=>jsbi_1.default.bitwiseXor(jsbi_1.default.asUintN(64, jsbi_1.default.leftShift(x, jsbi_1.default.BigInt(k))), jsbi_1.default.BigInt(jsbi_1.default.asUintN(64, jsbi_1.default.signedRightShift(x, jsbi_1.default.subtract(jsbi_1.default.BigInt(64), jsbi_1.default.BigInt(k))))));
class Xoshiro {
    constructor(seed){
        this.next = ()=>{
            return new bignumber_js_1.default(this.roll().toString());
        };
        this.nextDouble = ()=>{
            return new bignumber_js_1.default(this.roll().toString()).div(MAX_UINT64 + 1);
        };
        this.nextInt = (low, high)=>{
            return Math.floor(this.nextDouble().toNumber() * (high - low + 1) + low);
        };
        this.nextByte = ()=>this.nextInt(0, 255);
        this.nextData = (count)=>[
                ...new Array(count)
            ].map(()=>this.nextByte());
        const digest = utils_1.sha256Hash(seed);
        this.s = [
            jsbi_1.default.BigInt(0),
            jsbi_1.default.BigInt(0),
            jsbi_1.default.BigInt(0),
            jsbi_1.default.BigInt(0)
        ];
        this.setS(digest);
    }
    setS(digest) {
        for(let i = 0; i < 4; i++){
            let o = i * 8;
            let v = jsbi_1.default.BigInt(0);
            for(let n = 0; n < 8; n++){
                v = jsbi_1.default.asUintN(64, jsbi_1.default.leftShift(v, jsbi_1.default.BigInt(8)));
                v = jsbi_1.default.asUintN(64, jsbi_1.default.bitwiseOr(v, jsbi_1.default.BigInt(digest[o + n])));
            }
            this.s[i] = jsbi_1.default.asUintN(64, v);
        }
    }
    roll() {
        const result = jsbi_1.default.asUintN(64, jsbi_1.default.multiply(rotl(jsbi_1.default.asUintN(64, jsbi_1.default.multiply(this.s[1], jsbi_1.default.BigInt(5))), 7), jsbi_1.default.BigInt(9)));
        const t = jsbi_1.default.asUintN(64, jsbi_1.default.leftShift(this.s[1], jsbi_1.default.BigInt(17)));
        this.s[2] = jsbi_1.default.asUintN(64, jsbi_1.default.bitwiseXor(this.s[2], jsbi_1.default.BigInt(this.s[0])));
        this.s[3] = jsbi_1.default.asUintN(64, jsbi_1.default.bitwiseXor(this.s[3], jsbi_1.default.BigInt(this.s[1])));
        this.s[1] = jsbi_1.default.asUintN(64, jsbi_1.default.bitwiseXor(this.s[1], jsbi_1.default.BigInt(this.s[2])));
        this.s[0] = jsbi_1.default.asUintN(64, jsbi_1.default.bitwiseXor(this.s[0], jsbi_1.default.BigInt(this.s[3])));
        this.s[2] = jsbi_1.default.asUintN(64, jsbi_1.default.bitwiseXor(this.s[2], jsbi_1.default.BigInt(t)));
        this.s[3] = jsbi_1.default.asUintN(64, rotl(this.s[3], 45));
        return result;
    }
}
exports.default = Xoshiro; //# sourceMappingURL=xoshiro.js.map
}}),
"[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/fountainUtils.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.chooseFragments = exports.shuffle = exports.chooseDegree = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/utils.js [app-ssr] (ecmascript)");
const xoshiro_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/xoshiro.js [app-ssr] (ecmascript)"));
const alias_sampling_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/@keystonehq+alias-sampling@0.1.2/node_modules/@keystonehq/alias-sampling/dist/esm/index.js [app-ssr] (ecmascript)"));
const chooseDegree = (seqLenth, rng)=>{
    const degreeProbabilities = [
        ...new Array(seqLenth)
    ].map((_, index)=>1 / (index + 1));
    const degreeChooser = alias_sampling_1.default(degreeProbabilities, undefined, rng.nextDouble);
    return degreeChooser.next() + 1;
};
exports.chooseDegree = chooseDegree;
const shuffle = (items, rng)=>{
    let remaining = [
        ...items
    ];
    let result = [];
    while(remaining.length > 0){
        let index = rng.nextInt(0, remaining.length - 1);
        let item = remaining[index];
        // remaining.erase(remaining.begin() + index);
        remaining.splice(index, 1);
        result.push(item);
    }
    return result;
};
exports.shuffle = shuffle;
const chooseFragments = (seqNum, seqLength, checksum)=>{
    // The first `seqLenth` parts are the "pure" fragments, not mixed with any
    // others. This means that if you only generate the first `seqLenth` parts,
    // then you have all the parts you need to decode the message.
    if (seqNum <= seqLength) {
        return [
            seqNum - 1
        ];
    } else {
        const seed = Buffer.concat([
            utils_1.intToBytes(seqNum),
            utils_1.intToBytes(checksum)
        ]);
        const rng = new xoshiro_1.default(seed);
        const degree = exports.chooseDegree(seqLength, rng);
        const indexes = [
            ...new Array(seqLength)
        ].map((_, index)=>index);
        const shuffledIndexes = exports.shuffle(indexes, rng);
        return shuffledIndexes.slice(0, degree);
    }
};
exports.chooseFragments = chooseFragments; //# sourceMappingURL=fountainUtils.js.map
}}),
"[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/fountainEncoder.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FountainEncoderPart = void 0;
const assert_1 = __importDefault(__turbopack_context__.r("[externals]/assert [external] (assert, cjs)"));
const utils_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/utils.js [app-ssr] (ecmascript)");
const fountainUtils_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/fountainUtils.js [app-ssr] (ecmascript)");
const cbor_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/cbor.js [app-ssr] (ecmascript)");
class FountainEncoderPart {
    constructor(_seqNum, _seqLength, _messageLength, _checksum, _fragment){
        this._seqNum = _seqNum;
        this._seqLength = _seqLength;
        this._messageLength = _messageLength;
        this._checksum = _checksum;
        this._fragment = _fragment;
    }
    get messageLength() {
        return this._messageLength;
    }
    get fragment() {
        return this._fragment;
    }
    get seqNum() {
        return this._seqNum;
    }
    get seqLength() {
        return this._seqLength;
    }
    get checksum() {
        return this._checksum;
    }
    cbor() {
        const result = cbor_1.cborEncode([
            this._seqNum,
            this._seqLength,
            this._messageLength,
            this._checksum,
            this._fragment
        ]);
        return Buffer.from(result);
    }
    description() {
        return `seqNum:${this._seqNum}, seqLen:${this._seqLength}, messageLen:${this._messageLength}, checksum:${this._checksum}, data:${this._fragment.toString('hex')}`;
    }
    static fromCBOR(cborPayload) {
        const [seqNum, seqLength, messageLength, checksum, fragment] = cbor_1.cborDecode(cborPayload);
        assert_1.default(typeof seqNum === 'number');
        assert_1.default(typeof seqLength === 'number');
        assert_1.default(typeof messageLength === 'number');
        assert_1.default(typeof checksum === 'number');
        assert_1.default(Buffer.isBuffer(fragment) && fragment.length > 0);
        return new FountainEncoderPart(seqNum, seqLength, messageLength, checksum, Buffer.from(fragment));
    }
}
exports.FountainEncoderPart = FountainEncoderPart;
class FountainEncoder {
    constructor(message, maxFragmentLength = 100, firstSeqNum = 0, minFragmentLength = 10){
        const fragmentLength = FountainEncoder.findNominalFragmentLength(message.length, minFragmentLength, maxFragmentLength);
        this._messageLength = message.length;
        this._fragments = FountainEncoder.partitionMessage(message, fragmentLength);
        this.fragmentLength = fragmentLength;
        this.seqNum = utils_1.toUint32(firstSeqNum);
        this.checksum = utils_1.getCRC(message);
    }
    get fragmentsLength() {
        return this._fragments.length;
    }
    get fragments() {
        return this._fragments;
    }
    get messageLength() {
        return this._messageLength;
    }
    isComplete() {
        return this.seqNum >= this._fragments.length;
    }
    isSinglePart() {
        return this._fragments.length === 1;
    }
    seqLength() {
        return this._fragments.length;
    }
    mix(indexes) {
        return indexes.reduce((result, index)=>utils_1.bufferXOR(this._fragments[index], result), Buffer.alloc(this.fragmentLength, 0));
    }
    nextPart() {
        this.seqNum = utils_1.toUint32(this.seqNum + 1);
        const indexes = fountainUtils_1.chooseFragments(this.seqNum, this._fragments.length, this.checksum);
        const mixed = this.mix(indexes);
        return new FountainEncoderPart(this.seqNum, this._fragments.length, this._messageLength, this.checksum, mixed);
    }
    static findNominalFragmentLength(messageLength, minFragmentLength, maxFragmentLength) {
        assert_1.default(messageLength > 0);
        assert_1.default(minFragmentLength > 0);
        assert_1.default(maxFragmentLength >= minFragmentLength);
        const maxFragmentCount = Math.ceil(messageLength / minFragmentLength);
        let fragmentLength = 0;
        for(let fragmentCount = 1; fragmentCount <= maxFragmentCount; fragmentCount++){
            fragmentLength = Math.ceil(messageLength / fragmentCount);
            if (fragmentLength <= maxFragmentLength) {
                break;
            }
        }
        return fragmentLength;
    }
    static partitionMessage(message, fragmentLength) {
        let remaining = Buffer.from(message);
        let fragment;
        let _fragments = [];
        while(remaining.length > 0){
            [fragment, remaining] = utils_1.split(remaining, -fragmentLength);
            fragment = Buffer.alloc(fragmentLength, 0) // initialize with 0's to achieve the padding
            .fill(fragment, 0, fragment.length);
            _fragments.push(fragment);
        }
        return _fragments;
    }
}
exports.default = FountainEncoder; //# sourceMappingURL=fountainEncoder.js.map
}}),
"[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/bytewords.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const assert_1 = __importDefault(__turbopack_context__.r("[externals]/assert [external] (assert, cjs)"));
const utils_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/utils.js [app-ssr] (ecmascript)");
const bytewords = 'ableacidalsoapexaquaarchatomauntawayaxisbackbaldbarnbeltbetabiasbluebodybragbrewbulbbuzzcalmcashcatschefcityclawcodecolacookcostcruxcurlcuspcyandarkdatadaysdelidicedietdoordowndrawdropdrumdulldutyeacheasyechoedgeepicevenexamexiteyesfactfairfernfigsfilmfishfizzflapflewfluxfoxyfreefrogfuelfundgalagamegeargemsgiftgirlglowgoodgraygrimgurugushgyrohalfhanghardhawkheathelphighhillholyhopehornhutsicedideaidleinchinkyintoirisironitemjadejazzjoinjoltjowljudojugsjumpjunkjurykeepkenokeptkeyskickkilnkingkitekiwiknoblamblavalazyleaflegsliarlimplionlistlogoloudloveluaulucklungmainmanymathmazememomenumeowmildmintmissmonknailnavyneednewsnextnoonnotenumbobeyoboeomitonyxopenovalowlspaidpartpeckplaypluspoempoolposepuffpumapurrquadquizraceramprealredorichroadrockroofrubyruinrunsrustsafesagascarsetssilkskewslotsoapsolosongstubsurfswantacotasktaxitenttiedtimetinytoiltombtoystriptunatwinuglyundouniturgeuservastveryvetovialvibeviewvisavoidvowswallwandwarmwaspwavewaxywebswhatwhenwhizwolfworkyankyawnyellyogayurtzapszerozestzinczonezoom';
let bytewordsLookUpTable = [];
const BYTEWORDS_NUM = 256;
const BYTEWORD_LENGTH = 4;
const MINIMAL_BYTEWORD_LENGTH = 2;
var STYLES;
(function(STYLES) {
    STYLES["STANDARD"] = "standard";
    STYLES["URI"] = "uri";
    STYLES["MINIMAL"] = "minimal";
})(STYLES || (STYLES = {}));
const getWord = (index)=>{
    return bytewords.slice(index * BYTEWORD_LENGTH, index * BYTEWORD_LENGTH + BYTEWORD_LENGTH);
};
const getMinimalWord = (index)=>{
    const byteword = getWord(index);
    return `${byteword[0]}${byteword[BYTEWORD_LENGTH - 1]}`;
};
const addCRC = (string)=>{
    const crc = utils_1.getCRCHex(Buffer.from(string, 'hex'));
    return `${string}${crc}`;
};
const encodeWithSeparator = (word, separator)=>{
    const crcAppendedWord = addCRC(word);
    const crcWordBuff = Buffer.from(crcAppendedWord, 'hex');
    const result = crcWordBuff.reduce((result, w)=>[
            ...result,
            getWord(w)
        ], []);
    return result.join(separator);
};
const encodeMinimal = (word)=>{
    const crcAppendedWord = addCRC(word);
    const crcWordBuff = Buffer.from(crcAppendedWord, 'hex');
    const result = crcWordBuff.reduce((result, w)=>result + getMinimalWord(w), '');
    return result;
};
const decodeWord = (word, wordLength)=>{
    assert_1.default(word.length === wordLength, 'Invalid Bytewords: word.length does not match wordLength provided');
    const dim = 26;
    // Since the first and last letters of each Byteword are unique,
    // we can use them as indexes into a two-dimensional lookup table.
    // This table is generated lazily.
    if (bytewordsLookUpTable.length === 0) {
        const array_len = dim * dim;
        bytewordsLookUpTable = [
            ...new Array(array_len)
        ].map(()=>-1);
        for(let i = 0; i < BYTEWORDS_NUM; i++){
            const byteword = getWord(i);
            let x = byteword[0].charCodeAt(0) - 'a'.charCodeAt(0);
            let y = byteword[3].charCodeAt(0) - 'a'.charCodeAt(0);
            let offset = y * dim + x;
            bytewordsLookUpTable[offset] = i;
        }
    }
    // If the coordinates generated by the first and last letters are out of bounds,
    // or the lookup table contains -1 at the coordinates, then the word is not valid.
    let x = word[0].toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);
    let y = word[wordLength == 4 ? 3 : 1].toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);
    assert_1.default(0 <= x && x < dim && 0 <= y && y < dim, 'Invalid Bytewords: invalid word');
    let offset = y * dim + x;
    let value = bytewordsLookUpTable[offset];
    assert_1.default(value !== -1, 'Invalid Bytewords: value not in lookup table');
    // If we're decoding a full four-letter word, verify that the two middle letters are correct.
    if (wordLength == BYTEWORD_LENGTH) {
        const byteword = getWord(value);
        let c1 = word[1].toLowerCase();
        let c2 = word[2].toLowerCase();
        assert_1.default(c1 === byteword[1] && c2 === byteword[2], 'Invalid Bytewords: invalid middle letters of word');
    }
    // Successful decode.
    return Buffer.from([
        value
    ]).toString('hex');
};
const _decode = (string, separator, wordLength)=>{
    const words = wordLength == BYTEWORD_LENGTH ? string.split(separator) : utils_1.partition(string, 2);
    const decodedString = words.map((word)=>decodeWord(word, wordLength)).join('');
    assert_1.default(decodedString.length >= 5, 'Invalid Bytewords: invalid decoded string length');
    const [body, bodyChecksum] = utils_1.split(Buffer.from(decodedString, 'hex'), 4);
    const checksum = utils_1.getCRCHex(body); // convert to hex
    assert_1.default(checksum === bodyChecksum.toString('hex'), 'Invalid Checksum');
    return body.toString('hex');
};
const decode = (string, style = STYLES.MINIMAL)=>{
    switch(style){
        case STYLES.STANDARD:
            return _decode(string, ' ', BYTEWORD_LENGTH);
        case STYLES.URI:
            return _decode(string, '-', BYTEWORD_LENGTH);
        case STYLES.MINIMAL:
            return _decode(string, '', MINIMAL_BYTEWORD_LENGTH);
        default:
            throw new Error(`Invalid style ${style}`);
    }
};
const encode = (string, style = STYLES.MINIMAL)=>{
    switch(style){
        case STYLES.STANDARD:
            return encodeWithSeparator(string, ' ');
        case STYLES.URI:
            return encodeWithSeparator(string, '-');
        case STYLES.MINIMAL:
            return encodeMinimal(string);
        default:
            throw new Error(`Invalid style ${style}`);
    }
};
exports.default = {
    decode,
    encode,
    STYLES
}; //# sourceMappingURL=bytewords.js.map
}}),
"[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/urEncoder.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const fountainEncoder_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/fountainEncoder.js [app-ssr] (ecmascript)"));
const bytewords_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/bytewords.js [app-ssr] (ecmascript)"));
class UREncoder {
    constructor(_ur, maxFragmentLength, firstSeqNum, minFragmentLength){
        this.ur = _ur;
        this.fountainEncoder = new fountainEncoder_1.default(_ur.cbor, maxFragmentLength, firstSeqNum, minFragmentLength);
    }
    get fragmentsLength() {
        return this.fountainEncoder.fragmentsLength;
    }
    get fragments() {
        return this.fountainEncoder.fragments;
    }
    get messageLength() {
        return this.fountainEncoder.messageLength;
    }
    get cbor() {
        return this.ur.cbor;
    }
    encodeWhole() {
        return [
            ...new Array(this.fragmentsLength)
        ].map(()=>this.nextPart());
    }
    nextPart() {
        const part = this.fountainEncoder.nextPart();
        if (this.fountainEncoder.isSinglePart()) {
            return UREncoder.encodeSinglePart(this.ur);
        } else {
            return UREncoder.encodePart(this.ur.type, part);
        }
    }
    static encodeUri(scheme, pathComponents) {
        const path = pathComponents.join('/');
        return [
            scheme,
            path
        ].join(':');
    }
    static encodeUR(pathComponents) {
        return UREncoder.encodeUri('ur', pathComponents);
    }
    static encodePart(type, part) {
        const seq = `${part.seqNum}-${part.seqLength}`;
        const body = bytewords_1.default.encode(part.cbor().toString('hex'), bytewords_1.default.STYLES.MINIMAL);
        return UREncoder.encodeUR([
            type,
            seq,
            body
        ]);
    }
    static encodeSinglePart(ur) {
        const body = bytewords_1.default.encode(ur.cbor.toString('hex'), bytewords_1.default.STYLES.MINIMAL);
        return UREncoder.encodeUR([
            ur.type,
            body
        ]);
    }
}
exports.default = UREncoder; //# sourceMappingURL=urEncoder.js.map
}}),
"[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/fountainDecoder.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FountainDecoderPart = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/utils.js [app-ssr] (ecmascript)");
const fountainUtils_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/fountainUtils.js [app-ssr] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/errors.js [app-ssr] (ecmascript)");
class FountainDecoderPart {
    constructor(_indexes, _fragment){
        this._indexes = _indexes;
        this._fragment = _fragment;
    }
    get indexes() {
        return this._indexes;
    }
    get fragment() {
        return this._fragment;
    }
    static fromEncoderPart(encoderPart) {
        const indexes = fountainUtils_1.chooseFragments(encoderPart.seqNum, encoderPart.seqLength, encoderPart.checksum);
        const fragment = encoderPart.fragment;
        return new FountainDecoderPart(indexes, fragment);
    }
    isSimple() {
        return this.indexes.length === 1;
    }
}
exports.FountainDecoderPart = FountainDecoderPart;
class FountainDecoder {
    constructor(){
        this.result = undefined;
        this.expectedMessageLength = 0;
        this.expectedChecksum = 0;
        this.expectedFragmentLength = 0;
        this.processedPartsCount = 0;
        this.expectedPartIndexes = [];
        this.lastPartIndexes = [];
        this.queuedParts = [];
        this.receivedPartIndexes = [];
        this.mixedParts = [];
        this.simpleParts = [];
    }
    validatePart(part) {
        // If this is the first part we've seen
        if (this.expectedPartIndexes.length === 0) {
            // Record the things that all the other parts we see will have to match to be valid.
            [
                ...new Array(part.seqLength)
            ].forEach((_, index)=>this.expectedPartIndexes.push(index));
            this.expectedMessageLength = part.messageLength;
            this.expectedChecksum = part.checksum;
            this.expectedFragmentLength = part.fragment.length;
        } else {
            // If this part's values don't match the first part's values, throw away the part
            if (this.expectedPartIndexes.length !== part.seqLength) {
                return false;
            }
            if (this.expectedMessageLength !== part.messageLength) {
                return false;
            }
            if (this.expectedChecksum !== part.checksum) {
                return false;
            }
            if (this.expectedFragmentLength !== part.fragment.length) {
                return false;
            }
        }
        // This part should be processed
        return true;
    }
    reducePartByPart(a, b) {
        // If the fragments mixed into `b` are a strict (proper) subset of those in `a`...
        if (utils_1.arrayContains(a.indexes, b.indexes)) {
            const newIndexes = utils_1.setDifference(a.indexes, b.indexes);
            const newFragment = utils_1.bufferXOR(a.fragment, b.fragment);
            return new FountainDecoderPart(newIndexes, newFragment);
        } else {
            // `a` is not reducable by `b`, so return a
            return a;
        }
    }
    reduceMixedBy(part) {
        const newMixed = [];
        this.mixedParts.map(({ value: mixedPart })=>this.reducePartByPart(mixedPart, part)).forEach((reducedPart)=>{
            if (reducedPart.isSimple()) {
                this.queuedParts.push(reducedPart);
            } else {
                newMixed.push({
                    key: reducedPart.indexes,
                    value: reducedPart
                });
            }
        });
        this.mixedParts = newMixed;
    }
    processSimplePart(part) {
        // Don't process duplicate parts
        const fragmentIndex = part.indexes[0];
        if (this.receivedPartIndexes.includes(fragmentIndex)) {
            return;
        }
        this.simpleParts.push({
            key: part.indexes,
            value: part
        });
        this.receivedPartIndexes.push(fragmentIndex);
        // If we've received all the parts
        if (utils_1.arraysEqual(this.receivedPartIndexes, this.expectedPartIndexes)) {
            // Reassemble the message from its fragments
            const sortedParts = this.simpleParts.map(({ value })=>value).sort((a, b)=>a.indexes[0] - b.indexes[0]);
            const message = FountainDecoder.joinFragments(sortedParts.map((part)=>part.fragment), this.expectedMessageLength);
            const checksum = utils_1.getCRC(message);
            if (checksum === this.expectedChecksum) {
                this.result = message;
            } else {
                this.error = new errors_1.InvalidChecksumError();
            }
        } else {
            this.reduceMixedBy(part);
        }
    }
    processMixedPart(part) {
        // Don't process duplicate parts
        if (this.mixedParts.some(({ key: indexes })=>utils_1.arraysEqual(indexes, part.indexes))) {
            return;
        }
        // Reduce this part by all the others
        let p2 = this.simpleParts.reduce((acc, { value: p })=>this.reducePartByPart(acc, p), part);
        p2 = this.mixedParts.reduce((acc, { value: p })=>this.reducePartByPart(acc, p), p2);
        // If the part is now simple
        if (p2.isSimple()) {
            // Add it to the queue
            this.queuedParts.push(p2);
        } else {
            this.reduceMixedBy(p2);
            this.mixedParts.push({
                key: p2.indexes,
                value: p2
            });
        }
    }
    processQueuedItem() {
        if (this.queuedParts.length === 0) {
            return;
        }
        const part = this.queuedParts.shift();
        if (part.isSimple()) {
            this.processSimplePart(part);
        } else {
            this.processMixedPart(part);
        }
    }
    receivePart(encoderPart) {
        if (this.isComplete()) {
            return false;
        }
        if (!this.validatePart(encoderPart)) {
            return false;
        }
        const decoderPart = FountainDecoderPart.fromEncoderPart(encoderPart);
        this.lastPartIndexes = decoderPart.indexes;
        this.queuedParts.push(decoderPart);
        while(!this.isComplete() && this.queuedParts.length > 0){
            this.processQueuedItem();
        }
        ;
        this.processedPartsCount += 1;
        return true;
    }
    isComplete() {
        return Boolean(this.result !== undefined && this.result.length > 0);
    }
    isSuccess() {
        return Boolean(this.error === undefined && this.isComplete());
    }
    resultMessage() {
        return this.isSuccess() ? this.result : Buffer.from([]);
    }
    isFailure() {
        return this.error !== undefined;
    }
    resultError() {
        return this.error ? this.error.message : '';
    }
    expectedPartCount() {
        return this.expectedPartIndexes.length;
    }
    getExpectedPartIndexes() {
        return [
            ...this.expectedPartIndexes
        ];
    }
    getReceivedPartIndexes() {
        return [
            ...this.receivedPartIndexes
        ];
    }
    getLastPartIndexes() {
        return [
            ...this.lastPartIndexes
        ];
    }
    estimatedPercentComplete() {
        if (this.isComplete()) {
            return 1;
        }
        const expectedPartCount = this.expectedPartCount();
        if (expectedPartCount === 0) {
            return 0;
        }
        // We multiply the expectedPartCount by `1.75` as a way to compensate for the facet
        // that `this.processedPartsCount` also tracks the duplicate parts that have been
        // processeed.
        return Math.min(0.99, this.processedPartsCount / (expectedPartCount * 1.75));
    }
    getProgress() {
        if (this.isComplete()) {
            return 1;
        }
        const expectedPartCount = this.expectedPartCount();
        if (expectedPartCount === 0) {
            return 0;
        }
        return this.receivedPartIndexes.length / expectedPartCount;
    }
}
exports.default = FountainDecoder;
FountainDecoder.joinFragments = (fragments, messageLength)=>{
    return Buffer.concat(fragments).slice(0, messageLength);
}; //# sourceMappingURL=fountainDecoder.js.map
}}),
"[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/urDecoder.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const fountainDecoder_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/fountainDecoder.js [app-ssr] (ecmascript)"));
const bytewords_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/bytewords.js [app-ssr] (ecmascript)"));
const assert_1 = __importDefault(__turbopack_context__.r("[externals]/assert [external] (assert, cjs)"));
const utils_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/utils.js [app-ssr] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/errors.js [app-ssr] (ecmascript)");
const ur_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/ur.js [app-ssr] (ecmascript)"));
const fountainEncoder_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/fountainEncoder.js [app-ssr] (ecmascript)");
class URDecoder {
    constructor(fountainDecoder = new fountainDecoder_1.default(), type = 'bytes'){
        this.fountainDecoder = fountainDecoder;
        this.type = type;
        assert_1.default(utils_1.isURType(type), 'Invalid UR type');
        this.expected_type = '';
    }
    static decodeBody(type, message) {
        const cbor = bytewords_1.default.decode(message, bytewords_1.default.STYLES.MINIMAL);
        return new ur_1.default(Buffer.from(cbor, 'hex'), type);
    }
    validatePart(type) {
        if (this.expected_type) {
            return this.expected_type === type;
        }
        if (!utils_1.isURType(type)) {
            return false;
        }
        this.expected_type = type;
        return true;
    }
    static decode(message) {
        const [type, components] = this.parse(message);
        if (components.length === 0) {
            throw new errors_1.InvalidPathLengthError();
        }
        const body = components[0];
        return URDecoder.decodeBody(type, body);
    }
    static parse(message) {
        const lowercase = message.toLowerCase();
        const prefix = lowercase.slice(0, 3);
        if (prefix !== 'ur:') {
            throw new errors_1.InvalidSchemeError();
        }
        const components = lowercase.slice(3).split('/');
        const type = components[0];
        if (components.length < 2) {
            throw new errors_1.InvalidPathLengthError();
        }
        if (!utils_1.isURType(type)) {
            throw new errors_1.InvalidTypeError();
        }
        return [
            type,
            components.slice(1)
        ];
    }
    static parseSequenceComponent(s) {
        const components = s.split('-');
        if (components.length !== 2) {
            throw new errors_1.InvalidSequenceComponentError();
        }
        const seqNum = utils_1.toUint32(Number(components[0]));
        const seqLength = Number(components[1]);
        if (seqNum < 1 || seqLength < 1) {
            throw new errors_1.InvalidSequenceComponentError();
        }
        return [
            seqNum,
            seqLength
        ];
    }
    receivePart(s) {
        if (this.result !== undefined) {
            return false;
        }
        const [type, components] = URDecoder.parse(s);
        if (!this.validatePart(type)) {
            return false;
        }
        // If this is a single-part UR then we're done
        if (components.length === 1) {
            this.result = URDecoder.decodeBody(type, components[0]);
            return true;
        }
        if (components.length !== 2) {
            throw new errors_1.InvalidPathLengthError();
        }
        const [seq, fragment] = components;
        const [seqNum, seqLength] = URDecoder.parseSequenceComponent(seq);
        const cbor = bytewords_1.default.decode(fragment, bytewords_1.default.STYLES.MINIMAL);
        const part = fountainEncoder_1.FountainEncoderPart.fromCBOR(cbor);
        if (seqNum !== part.seqNum || seqLength !== part.seqLength) {
            return false;
        }
        if (!this.fountainDecoder.receivePart(part)) {
            return false;
        }
        if (this.fountainDecoder.isSuccess()) {
            this.result = new ur_1.default(this.fountainDecoder.resultMessage(), type);
        } else if (this.fountainDecoder.isFailure()) {
            this.error = new errors_1.InvalidSchemeError();
        }
        return true;
    }
    resultUR() {
        return this.result ? this.result : new ur_1.default(Buffer.from([]));
    }
    isComplete() {
        return this.result && this.result.cbor.length > 0;
    }
    isSuccess() {
        return !this.error && this.isComplete();
    }
    isError() {
        return this.error !== undefined;
    }
    resultError() {
        return this.error ? this.error.message : '';
    }
    expectedPartCount() {
        return this.fountainDecoder.expectedPartCount();
    }
    expectedPartIndexes() {
        return this.fountainDecoder.getExpectedPartIndexes();
    }
    receivedPartIndexes() {
        return this.fountainDecoder.getReceivedPartIndexes();
    }
    lastPartIndexes() {
        return this.fountainDecoder.getLastPartIndexes();
    }
    estimatedPercentComplete() {
        return this.fountainDecoder.estimatedPercentComplete();
    }
    getProgress() {
        return this.fountainDecoder.getProgress();
    }
}
exports.default = URDecoder; //# sourceMappingURL=urDecoder.js.map
}}),
"[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.URDecoder = exports.UREncoder = exports.UR = void 0;
const ur_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/ur.js [app-ssr] (ecmascript)"));
exports.UR = ur_1.default;
const urEncoder_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/urEncoder.js [app-ssr] (ecmascript)"));
exports.UREncoder = urEncoder_1.default;
const urDecoder_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/urDecoder.js [app-ssr] (ecmascript)"));
exports.URDecoder = urDecoder_1.default; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var Buffer = __turbopack_context__.r("[project]/node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js [app-ssr] (ecmascript)").Buffer;
// prototype class for hash functions
function Hash(blockSize, finalSize) {
    this._block = Buffer.alloc(blockSize);
    this._finalSize = finalSize;
    this._blockSize = blockSize;
    this._len = 0;
}
Hash.prototype.update = function(data, enc) {
    if (typeof data === 'string') {
        enc = enc || 'utf8';
        data = Buffer.from(data, enc);
    }
    var block = this._block;
    var blockSize = this._blockSize;
    var length = data.length;
    var accum = this._len;
    for(var offset = 0; offset < length;){
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for(var i = 0; i < remainder; i++){
            block[assigned + i] = data[offset + i];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
            this._update(block);
        }
    }
    this._len += length;
    return this;
};
Hash.prototype.digest = function(enc) {
    var rem = this._len % this._blockSize;
    this._block[rem] = 0x80;
    // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
    // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
    this._block.fill(0, rem + 1);
    if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
    }
    var bits = this._len * 8;
    // uint32
    if (bits <= 0xffffffff) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
    // uint64
    } else {
        var lowBits = (bits & 0xffffffff) >>> 0;
        var highBits = (bits - lowBits) / 0x100000000;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
    }
    this._update(this._block);
    var hash = this._hash();
    return enc ? hash.toString(enc) : hash;
};
Hash.prototype._update = function() {
    throw new Error('_update must be implemented by subclass');
};
module.exports = Hash;
}}),
"[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */ var inherits = __turbopack_context__.r("[project]/node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js [app-ssr] (ecmascript)");
var Hash = __turbopack_context__.r("[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js [app-ssr] (ecmascript)");
var Buffer = __turbopack_context__.r("[project]/node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js [app-ssr] (ecmascript)").Buffer;
var K = [
    0x5a827999,
    0x6ed9eba1,
    0x8f1bbcdc | 0,
    0xca62c1d6 | 0
];
var W = new Array(80);
function Sha() {
    this.init();
    this._w = W;
    Hash.call(this, 64, 56);
}
inherits(Sha, Hash);
Sha.prototype.init = function() {
    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
    this._e = 0xc3d2e1f0;
    return this;
};
function rotl5(num) {
    return num << 5 | num >>> 27;
}
function rotl30(num) {
    return num << 30 | num >>> 2;
}
function ft(s, b, c, d) {
    if (s === 0) return b & c | ~b & d;
    if (s === 2) return b & c | b & d | c & d;
    return b ^ c ^ d;
}
Sha.prototype._update = function(M) {
    var W = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    for(var i = 0; i < 16; ++i)W[i] = M.readInt32BE(i * 4);
    for(; i < 80; ++i)W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
    for(var j = 0; j < 80; ++j){
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
};
Sha.prototype._hash = function() {
    var H = Buffer.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
};
module.exports = Sha;
}}),
"[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha1.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */ var inherits = __turbopack_context__.r("[project]/node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js [app-ssr] (ecmascript)");
var Hash = __turbopack_context__.r("[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js [app-ssr] (ecmascript)");
var Buffer = __turbopack_context__.r("[project]/node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js [app-ssr] (ecmascript)").Buffer;
var K = [
    0x5a827999,
    0x6ed9eba1,
    0x8f1bbcdc | 0,
    0xca62c1d6 | 0
];
var W = new Array(80);
function Sha1() {
    this.init();
    this._w = W;
    Hash.call(this, 64, 56);
}
inherits(Sha1, Hash);
Sha1.prototype.init = function() {
    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
    this._e = 0xc3d2e1f0;
    return this;
};
function rotl1(num) {
    return num << 1 | num >>> 31;
}
function rotl5(num) {
    return num << 5 | num >>> 27;
}
function rotl30(num) {
    return num << 30 | num >>> 2;
}
function ft(s, b, c, d) {
    if (s === 0) return b & c | ~b & d;
    if (s === 2) return b & c | b & d | c & d;
    return b ^ c ^ d;
}
Sha1.prototype._update = function(M) {
    var W = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    for(var i = 0; i < 16; ++i)W[i] = M.readInt32BE(i * 4);
    for(; i < 80; ++i)W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);
    for(var j = 0; j < 80; ++j){
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
};
Sha1.prototype._hash = function() {
    var H = Buffer.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
};
module.exports = Sha1;
}}),
"[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha256.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */ var inherits = __turbopack_context__.r("[project]/node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js [app-ssr] (ecmascript)");
var Hash = __turbopack_context__.r("[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js [app-ssr] (ecmascript)");
var Buffer = __turbopack_context__.r("[project]/node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js [app-ssr] (ecmascript)").Buffer;
var K = [
    0x428A2F98,
    0x71374491,
    0xB5C0FBCF,
    0xE9B5DBA5,
    0x3956C25B,
    0x59F111F1,
    0x923F82A4,
    0xAB1C5ED5,
    0xD807AA98,
    0x12835B01,
    0x243185BE,
    0x550C7DC3,
    0x72BE5D74,
    0x80DEB1FE,
    0x9BDC06A7,
    0xC19BF174,
    0xE49B69C1,
    0xEFBE4786,
    0x0FC19DC6,
    0x240CA1CC,
    0x2DE92C6F,
    0x4A7484AA,
    0x5CB0A9DC,
    0x76F988DA,
    0x983E5152,
    0xA831C66D,
    0xB00327C8,
    0xBF597FC7,
    0xC6E00BF3,
    0xD5A79147,
    0x06CA6351,
    0x14292967,
    0x27B70A85,
    0x2E1B2138,
    0x4D2C6DFC,
    0x53380D13,
    0x650A7354,
    0x766A0ABB,
    0x81C2C92E,
    0x92722C85,
    0xA2BFE8A1,
    0xA81A664B,
    0xC24B8B70,
    0xC76C51A3,
    0xD192E819,
    0xD6990624,
    0xF40E3585,
    0x106AA070,
    0x19A4C116,
    0x1E376C08,
    0x2748774C,
    0x34B0BCB5,
    0x391C0CB3,
    0x4ED8AA4A,
    0x5B9CCA4F,
    0x682E6FF3,
    0x748F82EE,
    0x78A5636F,
    0x84C87814,
    0x8CC70208,
    0x90BEFFFA,
    0xA4506CEB,
    0xBEF9A3F7,
    0xC67178F2
];
var W = new Array(64);
function Sha256() {
    this.init();
    this._w = W // new Array(64)
    ;
    Hash.call(this, 64, 56);
}
inherits(Sha256, Hash);
Sha256.prototype.init = function() {
    this._a = 0x6a09e667;
    this._b = 0xbb67ae85;
    this._c = 0x3c6ef372;
    this._d = 0xa54ff53a;
    this._e = 0x510e527f;
    this._f = 0x9b05688c;
    this._g = 0x1f83d9ab;
    this._h = 0x5be0cd19;
    return this;
};
function ch(x, y, z) {
    return z ^ x & (y ^ z);
}
function maj(x, y, z) {
    return x & y | z & (x | y);
}
function sigma0(x) {
    return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
}
function sigma1(x) {
    return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
}
function gamma0(x) {
    return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
}
function gamma1(x) {
    return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
}
Sha256.prototype._update = function(M) {
    var W = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    var f = this._f | 0;
    var g = this._g | 0;
    var h = this._h | 0;
    for(var i = 0; i < 16; ++i)W[i] = M.readInt32BE(i * 4);
    for(; i < 64; ++i)W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16] | 0;
    for(var j = 0; j < 64; ++j){
        var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W[j] | 0;
        var T2 = sigma0(a) + maj(a, b, c) | 0;
        h = g;
        g = f;
        f = e;
        e = d + T1 | 0;
        d = c;
        c = b;
        b = a;
        a = T1 + T2 | 0;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
    this._f = f + this._f | 0;
    this._g = g + this._g | 0;
    this._h = h + this._h | 0;
};
Sha256.prototype._hash = function() {
    var H = Buffer.allocUnsafe(32);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    H.writeInt32BE(this._h, 28);
    return H;
};
module.exports = Sha256;
}}),
"[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha224.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */ var inherits = __turbopack_context__.r("[project]/node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js [app-ssr] (ecmascript)");
var Sha256 = __turbopack_context__.r("[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha256.js [app-ssr] (ecmascript)");
var Hash = __turbopack_context__.r("[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js [app-ssr] (ecmascript)");
var Buffer = __turbopack_context__.r("[project]/node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js [app-ssr] (ecmascript)").Buffer;
var W = new Array(64);
function Sha224() {
    this.init();
    this._w = W // new Array(64)
    ;
    Hash.call(this, 64, 56);
}
inherits(Sha224, Sha256);
Sha224.prototype.init = function() {
    this._a = 0xc1059ed8;
    this._b = 0x367cd507;
    this._c = 0x3070dd17;
    this._d = 0xf70e5939;
    this._e = 0xffc00b31;
    this._f = 0x68581511;
    this._g = 0x64f98fa7;
    this._h = 0xbefa4fa4;
    return this;
};
Sha224.prototype._hash = function() {
    var H = Buffer.allocUnsafe(28);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    return H;
};
module.exports = Sha224;
}}),
"[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha512.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var inherits = __turbopack_context__.r("[project]/node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js [app-ssr] (ecmascript)");
var Hash = __turbopack_context__.r("[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js [app-ssr] (ecmascript)");
var Buffer = __turbopack_context__.r("[project]/node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js [app-ssr] (ecmascript)").Buffer;
var K = [
    0x428a2f98,
    0xd728ae22,
    0x71374491,
    0x23ef65cd,
    0xb5c0fbcf,
    0xec4d3b2f,
    0xe9b5dba5,
    0x8189dbbc,
    0x3956c25b,
    0xf348b538,
    0x59f111f1,
    0xb605d019,
    0x923f82a4,
    0xaf194f9b,
    0xab1c5ed5,
    0xda6d8118,
    0xd807aa98,
    0xa3030242,
    0x12835b01,
    0x45706fbe,
    0x243185be,
    0x4ee4b28c,
    0x550c7dc3,
    0xd5ffb4e2,
    0x72be5d74,
    0xf27b896f,
    0x80deb1fe,
    0x3b1696b1,
    0x9bdc06a7,
    0x25c71235,
    0xc19bf174,
    0xcf692694,
    0xe49b69c1,
    0x9ef14ad2,
    0xefbe4786,
    0x384f25e3,
    0x0fc19dc6,
    0x8b8cd5b5,
    0x240ca1cc,
    0x77ac9c65,
    0x2de92c6f,
    0x592b0275,
    0x4a7484aa,
    0x6ea6e483,
    0x5cb0a9dc,
    0xbd41fbd4,
    0x76f988da,
    0x831153b5,
    0x983e5152,
    0xee66dfab,
    0xa831c66d,
    0x2db43210,
    0xb00327c8,
    0x98fb213f,
    0xbf597fc7,
    0xbeef0ee4,
    0xc6e00bf3,
    0x3da88fc2,
    0xd5a79147,
    0x930aa725,
    0x06ca6351,
    0xe003826f,
    0x14292967,
    0x0a0e6e70,
    0x27b70a85,
    0x46d22ffc,
    0x2e1b2138,
    0x5c26c926,
    0x4d2c6dfc,
    0x5ac42aed,
    0x53380d13,
    0x9d95b3df,
    0x650a7354,
    0x8baf63de,
    0x766a0abb,
    0x3c77b2a8,
    0x81c2c92e,
    0x47edaee6,
    0x92722c85,
    0x1482353b,
    0xa2bfe8a1,
    0x4cf10364,
    0xa81a664b,
    0xbc423001,
    0xc24b8b70,
    0xd0f89791,
    0xc76c51a3,
    0x0654be30,
    0xd192e819,
    0xd6ef5218,
    0xd6990624,
    0x5565a910,
    0xf40e3585,
    0x5771202a,
    0x106aa070,
    0x32bbd1b8,
    0x19a4c116,
    0xb8d2d0c8,
    0x1e376c08,
    0x5141ab53,
    0x2748774c,
    0xdf8eeb99,
    0x34b0bcb5,
    0xe19b48a8,
    0x391c0cb3,
    0xc5c95a63,
    0x4ed8aa4a,
    0xe3418acb,
    0x5b9cca4f,
    0x7763e373,
    0x682e6ff3,
    0xd6b2b8a3,
    0x748f82ee,
    0x5defb2fc,
    0x78a5636f,
    0x43172f60,
    0x84c87814,
    0xa1f0ab72,
    0x8cc70208,
    0x1a6439ec,
    0x90befffa,
    0x23631e28,
    0xa4506ceb,
    0xde82bde9,
    0xbef9a3f7,
    0xb2c67915,
    0xc67178f2,
    0xe372532b,
    0xca273ece,
    0xea26619c,
    0xd186b8c7,
    0x21c0c207,
    0xeada7dd6,
    0xcde0eb1e,
    0xf57d4f7f,
    0xee6ed178,
    0x06f067aa,
    0x72176fba,
    0x0a637dc5,
    0xa2c898a6,
    0x113f9804,
    0xbef90dae,
    0x1b710b35,
    0x131c471b,
    0x28db77f5,
    0x23047d84,
    0x32caab7b,
    0x40c72493,
    0x3c9ebe0a,
    0x15c9bebc,
    0x431d67c4,
    0x9c100d4c,
    0x4cc5d4be,
    0xcb3e42b6,
    0x597f299c,
    0xfc657e2a,
    0x5fcb6fab,
    0x3ad6faec,
    0x6c44198c,
    0x4a475817
];
var W = new Array(160);
function Sha512() {
    this.init();
    this._w = W;
    Hash.call(this, 128, 112);
}
inherits(Sha512, Hash);
Sha512.prototype.init = function() {
    this._ah = 0x6a09e667;
    this._bh = 0xbb67ae85;
    this._ch = 0x3c6ef372;
    this._dh = 0xa54ff53a;
    this._eh = 0x510e527f;
    this._fh = 0x9b05688c;
    this._gh = 0x1f83d9ab;
    this._hh = 0x5be0cd19;
    this._al = 0xf3bcc908;
    this._bl = 0x84caa73b;
    this._cl = 0xfe94f82b;
    this._dl = 0x5f1d36f1;
    this._el = 0xade682d1;
    this._fl = 0x2b3e6c1f;
    this._gl = 0xfb41bd6b;
    this._hl = 0x137e2179;
    return this;
};
function Ch(x, y, z) {
    return z ^ x & (y ^ z);
}
function maj(x, y, z) {
    return x & y | z & (x | y);
}
function sigma0(x, xl) {
    return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
}
function sigma1(x, xl) {
    return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
}
function Gamma0(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
}
function Gamma0l(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
}
function Gamma1(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
}
function Gamma1l(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
}
function getCarry(a, b) {
    return a >>> 0 < b >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(M) {
    var W = this._w;
    var ah = this._ah | 0;
    var bh = this._bh | 0;
    var ch = this._ch | 0;
    var dh = this._dh | 0;
    var eh = this._eh | 0;
    var fh = this._fh | 0;
    var gh = this._gh | 0;
    var hh = this._hh | 0;
    var al = this._al | 0;
    var bl = this._bl | 0;
    var cl = this._cl | 0;
    var dl = this._dl | 0;
    var el = this._el | 0;
    var fl = this._fl | 0;
    var gl = this._gl | 0;
    var hl = this._hl | 0;
    for(var i = 0; i < 32; i += 2){
        W[i] = M.readInt32BE(i * 4);
        W[i + 1] = M.readInt32BE(i * 4 + 4);
    }
    for(; i < 160; i += 2){
        var xh = W[i - 15 * 2];
        var xl = W[i - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = W[i - 2 * 2];
        xl = W[i - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
        var Wi7h = W[i - 7 * 2];
        var Wi7l = W[i - 7 * 2 + 1];
        var Wi16h = W[i - 16 * 2];
        var Wi16l = W[i - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        W[i] = Wih;
        W[i + 1] = Wil;
    }
    for(var j = 0; j < 160; j += 2){
        Wih = W[j];
        Wil = W[j + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        // t1 = h + sigma1 + ch + K[j] + W[j]
        var Kih = K[j];
        var Kil = K[j + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        // t2 = sigma0 + maj
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
    }
    this._al = this._al + al | 0;
    this._bl = this._bl + bl | 0;
    this._cl = this._cl + cl | 0;
    this._dl = this._dl + dl | 0;
    this._el = this._el + el | 0;
    this._fl = this._fl + fl | 0;
    this._gl = this._gl + gl | 0;
    this._hl = this._hl + hl | 0;
    this._ah = this._ah + ah + getCarry(this._al, al) | 0;
    this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
    this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
    this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
    this._eh = this._eh + eh + getCarry(this._el, el) | 0;
    this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
    this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
    this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
};
Sha512.prototype._hash = function() {
    var H = Buffer.allocUnsafe(64);
    function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
    }
    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    writeInt64BE(this._gh, this._gl, 48);
    writeInt64BE(this._hh, this._hl, 56);
    return H;
};
module.exports = Sha512;
}}),
"[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha384.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var inherits = __turbopack_context__.r("[project]/node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js [app-ssr] (ecmascript)");
var SHA512 = __turbopack_context__.r("[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha512.js [app-ssr] (ecmascript)");
var Hash = __turbopack_context__.r("[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js [app-ssr] (ecmascript)");
var Buffer = __turbopack_context__.r("[project]/node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js [app-ssr] (ecmascript)").Buffer;
var W = new Array(160);
function Sha384() {
    this.init();
    this._w = W;
    Hash.call(this, 128, 112);
}
inherits(Sha384, SHA512);
Sha384.prototype.init = function() {
    this._ah = 0xcbbb9d5d;
    this._bh = 0x629a292a;
    this._ch = 0x9159015a;
    this._dh = 0x152fecd8;
    this._eh = 0x67332667;
    this._fh = 0x8eb44a87;
    this._gh = 0xdb0c2e0d;
    this._hh = 0x47b5481d;
    this._al = 0xc1059ed8;
    this._bl = 0x367cd507;
    this._cl = 0x3070dd17;
    this._dl = 0xf70e5939;
    this._el = 0xffc00b31;
    this._fl = 0x68581511;
    this._gl = 0x64f98fa7;
    this._hl = 0xbefa4fa4;
    return this;
};
Sha384.prototype._hash = function() {
    var H = Buffer.allocUnsafe(48);
    function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
    }
    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    return H;
};
module.exports = Sha384;
}}),
"[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var exports = module.exports = function SHA(algorithm) {
    algorithm = algorithm.toLowerCase();
    var Algorithm = exports[algorithm];
    if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)');
    return new Algorithm();
};
exports.sha = __turbopack_context__.r("[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha.js [app-ssr] (ecmascript)");
exports.sha1 = __turbopack_context__.r("[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha1.js [app-ssr] (ecmascript)");
exports.sha224 = __turbopack_context__.r("[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha224.js [app-ssr] (ecmascript)");
exports.sha256 = __turbopack_context__.r("[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha256.js [app-ssr] (ecmascript)");
exports.sha384 = __turbopack_context__.r("[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha384.js [app-ssr] (ecmascript)");
exports.sha512 = __turbopack_context__.r("[project]/node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha512.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/create_buffer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/buffer [external] (buffer, cjs)");
;
const createBuffer = __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__["Buffer"].from && __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__["Buffer"].alloc && __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__["Buffer"].allocUnsafe && __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__["Buffer"].allocUnsafeSlow ? __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__["Buffer"].from : (val)=>new __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__["Buffer"](val);
const __TURBOPACK__default__export__ = createBuffer;
}}),
"[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/define_crc.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(model, calc) {
    const fn = (buf, previous)=>calc(buf, previous) >>> 0;
    fn.signed = calc;
    fn.unsigned = fn;
    fn.model = model;
    return fn;
}
}}),
"[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc1.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/buffer [external] (buffer, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/create_buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/define_crc.js [app-ssr] (ecmascript)");
;
;
;
const crc1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])('crc1', function(buf, previous) {
    if (!__TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__["Buffer"].isBuffer(buf)) buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(buf);
    let crc = ~~previous;
    let accum = 0;
    for(let index = 0; index < buf.length; index++){
        const byte = buf[index];
        accum += byte;
    }
    crc += accum % 256;
    return crc % 256;
});
const __TURBOPACK__default__export__ = crc1;
}}),
"[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc8.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/buffer [external] (buffer, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/create_buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/define_crc.js [app-ssr] (ecmascript)");
;
;
;
// Generated by `./pycrc.py --algorithm=table-driven --model=crc-8 --generate=c`
// prettier-ignore
let TABLE = [
    0x00,
    0x07,
    0x0e,
    0x09,
    0x1c,
    0x1b,
    0x12,
    0x15,
    0x38,
    0x3f,
    0x36,
    0x31,
    0x24,
    0x23,
    0x2a,
    0x2d,
    0x70,
    0x77,
    0x7e,
    0x79,
    0x6c,
    0x6b,
    0x62,
    0x65,
    0x48,
    0x4f,
    0x46,
    0x41,
    0x54,
    0x53,
    0x5a,
    0x5d,
    0xe0,
    0xe7,
    0xee,
    0xe9,
    0xfc,
    0xfb,
    0xf2,
    0xf5,
    0xd8,
    0xdf,
    0xd6,
    0xd1,
    0xc4,
    0xc3,
    0xca,
    0xcd,
    0x90,
    0x97,
    0x9e,
    0x99,
    0x8c,
    0x8b,
    0x82,
    0x85,
    0xa8,
    0xaf,
    0xa6,
    0xa1,
    0xb4,
    0xb3,
    0xba,
    0xbd,
    0xc7,
    0xc0,
    0xc9,
    0xce,
    0xdb,
    0xdc,
    0xd5,
    0xd2,
    0xff,
    0xf8,
    0xf1,
    0xf6,
    0xe3,
    0xe4,
    0xed,
    0xea,
    0xb7,
    0xb0,
    0xb9,
    0xbe,
    0xab,
    0xac,
    0xa5,
    0xa2,
    0x8f,
    0x88,
    0x81,
    0x86,
    0x93,
    0x94,
    0x9d,
    0x9a,
    0x27,
    0x20,
    0x29,
    0x2e,
    0x3b,
    0x3c,
    0x35,
    0x32,
    0x1f,
    0x18,
    0x11,
    0x16,
    0x03,
    0x04,
    0x0d,
    0x0a,
    0x57,
    0x50,
    0x59,
    0x5e,
    0x4b,
    0x4c,
    0x45,
    0x42,
    0x6f,
    0x68,
    0x61,
    0x66,
    0x73,
    0x74,
    0x7d,
    0x7a,
    0x89,
    0x8e,
    0x87,
    0x80,
    0x95,
    0x92,
    0x9b,
    0x9c,
    0xb1,
    0xb6,
    0xbf,
    0xb8,
    0xad,
    0xaa,
    0xa3,
    0xa4,
    0xf9,
    0xfe,
    0xf7,
    0xf0,
    0xe5,
    0xe2,
    0xeb,
    0xec,
    0xc1,
    0xc6,
    0xcf,
    0xc8,
    0xdd,
    0xda,
    0xd3,
    0xd4,
    0x69,
    0x6e,
    0x67,
    0x60,
    0x75,
    0x72,
    0x7b,
    0x7c,
    0x51,
    0x56,
    0x5f,
    0x58,
    0x4d,
    0x4a,
    0x43,
    0x44,
    0x19,
    0x1e,
    0x17,
    0x10,
    0x05,
    0x02,
    0x0b,
    0x0c,
    0x21,
    0x26,
    0x2f,
    0x28,
    0x3d,
    0x3a,
    0x33,
    0x34,
    0x4e,
    0x49,
    0x40,
    0x47,
    0x52,
    0x55,
    0x5c,
    0x5b,
    0x76,
    0x71,
    0x78,
    0x7f,
    0x6a,
    0x6d,
    0x64,
    0x63,
    0x3e,
    0x39,
    0x30,
    0x37,
    0x22,
    0x25,
    0x2c,
    0x2b,
    0x06,
    0x01,
    0x08,
    0x0f,
    0x1a,
    0x1d,
    0x14,
    0x13,
    0xae,
    0xa9,
    0xa0,
    0xa7,
    0xb2,
    0xb5,
    0xbc,
    0xbb,
    0x96,
    0x91,
    0x98,
    0x9f,
    0x8a,
    0x8d,
    0x84,
    0x83,
    0xde,
    0xd9,
    0xd0,
    0xd7,
    0xc2,
    0xc5,
    0xcc,
    0xcb,
    0xe6,
    0xe1,
    0xe8,
    0xef,
    0xfa,
    0xfd,
    0xf4,
    0xf3
];
if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);
const crc8 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])('crc-8', function(buf, previous) {
    if (!__TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__["Buffer"].isBuffer(buf)) buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(buf);
    let crc = ~~previous;
    for(let index = 0; index < buf.length; index++){
        const byte = buf[index];
        crc = TABLE[(crc ^ byte) & 0xff] & 0xff;
    }
    return crc;
});
const __TURBOPACK__default__export__ = crc8;
}}),
"[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc81wire.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/buffer [external] (buffer, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/create_buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/define_crc.js [app-ssr] (ecmascript)");
;
;
;
// Generated by `./pycrc.py --algorithm=table-driven --model=dallas-1-wire --generate=c`
// prettier-ignore
let TABLE = [
    0x00,
    0x5e,
    0xbc,
    0xe2,
    0x61,
    0x3f,
    0xdd,
    0x83,
    0xc2,
    0x9c,
    0x7e,
    0x20,
    0xa3,
    0xfd,
    0x1f,
    0x41,
    0x9d,
    0xc3,
    0x21,
    0x7f,
    0xfc,
    0xa2,
    0x40,
    0x1e,
    0x5f,
    0x01,
    0xe3,
    0xbd,
    0x3e,
    0x60,
    0x82,
    0xdc,
    0x23,
    0x7d,
    0x9f,
    0xc1,
    0x42,
    0x1c,
    0xfe,
    0xa0,
    0xe1,
    0xbf,
    0x5d,
    0x03,
    0x80,
    0xde,
    0x3c,
    0x62,
    0xbe,
    0xe0,
    0x02,
    0x5c,
    0xdf,
    0x81,
    0x63,
    0x3d,
    0x7c,
    0x22,
    0xc0,
    0x9e,
    0x1d,
    0x43,
    0xa1,
    0xff,
    0x46,
    0x18,
    0xfa,
    0xa4,
    0x27,
    0x79,
    0x9b,
    0xc5,
    0x84,
    0xda,
    0x38,
    0x66,
    0xe5,
    0xbb,
    0x59,
    0x07,
    0xdb,
    0x85,
    0x67,
    0x39,
    0xba,
    0xe4,
    0x06,
    0x58,
    0x19,
    0x47,
    0xa5,
    0xfb,
    0x78,
    0x26,
    0xc4,
    0x9a,
    0x65,
    0x3b,
    0xd9,
    0x87,
    0x04,
    0x5a,
    0xb8,
    0xe6,
    0xa7,
    0xf9,
    0x1b,
    0x45,
    0xc6,
    0x98,
    0x7a,
    0x24,
    0xf8,
    0xa6,
    0x44,
    0x1a,
    0x99,
    0xc7,
    0x25,
    0x7b,
    0x3a,
    0x64,
    0x86,
    0xd8,
    0x5b,
    0x05,
    0xe7,
    0xb9,
    0x8c,
    0xd2,
    0x30,
    0x6e,
    0xed,
    0xb3,
    0x51,
    0x0f,
    0x4e,
    0x10,
    0xf2,
    0xac,
    0x2f,
    0x71,
    0x93,
    0xcd,
    0x11,
    0x4f,
    0xad,
    0xf3,
    0x70,
    0x2e,
    0xcc,
    0x92,
    0xd3,
    0x8d,
    0x6f,
    0x31,
    0xb2,
    0xec,
    0x0e,
    0x50,
    0xaf,
    0xf1,
    0x13,
    0x4d,
    0xce,
    0x90,
    0x72,
    0x2c,
    0x6d,
    0x33,
    0xd1,
    0x8f,
    0x0c,
    0x52,
    0xb0,
    0xee,
    0x32,
    0x6c,
    0x8e,
    0xd0,
    0x53,
    0x0d,
    0xef,
    0xb1,
    0xf0,
    0xae,
    0x4c,
    0x12,
    0x91,
    0xcf,
    0x2d,
    0x73,
    0xca,
    0x94,
    0x76,
    0x28,
    0xab,
    0xf5,
    0x17,
    0x49,
    0x08,
    0x56,
    0xb4,
    0xea,
    0x69,
    0x37,
    0xd5,
    0x8b,
    0x57,
    0x09,
    0xeb,
    0xb5,
    0x36,
    0x68,
    0x8a,
    0xd4,
    0x95,
    0xcb,
    0x29,
    0x77,
    0xf4,
    0xaa,
    0x48,
    0x16,
    0xe9,
    0xb7,
    0x55,
    0x0b,
    0x88,
    0xd6,
    0x34,
    0x6a,
    0x2b,
    0x75,
    0x97,
    0xc9,
    0x4a,
    0x14,
    0xf6,
    0xa8,
    0x74,
    0x2a,
    0xc8,
    0x96,
    0x15,
    0x4b,
    0xa9,
    0xf7,
    0xb6,
    0xe8,
    0x0a,
    0x54,
    0xd7,
    0x89,
    0x6b,
    0x35
];
if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);
const crc81wire = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])('dallas-1-wire', function(buf, previous) {
    if (!__TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__["Buffer"].isBuffer(buf)) buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(buf);
    let crc = ~~previous;
    for(let index = 0; index < buf.length; index++){
        const byte = buf[index];
        crc = TABLE[(crc ^ byte) & 0xff] & 0xff;
    }
    return crc;
});
const __TURBOPACK__default__export__ = crc81wire;
}}),
"[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/buffer [external] (buffer, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/create_buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/define_crc.js [app-ssr] (ecmascript)");
;
;
;
// Generated by `./pycrc.py --algorithm=table-driven --model=crc-16 --generate=c`
// prettier-ignore
let TABLE = [
    0x0000,
    0xc0c1,
    0xc181,
    0x0140,
    0xc301,
    0x03c0,
    0x0280,
    0xc241,
    0xc601,
    0x06c0,
    0x0780,
    0xc741,
    0x0500,
    0xc5c1,
    0xc481,
    0x0440,
    0xcc01,
    0x0cc0,
    0x0d80,
    0xcd41,
    0x0f00,
    0xcfc1,
    0xce81,
    0x0e40,
    0x0a00,
    0xcac1,
    0xcb81,
    0x0b40,
    0xc901,
    0x09c0,
    0x0880,
    0xc841,
    0xd801,
    0x18c0,
    0x1980,
    0xd941,
    0x1b00,
    0xdbc1,
    0xda81,
    0x1a40,
    0x1e00,
    0xdec1,
    0xdf81,
    0x1f40,
    0xdd01,
    0x1dc0,
    0x1c80,
    0xdc41,
    0x1400,
    0xd4c1,
    0xd581,
    0x1540,
    0xd701,
    0x17c0,
    0x1680,
    0xd641,
    0xd201,
    0x12c0,
    0x1380,
    0xd341,
    0x1100,
    0xd1c1,
    0xd081,
    0x1040,
    0xf001,
    0x30c0,
    0x3180,
    0xf141,
    0x3300,
    0xf3c1,
    0xf281,
    0x3240,
    0x3600,
    0xf6c1,
    0xf781,
    0x3740,
    0xf501,
    0x35c0,
    0x3480,
    0xf441,
    0x3c00,
    0xfcc1,
    0xfd81,
    0x3d40,
    0xff01,
    0x3fc0,
    0x3e80,
    0xfe41,
    0xfa01,
    0x3ac0,
    0x3b80,
    0xfb41,
    0x3900,
    0xf9c1,
    0xf881,
    0x3840,
    0x2800,
    0xe8c1,
    0xe981,
    0x2940,
    0xeb01,
    0x2bc0,
    0x2a80,
    0xea41,
    0xee01,
    0x2ec0,
    0x2f80,
    0xef41,
    0x2d00,
    0xedc1,
    0xec81,
    0x2c40,
    0xe401,
    0x24c0,
    0x2580,
    0xe541,
    0x2700,
    0xe7c1,
    0xe681,
    0x2640,
    0x2200,
    0xe2c1,
    0xe381,
    0x2340,
    0xe101,
    0x21c0,
    0x2080,
    0xe041,
    0xa001,
    0x60c0,
    0x6180,
    0xa141,
    0x6300,
    0xa3c1,
    0xa281,
    0x6240,
    0x6600,
    0xa6c1,
    0xa781,
    0x6740,
    0xa501,
    0x65c0,
    0x6480,
    0xa441,
    0x6c00,
    0xacc1,
    0xad81,
    0x6d40,
    0xaf01,
    0x6fc0,
    0x6e80,
    0xae41,
    0xaa01,
    0x6ac0,
    0x6b80,
    0xab41,
    0x6900,
    0xa9c1,
    0xa881,
    0x6840,
    0x7800,
    0xb8c1,
    0xb981,
    0x7940,
    0xbb01,
    0x7bc0,
    0x7a80,
    0xba41,
    0xbe01,
    0x7ec0,
    0x7f80,
    0xbf41,
    0x7d00,
    0xbdc1,
    0xbc81,
    0x7c40,
    0xb401,
    0x74c0,
    0x7580,
    0xb541,
    0x7700,
    0xb7c1,
    0xb681,
    0x7640,
    0x7200,
    0xb2c1,
    0xb381,
    0x7340,
    0xb101,
    0x71c0,
    0x7080,
    0xb041,
    0x5000,
    0x90c1,
    0x9181,
    0x5140,
    0x9301,
    0x53c0,
    0x5280,
    0x9241,
    0x9601,
    0x56c0,
    0x5780,
    0x9741,
    0x5500,
    0x95c1,
    0x9481,
    0x5440,
    0x9c01,
    0x5cc0,
    0x5d80,
    0x9d41,
    0x5f00,
    0x9fc1,
    0x9e81,
    0x5e40,
    0x5a00,
    0x9ac1,
    0x9b81,
    0x5b40,
    0x9901,
    0x59c0,
    0x5880,
    0x9841,
    0x8801,
    0x48c0,
    0x4980,
    0x8941,
    0x4b00,
    0x8bc1,
    0x8a81,
    0x4a40,
    0x4e00,
    0x8ec1,
    0x8f81,
    0x4f40,
    0x8d01,
    0x4dc0,
    0x4c80,
    0x8c41,
    0x4400,
    0x84c1,
    0x8581,
    0x4540,
    0x8701,
    0x47c0,
    0x4680,
    0x8641,
    0x8201,
    0x42c0,
    0x4380,
    0x8341,
    0x4100,
    0x81c1,
    0x8081,
    0x4040
];
if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);
const crc16 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])('crc-16', function(buf, previous) {
    if (!__TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__["Buffer"].isBuffer(buf)) buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(buf);
    let crc = ~~previous;
    for(let index = 0; index < buf.length; index++){
        const byte = buf[index];
        crc = (TABLE[(crc ^ byte) & 0xff] ^ crc >> 8) & 0xffff;
    }
    return crc;
});
const __TURBOPACK__default__export__ = crc16;
}}),
"[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16ccitt.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/buffer [external] (buffer, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/create_buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/define_crc.js [app-ssr] (ecmascript)");
;
;
;
// Generated by `./pycrc.py --algorithm=table-driven --model=ccitt --generate=c`
// prettier-ignore
let TABLE = [
    0x0000,
    0x1021,
    0x2042,
    0x3063,
    0x4084,
    0x50a5,
    0x60c6,
    0x70e7,
    0x8108,
    0x9129,
    0xa14a,
    0xb16b,
    0xc18c,
    0xd1ad,
    0xe1ce,
    0xf1ef,
    0x1231,
    0x0210,
    0x3273,
    0x2252,
    0x52b5,
    0x4294,
    0x72f7,
    0x62d6,
    0x9339,
    0x8318,
    0xb37b,
    0xa35a,
    0xd3bd,
    0xc39c,
    0xf3ff,
    0xe3de,
    0x2462,
    0x3443,
    0x0420,
    0x1401,
    0x64e6,
    0x74c7,
    0x44a4,
    0x5485,
    0xa56a,
    0xb54b,
    0x8528,
    0x9509,
    0xe5ee,
    0xf5cf,
    0xc5ac,
    0xd58d,
    0x3653,
    0x2672,
    0x1611,
    0x0630,
    0x76d7,
    0x66f6,
    0x5695,
    0x46b4,
    0xb75b,
    0xa77a,
    0x9719,
    0x8738,
    0xf7df,
    0xe7fe,
    0xd79d,
    0xc7bc,
    0x48c4,
    0x58e5,
    0x6886,
    0x78a7,
    0x0840,
    0x1861,
    0x2802,
    0x3823,
    0xc9cc,
    0xd9ed,
    0xe98e,
    0xf9af,
    0x8948,
    0x9969,
    0xa90a,
    0xb92b,
    0x5af5,
    0x4ad4,
    0x7ab7,
    0x6a96,
    0x1a71,
    0x0a50,
    0x3a33,
    0x2a12,
    0xdbfd,
    0xcbdc,
    0xfbbf,
    0xeb9e,
    0x9b79,
    0x8b58,
    0xbb3b,
    0xab1a,
    0x6ca6,
    0x7c87,
    0x4ce4,
    0x5cc5,
    0x2c22,
    0x3c03,
    0x0c60,
    0x1c41,
    0xedae,
    0xfd8f,
    0xcdec,
    0xddcd,
    0xad2a,
    0xbd0b,
    0x8d68,
    0x9d49,
    0x7e97,
    0x6eb6,
    0x5ed5,
    0x4ef4,
    0x3e13,
    0x2e32,
    0x1e51,
    0x0e70,
    0xff9f,
    0xefbe,
    0xdfdd,
    0xcffc,
    0xbf1b,
    0xaf3a,
    0x9f59,
    0x8f78,
    0x9188,
    0x81a9,
    0xb1ca,
    0xa1eb,
    0xd10c,
    0xc12d,
    0xf14e,
    0xe16f,
    0x1080,
    0x00a1,
    0x30c2,
    0x20e3,
    0x5004,
    0x4025,
    0x7046,
    0x6067,
    0x83b9,
    0x9398,
    0xa3fb,
    0xb3da,
    0xc33d,
    0xd31c,
    0xe37f,
    0xf35e,
    0x02b1,
    0x1290,
    0x22f3,
    0x32d2,
    0x4235,
    0x5214,
    0x6277,
    0x7256,
    0xb5ea,
    0xa5cb,
    0x95a8,
    0x8589,
    0xf56e,
    0xe54f,
    0xd52c,
    0xc50d,
    0x34e2,
    0x24c3,
    0x14a0,
    0x0481,
    0x7466,
    0x6447,
    0x5424,
    0x4405,
    0xa7db,
    0xb7fa,
    0x8799,
    0x97b8,
    0xe75f,
    0xf77e,
    0xc71d,
    0xd73c,
    0x26d3,
    0x36f2,
    0x0691,
    0x16b0,
    0x6657,
    0x7676,
    0x4615,
    0x5634,
    0xd94c,
    0xc96d,
    0xf90e,
    0xe92f,
    0x99c8,
    0x89e9,
    0xb98a,
    0xa9ab,
    0x5844,
    0x4865,
    0x7806,
    0x6827,
    0x18c0,
    0x08e1,
    0x3882,
    0x28a3,
    0xcb7d,
    0xdb5c,
    0xeb3f,
    0xfb1e,
    0x8bf9,
    0x9bd8,
    0xabbb,
    0xbb9a,
    0x4a75,
    0x5a54,
    0x6a37,
    0x7a16,
    0x0af1,
    0x1ad0,
    0x2ab3,
    0x3a92,
    0xfd2e,
    0xed0f,
    0xdd6c,
    0xcd4d,
    0xbdaa,
    0xad8b,
    0x9de8,
    0x8dc9,
    0x7c26,
    0x6c07,
    0x5c64,
    0x4c45,
    0x3ca2,
    0x2c83,
    0x1ce0,
    0x0cc1,
    0xef1f,
    0xff3e,
    0xcf5d,
    0xdf7c,
    0xaf9b,
    0xbfba,
    0x8fd9,
    0x9ff8,
    0x6e17,
    0x7e36,
    0x4e55,
    0x5e74,
    0x2e93,
    0x3eb2,
    0x0ed1,
    0x1ef0
];
if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);
const crc16ccitt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])('ccitt', function(buf, previous) {
    if (!__TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__["Buffer"].isBuffer(buf)) buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(buf);
    let crc = typeof previous !== 'undefined' ? ~~previous : 0xffff;
    for(let index = 0; index < buf.length; index++){
        const byte = buf[index];
        crc = (TABLE[(crc >> 8 ^ byte) & 0xff] ^ crc << 8) & 0xffff;
    }
    return crc;
});
const __TURBOPACK__default__export__ = crc16ccitt;
}}),
"[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16modbus.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/buffer [external] (buffer, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/create_buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/define_crc.js [app-ssr] (ecmascript)");
;
;
;
// Generated by `./pycrc.py --algorithm=table-driven --model=crc-16-modbus --generate=c`
// prettier-ignore
let TABLE = [
    0x0000,
    0xc0c1,
    0xc181,
    0x0140,
    0xc301,
    0x03c0,
    0x0280,
    0xc241,
    0xc601,
    0x06c0,
    0x0780,
    0xc741,
    0x0500,
    0xc5c1,
    0xc481,
    0x0440,
    0xcc01,
    0x0cc0,
    0x0d80,
    0xcd41,
    0x0f00,
    0xcfc1,
    0xce81,
    0x0e40,
    0x0a00,
    0xcac1,
    0xcb81,
    0x0b40,
    0xc901,
    0x09c0,
    0x0880,
    0xc841,
    0xd801,
    0x18c0,
    0x1980,
    0xd941,
    0x1b00,
    0xdbc1,
    0xda81,
    0x1a40,
    0x1e00,
    0xdec1,
    0xdf81,
    0x1f40,
    0xdd01,
    0x1dc0,
    0x1c80,
    0xdc41,
    0x1400,
    0xd4c1,
    0xd581,
    0x1540,
    0xd701,
    0x17c0,
    0x1680,
    0xd641,
    0xd201,
    0x12c0,
    0x1380,
    0xd341,
    0x1100,
    0xd1c1,
    0xd081,
    0x1040,
    0xf001,
    0x30c0,
    0x3180,
    0xf141,
    0x3300,
    0xf3c1,
    0xf281,
    0x3240,
    0x3600,
    0xf6c1,
    0xf781,
    0x3740,
    0xf501,
    0x35c0,
    0x3480,
    0xf441,
    0x3c00,
    0xfcc1,
    0xfd81,
    0x3d40,
    0xff01,
    0x3fc0,
    0x3e80,
    0xfe41,
    0xfa01,
    0x3ac0,
    0x3b80,
    0xfb41,
    0x3900,
    0xf9c1,
    0xf881,
    0x3840,
    0x2800,
    0xe8c1,
    0xe981,
    0x2940,
    0xeb01,
    0x2bc0,
    0x2a80,
    0xea41,
    0xee01,
    0x2ec0,
    0x2f80,
    0xef41,
    0x2d00,
    0xedc1,
    0xec81,
    0x2c40,
    0xe401,
    0x24c0,
    0x2580,
    0xe541,
    0x2700,
    0xe7c1,
    0xe681,
    0x2640,
    0x2200,
    0xe2c1,
    0xe381,
    0x2340,
    0xe101,
    0x21c0,
    0x2080,
    0xe041,
    0xa001,
    0x60c0,
    0x6180,
    0xa141,
    0x6300,
    0xa3c1,
    0xa281,
    0x6240,
    0x6600,
    0xa6c1,
    0xa781,
    0x6740,
    0xa501,
    0x65c0,
    0x6480,
    0xa441,
    0x6c00,
    0xacc1,
    0xad81,
    0x6d40,
    0xaf01,
    0x6fc0,
    0x6e80,
    0xae41,
    0xaa01,
    0x6ac0,
    0x6b80,
    0xab41,
    0x6900,
    0xa9c1,
    0xa881,
    0x6840,
    0x7800,
    0xb8c1,
    0xb981,
    0x7940,
    0xbb01,
    0x7bc0,
    0x7a80,
    0xba41,
    0xbe01,
    0x7ec0,
    0x7f80,
    0xbf41,
    0x7d00,
    0xbdc1,
    0xbc81,
    0x7c40,
    0xb401,
    0x74c0,
    0x7580,
    0xb541,
    0x7700,
    0xb7c1,
    0xb681,
    0x7640,
    0x7200,
    0xb2c1,
    0xb381,
    0x7340,
    0xb101,
    0x71c0,
    0x7080,
    0xb041,
    0x5000,
    0x90c1,
    0x9181,
    0x5140,
    0x9301,
    0x53c0,
    0x5280,
    0x9241,
    0x9601,
    0x56c0,
    0x5780,
    0x9741,
    0x5500,
    0x95c1,
    0x9481,
    0x5440,
    0x9c01,
    0x5cc0,
    0x5d80,
    0x9d41,
    0x5f00,
    0x9fc1,
    0x9e81,
    0x5e40,
    0x5a00,
    0x9ac1,
    0x9b81,
    0x5b40,
    0x9901,
    0x59c0,
    0x5880,
    0x9841,
    0x8801,
    0x48c0,
    0x4980,
    0x8941,
    0x4b00,
    0x8bc1,
    0x8a81,
    0x4a40,
    0x4e00,
    0x8ec1,
    0x8f81,
    0x4f40,
    0x8d01,
    0x4dc0,
    0x4c80,
    0x8c41,
    0x4400,
    0x84c1,
    0x8581,
    0x4540,
    0x8701,
    0x47c0,
    0x4680,
    0x8641,
    0x8201,
    0x42c0,
    0x4380,
    0x8341,
    0x4100,
    0x81c1,
    0x8081,
    0x4040
];
if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);
const crc16modbus = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])('crc-16-modbus', function(buf, previous) {
    if (!__TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__["Buffer"].isBuffer(buf)) buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(buf);
    let crc = typeof previous !== 'undefined' ? ~~previous : 0xffff;
    for(let index = 0; index < buf.length; index++){
        const byte = buf[index];
        crc = (TABLE[(crc ^ byte) & 0xff] ^ crc >> 8) & 0xffff;
    }
    return crc;
});
const __TURBOPACK__default__export__ = crc16modbus;
}}),
"[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16xmodem.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/buffer [external] (buffer, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/create_buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/define_crc.js [app-ssr] (ecmascript)");
;
;
;
const crc16xmodem = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])('xmodem', function(buf, previous) {
    if (!__TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__["Buffer"].isBuffer(buf)) buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(buf);
    let crc = typeof previous !== 'undefined' ? ~~previous : 0x0;
    for(let index = 0; index < buf.length; index++){
        const byte = buf[index];
        let code = crc >>> 8 & 0xff;
        code ^= byte & 0xff;
        code ^= code >>> 4;
        crc = crc << 8 & 0xffff;
        crc ^= code;
        code = code << 5 & 0xffff;
        crc ^= code;
        code = code << 7 & 0xffff;
        crc ^= code;
    }
    return crc;
});
const __TURBOPACK__default__export__ = crc16xmodem;
}}),
"[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16kermit.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/buffer [external] (buffer, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/create_buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/define_crc.js [app-ssr] (ecmascript)");
;
;
;
// Generated by `./pycrc.py --algorithm=table-driven --model=kermit --generate=c`
// prettier-ignore
let TABLE = [
    0x0000,
    0x1189,
    0x2312,
    0x329b,
    0x4624,
    0x57ad,
    0x6536,
    0x74bf,
    0x8c48,
    0x9dc1,
    0xaf5a,
    0xbed3,
    0xca6c,
    0xdbe5,
    0xe97e,
    0xf8f7,
    0x1081,
    0x0108,
    0x3393,
    0x221a,
    0x56a5,
    0x472c,
    0x75b7,
    0x643e,
    0x9cc9,
    0x8d40,
    0xbfdb,
    0xae52,
    0xdaed,
    0xcb64,
    0xf9ff,
    0xe876,
    0x2102,
    0x308b,
    0x0210,
    0x1399,
    0x6726,
    0x76af,
    0x4434,
    0x55bd,
    0xad4a,
    0xbcc3,
    0x8e58,
    0x9fd1,
    0xeb6e,
    0xfae7,
    0xc87c,
    0xd9f5,
    0x3183,
    0x200a,
    0x1291,
    0x0318,
    0x77a7,
    0x662e,
    0x54b5,
    0x453c,
    0xbdcb,
    0xac42,
    0x9ed9,
    0x8f50,
    0xfbef,
    0xea66,
    0xd8fd,
    0xc974,
    0x4204,
    0x538d,
    0x6116,
    0x709f,
    0x0420,
    0x15a9,
    0x2732,
    0x36bb,
    0xce4c,
    0xdfc5,
    0xed5e,
    0xfcd7,
    0x8868,
    0x99e1,
    0xab7a,
    0xbaf3,
    0x5285,
    0x430c,
    0x7197,
    0x601e,
    0x14a1,
    0x0528,
    0x37b3,
    0x263a,
    0xdecd,
    0xcf44,
    0xfddf,
    0xec56,
    0x98e9,
    0x8960,
    0xbbfb,
    0xaa72,
    0x6306,
    0x728f,
    0x4014,
    0x519d,
    0x2522,
    0x34ab,
    0x0630,
    0x17b9,
    0xef4e,
    0xfec7,
    0xcc5c,
    0xddd5,
    0xa96a,
    0xb8e3,
    0x8a78,
    0x9bf1,
    0x7387,
    0x620e,
    0x5095,
    0x411c,
    0x35a3,
    0x242a,
    0x16b1,
    0x0738,
    0xffcf,
    0xee46,
    0xdcdd,
    0xcd54,
    0xb9eb,
    0xa862,
    0x9af9,
    0x8b70,
    0x8408,
    0x9581,
    0xa71a,
    0xb693,
    0xc22c,
    0xd3a5,
    0xe13e,
    0xf0b7,
    0x0840,
    0x19c9,
    0x2b52,
    0x3adb,
    0x4e64,
    0x5fed,
    0x6d76,
    0x7cff,
    0x9489,
    0x8500,
    0xb79b,
    0xa612,
    0xd2ad,
    0xc324,
    0xf1bf,
    0xe036,
    0x18c1,
    0x0948,
    0x3bd3,
    0x2a5a,
    0x5ee5,
    0x4f6c,
    0x7df7,
    0x6c7e,
    0xa50a,
    0xb483,
    0x8618,
    0x9791,
    0xe32e,
    0xf2a7,
    0xc03c,
    0xd1b5,
    0x2942,
    0x38cb,
    0x0a50,
    0x1bd9,
    0x6f66,
    0x7eef,
    0x4c74,
    0x5dfd,
    0xb58b,
    0xa402,
    0x9699,
    0x8710,
    0xf3af,
    0xe226,
    0xd0bd,
    0xc134,
    0x39c3,
    0x284a,
    0x1ad1,
    0x0b58,
    0x7fe7,
    0x6e6e,
    0x5cf5,
    0x4d7c,
    0xc60c,
    0xd785,
    0xe51e,
    0xf497,
    0x8028,
    0x91a1,
    0xa33a,
    0xb2b3,
    0x4a44,
    0x5bcd,
    0x6956,
    0x78df,
    0x0c60,
    0x1de9,
    0x2f72,
    0x3efb,
    0xd68d,
    0xc704,
    0xf59f,
    0xe416,
    0x90a9,
    0x8120,
    0xb3bb,
    0xa232,
    0x5ac5,
    0x4b4c,
    0x79d7,
    0x685e,
    0x1ce1,
    0x0d68,
    0x3ff3,
    0x2e7a,
    0xe70e,
    0xf687,
    0xc41c,
    0xd595,
    0xa12a,
    0xb0a3,
    0x8238,
    0x93b1,
    0x6b46,
    0x7acf,
    0x4854,
    0x59dd,
    0x2d62,
    0x3ceb,
    0x0e70,
    0x1ff9,
    0xf78f,
    0xe606,
    0xd49d,
    0xc514,
    0xb1ab,
    0xa022,
    0x92b9,
    0x8330,
    0x7bc7,
    0x6a4e,
    0x58d5,
    0x495c,
    0x3de3,
    0x2c6a,
    0x1ef1,
    0x0f78
];
if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);
const crc16kermit = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])('kermit', function(buf, previous) {
    if (!__TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__["Buffer"].isBuffer(buf)) buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(buf);
    let crc = typeof previous !== 'undefined' ? ~~previous : 0x0000;
    for(let index = 0; index < buf.length; index++){
        const byte = buf[index];
        crc = (TABLE[(crc ^ byte) & 0xff] ^ crc >> 8) & 0xffff;
    }
    return crc;
});
const __TURBOPACK__default__export__ = crc16kermit;
}}),
"[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc24.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/buffer [external] (buffer, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/create_buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/define_crc.js [app-ssr] (ecmascript)");
;
;
;
// Generated by `./pycrc.py --algorithm=table-drive --model=crc-24 --generate=c`
// prettier-ignore
let TABLE = [
    0x000000,
    0x864cfb,
    0x8ad50d,
    0x0c99f6,
    0x93e6e1,
    0x15aa1a,
    0x1933ec,
    0x9f7f17,
    0xa18139,
    0x27cdc2,
    0x2b5434,
    0xad18cf,
    0x3267d8,
    0xb42b23,
    0xb8b2d5,
    0x3efe2e,
    0xc54e89,
    0x430272,
    0x4f9b84,
    0xc9d77f,
    0x56a868,
    0xd0e493,
    0xdc7d65,
    0x5a319e,
    0x64cfb0,
    0xe2834b,
    0xee1abd,
    0x685646,
    0xf72951,
    0x7165aa,
    0x7dfc5c,
    0xfbb0a7,
    0x0cd1e9,
    0x8a9d12,
    0x8604e4,
    0x00481f,
    0x9f3708,
    0x197bf3,
    0x15e205,
    0x93aefe,
    0xad50d0,
    0x2b1c2b,
    0x2785dd,
    0xa1c926,
    0x3eb631,
    0xb8faca,
    0xb4633c,
    0x322fc7,
    0xc99f60,
    0x4fd39b,
    0x434a6d,
    0xc50696,
    0x5a7981,
    0xdc357a,
    0xd0ac8c,
    0x56e077,
    0x681e59,
    0xee52a2,
    0xe2cb54,
    0x6487af,
    0xfbf8b8,
    0x7db443,
    0x712db5,
    0xf7614e,
    0x19a3d2,
    0x9fef29,
    0x9376df,
    0x153a24,
    0x8a4533,
    0x0c09c8,
    0x00903e,
    0x86dcc5,
    0xb822eb,
    0x3e6e10,
    0x32f7e6,
    0xb4bb1d,
    0x2bc40a,
    0xad88f1,
    0xa11107,
    0x275dfc,
    0xdced5b,
    0x5aa1a0,
    0x563856,
    0xd074ad,
    0x4f0bba,
    0xc94741,
    0xc5deb7,
    0x43924c,
    0x7d6c62,
    0xfb2099,
    0xf7b96f,
    0x71f594,
    0xee8a83,
    0x68c678,
    0x645f8e,
    0xe21375,
    0x15723b,
    0x933ec0,
    0x9fa736,
    0x19ebcd,
    0x8694da,
    0x00d821,
    0x0c41d7,
    0x8a0d2c,
    0xb4f302,
    0x32bff9,
    0x3e260f,
    0xb86af4,
    0x2715e3,
    0xa15918,
    0xadc0ee,
    0x2b8c15,
    0xd03cb2,
    0x567049,
    0x5ae9bf,
    0xdca544,
    0x43da53,
    0xc596a8,
    0xc90f5e,
    0x4f43a5,
    0x71bd8b,
    0xf7f170,
    0xfb6886,
    0x7d247d,
    0xe25b6a,
    0x641791,
    0x688e67,
    0xeec29c,
    0x3347a4,
    0xb50b5f,
    0xb992a9,
    0x3fde52,
    0xa0a145,
    0x26edbe,
    0x2a7448,
    0xac38b3,
    0x92c69d,
    0x148a66,
    0x181390,
    0x9e5f6b,
    0x01207c,
    0x876c87,
    0x8bf571,
    0x0db98a,
    0xf6092d,
    0x7045d6,
    0x7cdc20,
    0xfa90db,
    0x65efcc,
    0xe3a337,
    0xef3ac1,
    0x69763a,
    0x578814,
    0xd1c4ef,
    0xdd5d19,
    0x5b11e2,
    0xc46ef5,
    0x42220e,
    0x4ebbf8,
    0xc8f703,
    0x3f964d,
    0xb9dab6,
    0xb54340,
    0x330fbb,
    0xac70ac,
    0x2a3c57,
    0x26a5a1,
    0xa0e95a,
    0x9e1774,
    0x185b8f,
    0x14c279,
    0x928e82,
    0x0df195,
    0x8bbd6e,
    0x872498,
    0x016863,
    0xfad8c4,
    0x7c943f,
    0x700dc9,
    0xf64132,
    0x693e25,
    0xef72de,
    0xe3eb28,
    0x65a7d3,
    0x5b59fd,
    0xdd1506,
    0xd18cf0,
    0x57c00b,
    0xc8bf1c,
    0x4ef3e7,
    0x426a11,
    0xc426ea,
    0x2ae476,
    0xaca88d,
    0xa0317b,
    0x267d80,
    0xb90297,
    0x3f4e6c,
    0x33d79a,
    0xb59b61,
    0x8b654f,
    0x0d29b4,
    0x01b042,
    0x87fcb9,
    0x1883ae,
    0x9ecf55,
    0x9256a3,
    0x141a58,
    0xefaaff,
    0x69e604,
    0x657ff2,
    0xe33309,
    0x7c4c1e,
    0xfa00e5,
    0xf69913,
    0x70d5e8,
    0x4e2bc6,
    0xc8673d,
    0xc4fecb,
    0x42b230,
    0xddcd27,
    0x5b81dc,
    0x57182a,
    0xd154d1,
    0x26359f,
    0xa07964,
    0xace092,
    0x2aac69,
    0xb5d37e,
    0x339f85,
    0x3f0673,
    0xb94a88,
    0x87b4a6,
    0x01f85d,
    0x0d61ab,
    0x8b2d50,
    0x145247,
    0x921ebc,
    0x9e874a,
    0x18cbb1,
    0xe37b16,
    0x6537ed,
    0x69ae1b,
    0xefe2e0,
    0x709df7,
    0xf6d10c,
    0xfa48fa,
    0x7c0401,
    0x42fa2f,
    0xc4b6d4,
    0xc82f22,
    0x4e63d9,
    0xd11cce,
    0x575035,
    0x5bc9c3,
    0xdd8538
];
if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);
const crc24 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])('crc-24', function(buf, previous) {
    if (!__TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__["Buffer"].isBuffer(buf)) buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(buf);
    let crc = typeof previous !== 'undefined' ? ~~previous : 0xb704ce;
    for(let index = 0; index < buf.length; index++){
        const byte = buf[index];
        crc = (TABLE[(crc >> 16 ^ byte) & 0xff] ^ crc << 8) & 0xffffff;
    }
    return crc;
});
const __TURBOPACK__default__export__ = crc24;
}}),
"[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc32.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/buffer [external] (buffer, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/create_buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/define_crc.js [app-ssr] (ecmascript)");
;
;
;
// Generated by `./pycrc.py --algorithm=table-driven --model=crc-32 --generate=c`
// prettier-ignore
let TABLE = [
    0x00000000,
    0x77073096,
    0xee0e612c,
    0x990951ba,
    0x076dc419,
    0x706af48f,
    0xe963a535,
    0x9e6495a3,
    0x0edb8832,
    0x79dcb8a4,
    0xe0d5e91e,
    0x97d2d988,
    0x09b64c2b,
    0x7eb17cbd,
    0xe7b82d07,
    0x90bf1d91,
    0x1db71064,
    0x6ab020f2,
    0xf3b97148,
    0x84be41de,
    0x1adad47d,
    0x6ddde4eb,
    0xf4d4b551,
    0x83d385c7,
    0x136c9856,
    0x646ba8c0,
    0xfd62f97a,
    0x8a65c9ec,
    0x14015c4f,
    0x63066cd9,
    0xfa0f3d63,
    0x8d080df5,
    0x3b6e20c8,
    0x4c69105e,
    0xd56041e4,
    0xa2677172,
    0x3c03e4d1,
    0x4b04d447,
    0xd20d85fd,
    0xa50ab56b,
    0x35b5a8fa,
    0x42b2986c,
    0xdbbbc9d6,
    0xacbcf940,
    0x32d86ce3,
    0x45df5c75,
    0xdcd60dcf,
    0xabd13d59,
    0x26d930ac,
    0x51de003a,
    0xc8d75180,
    0xbfd06116,
    0x21b4f4b5,
    0x56b3c423,
    0xcfba9599,
    0xb8bda50f,
    0x2802b89e,
    0x5f058808,
    0xc60cd9b2,
    0xb10be924,
    0x2f6f7c87,
    0x58684c11,
    0xc1611dab,
    0xb6662d3d,
    0x76dc4190,
    0x01db7106,
    0x98d220bc,
    0xefd5102a,
    0x71b18589,
    0x06b6b51f,
    0x9fbfe4a5,
    0xe8b8d433,
    0x7807c9a2,
    0x0f00f934,
    0x9609a88e,
    0xe10e9818,
    0x7f6a0dbb,
    0x086d3d2d,
    0x91646c97,
    0xe6635c01,
    0x6b6b51f4,
    0x1c6c6162,
    0x856530d8,
    0xf262004e,
    0x6c0695ed,
    0x1b01a57b,
    0x8208f4c1,
    0xf50fc457,
    0x65b0d9c6,
    0x12b7e950,
    0x8bbeb8ea,
    0xfcb9887c,
    0x62dd1ddf,
    0x15da2d49,
    0x8cd37cf3,
    0xfbd44c65,
    0x4db26158,
    0x3ab551ce,
    0xa3bc0074,
    0xd4bb30e2,
    0x4adfa541,
    0x3dd895d7,
    0xa4d1c46d,
    0xd3d6f4fb,
    0x4369e96a,
    0x346ed9fc,
    0xad678846,
    0xda60b8d0,
    0x44042d73,
    0x33031de5,
    0xaa0a4c5f,
    0xdd0d7cc9,
    0x5005713c,
    0x270241aa,
    0xbe0b1010,
    0xc90c2086,
    0x5768b525,
    0x206f85b3,
    0xb966d409,
    0xce61e49f,
    0x5edef90e,
    0x29d9c998,
    0xb0d09822,
    0xc7d7a8b4,
    0x59b33d17,
    0x2eb40d81,
    0xb7bd5c3b,
    0xc0ba6cad,
    0xedb88320,
    0x9abfb3b6,
    0x03b6e20c,
    0x74b1d29a,
    0xead54739,
    0x9dd277af,
    0x04db2615,
    0x73dc1683,
    0xe3630b12,
    0x94643b84,
    0x0d6d6a3e,
    0x7a6a5aa8,
    0xe40ecf0b,
    0x9309ff9d,
    0x0a00ae27,
    0x7d079eb1,
    0xf00f9344,
    0x8708a3d2,
    0x1e01f268,
    0x6906c2fe,
    0xf762575d,
    0x806567cb,
    0x196c3671,
    0x6e6b06e7,
    0xfed41b76,
    0x89d32be0,
    0x10da7a5a,
    0x67dd4acc,
    0xf9b9df6f,
    0x8ebeeff9,
    0x17b7be43,
    0x60b08ed5,
    0xd6d6a3e8,
    0xa1d1937e,
    0x38d8c2c4,
    0x4fdff252,
    0xd1bb67f1,
    0xa6bc5767,
    0x3fb506dd,
    0x48b2364b,
    0xd80d2bda,
    0xaf0a1b4c,
    0x36034af6,
    0x41047a60,
    0xdf60efc3,
    0xa867df55,
    0x316e8eef,
    0x4669be79,
    0xcb61b38c,
    0xbc66831a,
    0x256fd2a0,
    0x5268e236,
    0xcc0c7795,
    0xbb0b4703,
    0x220216b9,
    0x5505262f,
    0xc5ba3bbe,
    0xb2bd0b28,
    0x2bb45a92,
    0x5cb36a04,
    0xc2d7ffa7,
    0xb5d0cf31,
    0x2cd99e8b,
    0x5bdeae1d,
    0x9b64c2b0,
    0xec63f226,
    0x756aa39c,
    0x026d930a,
    0x9c0906a9,
    0xeb0e363f,
    0x72076785,
    0x05005713,
    0x95bf4a82,
    0xe2b87a14,
    0x7bb12bae,
    0x0cb61b38,
    0x92d28e9b,
    0xe5d5be0d,
    0x7cdcefb7,
    0x0bdbdf21,
    0x86d3d2d4,
    0xf1d4e242,
    0x68ddb3f8,
    0x1fda836e,
    0x81be16cd,
    0xf6b9265b,
    0x6fb077e1,
    0x18b74777,
    0x88085ae6,
    0xff0f6a70,
    0x66063bca,
    0x11010b5c,
    0x8f659eff,
    0xf862ae69,
    0x616bffd3,
    0x166ccf45,
    0xa00ae278,
    0xd70dd2ee,
    0x4e048354,
    0x3903b3c2,
    0xa7672661,
    0xd06016f7,
    0x4969474d,
    0x3e6e77db,
    0xaed16a4a,
    0xd9d65adc,
    0x40df0b66,
    0x37d83bf0,
    0xa9bcae53,
    0xdebb9ec5,
    0x47b2cf7f,
    0x30b5ffe9,
    0xbdbdf21c,
    0xcabac28a,
    0x53b39330,
    0x24b4a3a6,
    0xbad03605,
    0xcdd70693,
    0x54de5729,
    0x23d967bf,
    0xb3667a2e,
    0xc4614ab8,
    0x5d681b02,
    0x2a6f2b94,
    0xb40bbe37,
    0xc30c8ea1,
    0x5a05df1b,
    0x2d02ef8d
];
if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);
const crc32 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])('crc-32', function(buf, previous) {
    if (!__TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__["Buffer"].isBuffer(buf)) buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(buf);
    let crc = previous === 0 ? 0 : ~~previous ^ -1;
    for(let index = 0; index < buf.length; index++){
        const byte = buf[index];
        crc = TABLE[(crc ^ byte) & 0xff] ^ crc >>> 8;
    }
    return crc ^ -1;
});
const __TURBOPACK__default__export__ = crc32;
}}),
"[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crcjam.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/buffer [external] (buffer, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/create_buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/define_crc.js [app-ssr] (ecmascript)");
;
;
;
// Generated by `./pycrc.py --algorithm=table-driven --model=jam --generate=c`
// prettier-ignore
let TABLE = [
    0x00000000,
    0x77073096,
    0xee0e612c,
    0x990951ba,
    0x076dc419,
    0x706af48f,
    0xe963a535,
    0x9e6495a3,
    0x0edb8832,
    0x79dcb8a4,
    0xe0d5e91e,
    0x97d2d988,
    0x09b64c2b,
    0x7eb17cbd,
    0xe7b82d07,
    0x90bf1d91,
    0x1db71064,
    0x6ab020f2,
    0xf3b97148,
    0x84be41de,
    0x1adad47d,
    0x6ddde4eb,
    0xf4d4b551,
    0x83d385c7,
    0x136c9856,
    0x646ba8c0,
    0xfd62f97a,
    0x8a65c9ec,
    0x14015c4f,
    0x63066cd9,
    0xfa0f3d63,
    0x8d080df5,
    0x3b6e20c8,
    0x4c69105e,
    0xd56041e4,
    0xa2677172,
    0x3c03e4d1,
    0x4b04d447,
    0xd20d85fd,
    0xa50ab56b,
    0x35b5a8fa,
    0x42b2986c,
    0xdbbbc9d6,
    0xacbcf940,
    0x32d86ce3,
    0x45df5c75,
    0xdcd60dcf,
    0xabd13d59,
    0x26d930ac,
    0x51de003a,
    0xc8d75180,
    0xbfd06116,
    0x21b4f4b5,
    0x56b3c423,
    0xcfba9599,
    0xb8bda50f,
    0x2802b89e,
    0x5f058808,
    0xc60cd9b2,
    0xb10be924,
    0x2f6f7c87,
    0x58684c11,
    0xc1611dab,
    0xb6662d3d,
    0x76dc4190,
    0x01db7106,
    0x98d220bc,
    0xefd5102a,
    0x71b18589,
    0x06b6b51f,
    0x9fbfe4a5,
    0xe8b8d433,
    0x7807c9a2,
    0x0f00f934,
    0x9609a88e,
    0xe10e9818,
    0x7f6a0dbb,
    0x086d3d2d,
    0x91646c97,
    0xe6635c01,
    0x6b6b51f4,
    0x1c6c6162,
    0x856530d8,
    0xf262004e,
    0x6c0695ed,
    0x1b01a57b,
    0x8208f4c1,
    0xf50fc457,
    0x65b0d9c6,
    0x12b7e950,
    0x8bbeb8ea,
    0xfcb9887c,
    0x62dd1ddf,
    0x15da2d49,
    0x8cd37cf3,
    0xfbd44c65,
    0x4db26158,
    0x3ab551ce,
    0xa3bc0074,
    0xd4bb30e2,
    0x4adfa541,
    0x3dd895d7,
    0xa4d1c46d,
    0xd3d6f4fb,
    0x4369e96a,
    0x346ed9fc,
    0xad678846,
    0xda60b8d0,
    0x44042d73,
    0x33031de5,
    0xaa0a4c5f,
    0xdd0d7cc9,
    0x5005713c,
    0x270241aa,
    0xbe0b1010,
    0xc90c2086,
    0x5768b525,
    0x206f85b3,
    0xb966d409,
    0xce61e49f,
    0x5edef90e,
    0x29d9c998,
    0xb0d09822,
    0xc7d7a8b4,
    0x59b33d17,
    0x2eb40d81,
    0xb7bd5c3b,
    0xc0ba6cad,
    0xedb88320,
    0x9abfb3b6,
    0x03b6e20c,
    0x74b1d29a,
    0xead54739,
    0x9dd277af,
    0x04db2615,
    0x73dc1683,
    0xe3630b12,
    0x94643b84,
    0x0d6d6a3e,
    0x7a6a5aa8,
    0xe40ecf0b,
    0x9309ff9d,
    0x0a00ae27,
    0x7d079eb1,
    0xf00f9344,
    0x8708a3d2,
    0x1e01f268,
    0x6906c2fe,
    0xf762575d,
    0x806567cb,
    0x196c3671,
    0x6e6b06e7,
    0xfed41b76,
    0x89d32be0,
    0x10da7a5a,
    0x67dd4acc,
    0xf9b9df6f,
    0x8ebeeff9,
    0x17b7be43,
    0x60b08ed5,
    0xd6d6a3e8,
    0xa1d1937e,
    0x38d8c2c4,
    0x4fdff252,
    0xd1bb67f1,
    0xa6bc5767,
    0x3fb506dd,
    0x48b2364b,
    0xd80d2bda,
    0xaf0a1b4c,
    0x36034af6,
    0x41047a60,
    0xdf60efc3,
    0xa867df55,
    0x316e8eef,
    0x4669be79,
    0xcb61b38c,
    0xbc66831a,
    0x256fd2a0,
    0x5268e236,
    0xcc0c7795,
    0xbb0b4703,
    0x220216b9,
    0x5505262f,
    0xc5ba3bbe,
    0xb2bd0b28,
    0x2bb45a92,
    0x5cb36a04,
    0xc2d7ffa7,
    0xb5d0cf31,
    0x2cd99e8b,
    0x5bdeae1d,
    0x9b64c2b0,
    0xec63f226,
    0x756aa39c,
    0x026d930a,
    0x9c0906a9,
    0xeb0e363f,
    0x72076785,
    0x05005713,
    0x95bf4a82,
    0xe2b87a14,
    0x7bb12bae,
    0x0cb61b38,
    0x92d28e9b,
    0xe5d5be0d,
    0x7cdcefb7,
    0x0bdbdf21,
    0x86d3d2d4,
    0xf1d4e242,
    0x68ddb3f8,
    0x1fda836e,
    0x81be16cd,
    0xf6b9265b,
    0x6fb077e1,
    0x18b74777,
    0x88085ae6,
    0xff0f6a70,
    0x66063bca,
    0x11010b5c,
    0x8f659eff,
    0xf862ae69,
    0x616bffd3,
    0x166ccf45,
    0xa00ae278,
    0xd70dd2ee,
    0x4e048354,
    0x3903b3c2,
    0xa7672661,
    0xd06016f7,
    0x4969474d,
    0x3e6e77db,
    0xaed16a4a,
    0xd9d65adc,
    0x40df0b66,
    0x37d83bf0,
    0xa9bcae53,
    0xdebb9ec5,
    0x47b2cf7f,
    0x30b5ffe9,
    0xbdbdf21c,
    0xcabac28a,
    0x53b39330,
    0x24b4a3a6,
    0xbad03605,
    0xcdd70693,
    0x54de5729,
    0x23d967bf,
    0xb3667a2e,
    0xc4614ab8,
    0x5d681b02,
    0x2a6f2b94,
    0xb40bbe37,
    0xc30c8ea1,
    0x5a05df1b,
    0x2d02ef8d
];
if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);
const crcjam = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$define_crc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])('jam', function(buf, previous = -1) {
    if (!__TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__["Buffer"].isBuffer(buf)) buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$create_buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(buf);
    let crc = previous === 0 ? 0 : ~~previous;
    for(let index = 0; index < buf.length; index++){
        const byte = buf[index];
        crc = TABLE[(crc ^ byte) & 0xff] ^ crc >>> 8;
    }
    return crc;
});
const __TURBOPACK__default__export__ = crcjam;
}}),
"[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/index.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc1.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc8.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc81wire$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc81wire.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16ccitt$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16ccitt.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16modbus$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16modbus.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16xmodem$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16xmodem.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16kermit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16kermit.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc24$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc24.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc32$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc32.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crcjam$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crcjam.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const __TURBOPACK__default__export__ = {
    crc1: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    crc8: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    crc81wire: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc81wire$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    crc16: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    crc16ccitt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16ccitt$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    crc16modbus: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16modbus$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    crc16xmodem: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16xmodem$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    crc16kermit: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16kermit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    crc24: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc24$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    crc32: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc32$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    crcjam: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crcjam$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
};
}}),
"[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/index.js [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc1.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc8.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc81wire$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc81wire.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16ccitt$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16ccitt.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16modbus$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16modbus.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16xmodem$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16xmodem.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16kermit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16kermit.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc24$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc24.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc32$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc32.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crcjam$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crcjam.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/index.js [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/index.js [app-ssr] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "crc1": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]),
    "crc16": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]),
    "crc16ccitt": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16ccitt$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]),
    "crc16kermit": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16kermit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]),
    "crc16modbus": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16modbus$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]),
    "crc16xmodem": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16xmodem$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]),
    "crc24": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc24$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]),
    "crc32": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc32$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]),
    "crc8": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]),
    "crc81wire": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc81wire$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]),
    "crcjam": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crcjam$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]),
    "default": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc1.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc8.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc81wire$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc81wire.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16ccitt$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16ccitt.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16modbus$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16modbus.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16xmodem$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16xmodem.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc16kermit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc16kermit.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc24$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc24.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crc32$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crc32.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$crcjam$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/crcjam.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/index.js [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "crc1": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["crc1"]),
    "crc16": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["crc16"]),
    "crc16ccitt": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["crc16ccitt"]),
    "crc16kermit": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["crc16kermit"]),
    "crc16modbus": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["crc16modbus"]),
    "crc16xmodem": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["crc16xmodem"]),
    "crc24": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["crc24"]),
    "crc32": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["crc32"]),
    "crc8": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["crc8"]),
    "crc81wire": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["crc81wire"]),
    "crcjam": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["crcjam"]),
    "default": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$crc$40$3$2e$8$2e$0$2f$node_modules$2f$crc$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/crc@3.8.0/node_modules/crc/index.js [app-ssr] (ecmascript) <exports>");
}}),
"[project]/node_modules/.pnpm/cbor-sync@1.0.4/node_modules/cbor-sync/main.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function(global, factory) {
    if (typeof define === 'function' && define.amd) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(factory());
    } else if (("TURBOPACK compile-time value", "object") !== 'undefined' && module.exports) {
        module.exports = factory();
    } else {
        global.CBOR = factory();
    }
})(this, function() {
    var CBOR = function() {
        function BinaryHex(hex) {
            this.$hex = hex;
        }
        BinaryHex.prototype = {
            length: function() {
                return this.$hex.length / 2;
            },
            toString: function(format) {
                if (!format || format === 'hex' || format === 16) return this.$hex;
                if (format === 'utf-8') {
                    var encoded = '';
                    for(var i = 0; i < this.$hex.length; i += 2){
                        encoded += '%' + this.$hex.substring(i, i + 2);
                    }
                    return decodeURIComponent(encoded);
                }
                if (format === 'latin') {
                    var encoded = [];
                    for(var i = 0; i < this.$hex.length; i += 2){
                        encoded.push(parseInt(this.$hex.substring(i, i + 2), 16));
                    }
                    return String.fromCharCode.apply(String, encoded);
                }
                throw new Error('Unrecognised format: ' + format);
            }
        };
        BinaryHex.fromLatinString = function(latinString) {
            var hex = '';
            for(var i = 0; i < latinString.length; i++){
                var pair = latinString.charCodeAt(i).toString(16);
                if (pair.length === 1) pair = "0" + pair;
                hex += pair;
            }
            return new BinaryHex(hex);
        };
        BinaryHex.fromUtf8String = function(utf8String) {
            var encoded = encodeURIComponent(utf8String);
            var hex = '';
            for(var i = 0; i < encoded.length; i++){
                if (encoded.charAt(i) === '%') {
                    hex += encoded.substring(i + 1, i + 3);
                    i += 2;
                } else {
                    var hexPair = encoded.charCodeAt(i).toString(16);
                    if (hexPair.length < 2) hexPair = "0" + hexPair;
                    hex += hexPair;
                }
            }
            return new BinaryHex(hex);
        };
        var semanticEncoders = [];
        var semanticDecoders = {};
        var notImplemented = function(label) {
            return function() {
                throw new Error(label + ' not implemented');
            };
        };
        function Reader() {}
        Reader.prototype = {
            peekByte: notImplemented('peekByte'),
            readByte: notImplemented('readByte'),
            readChunk: notImplemented('readChunk'),
            readFloat16: function() {
                var half = this.readUint16();
                var exponent = (half & 0x7fff) >> 10;
                var mantissa = half & 0x3ff;
                var negative = half & 0x8000;
                if (exponent === 0x1f) {
                    if (mantissa === 0) {
                        return negative ? -Infinity : Infinity;
                    }
                    return NaN;
                }
                var magnitude = exponent ? Math.pow(2, exponent - 25) * (1024 + mantissa) : Math.pow(2, -24) * mantissa;
                return negative ? -magnitude : magnitude;
            },
            readFloat32: function() {
                var intValue = this.readUint32();
                var exponent = (intValue & 0x7fffffff) >> 23;
                var mantissa = intValue & 0x7fffff;
                var negative = intValue & 0x80000000;
                if (exponent === 0xff) {
                    if (mantissa === 0) {
                        return negative ? -Infinity : Infinity;
                    }
                    return NaN;
                }
                var magnitude = exponent ? Math.pow(2, exponent - 23 - 127) * (8388608 + mantissa) : Math.pow(2, -23 - 126) * mantissa;
                return negative ? -magnitude : magnitude;
            },
            readFloat64: function() {
                var int1 = this.readUint32(), int2 = this.readUint32();
                var exponent = int1 >> 20 & 0x7ff;
                var mantissa = (int1 & 0xfffff) * 4294967296 + int2;
                var negative = int1 & 0x80000000;
                if (exponent === 0x7ff) {
                    if (mantissa === 0) {
                        return negative ? -Infinity : Infinity;
                    }
                    return NaN;
                }
                var magnitude = exponent ? Math.pow(2, exponent - 52 - 1023) * (4503599627370496 + mantissa) : Math.pow(2, -52 - 1022) * mantissa;
                return negative ? -magnitude : magnitude;
            },
            readUint16: function() {
                return this.readByte() * 256 + this.readByte();
            },
            readUint32: function() {
                return this.readUint16() * 65536 + this.readUint16();
            },
            readUint64: function() {
                return this.readUint32() * 4294967296 + this.readUint32();
            }
        };
        function Writer() {}
        Writer.prototype = {
            writeByte: notImplemented('writeByte'),
            result: notImplemented('result'),
            writeFloat16: notImplemented('writeFloat16'),
            writeFloat32: notImplemented('writeFloat32'),
            writeFloat64: notImplemented('writeFloat64'),
            writeUint16: function(value) {
                this.writeByte(value >> 8 & 0xff);
                this.writeByte(value & 0xff);
            },
            writeUint32: function(value) {
                this.writeUint16(value >> 16 & 0xffff);
                this.writeUint16(value & 0xffff);
            },
            writeUint64: function(value) {
                if (value >= 9007199254740992 || value <= -9007199254740992) {
                    throw new Error('Cannot encode Uint64 of: ' + value + ' magnitude to big (floating point errors)');
                }
                this.writeUint32(Math.floor(value / 4294967296));
                this.writeUint32(value % 4294967296);
            },
            writeString: notImplemented('writeString'),
            canWriteBinary: function(chunk) {
                return false;
            },
            writeBinary: notImplemented('writeChunk')
        };
        function readHeaderRaw(reader) {
            var firstByte = reader.readByte();
            var majorType = firstByte >> 5, value = firstByte & 0x1f;
            return {
                type: majorType,
                value: value
            };
        }
        function valueFromHeader(header, reader) {
            var value = header.value;
            if (value < 24) {
                return value;
            } else if (value == 24) {
                return reader.readByte();
            } else if (value == 25) {
                return reader.readUint16();
            } else if (value == 26) {
                return reader.readUint32();
            } else if (value == 27) {
                return reader.readUint64();
            } else if (value == 31) {
                // special value for non-terminating arrays/objects
                return null;
            }
            notImplemented('Additional info: ' + value)();
        }
        function writeHeaderRaw(type, value, writer) {
            writer.writeByte(type << 5 | value);
        }
        function writeHeader(type, value, writer) {
            var firstByte = type << 5;
            if (value < 24) {
                writer.writeByte(firstByte | value);
            } else if (value < 256) {
                writer.writeByte(firstByte | 24);
                writer.writeByte(value);
            } else if (value < 65536) {
                writer.writeByte(firstByte | 25);
                writer.writeUint16(value);
            } else if (value < 4294967296) {
                writer.writeByte(firstByte | 26);
                writer.writeUint32(value);
            } else {
                writer.writeByte(firstByte | 27);
                writer.writeUint64(value);
            }
        }
        var stopCode = new Error(); // Just a unique object, that won't compare strictly equal to anything else
        function decodeReader(reader) {
            var header = readHeaderRaw(reader);
            switch(header.type){
                case 0:
                    return valueFromHeader(header, reader);
                case 1:
                    return -1 - valueFromHeader(header, reader);
                case 2:
                    return reader.readChunk(valueFromHeader(header, reader));
                case 3:
                    var buffer = reader.readChunk(valueFromHeader(header, reader));
                    return buffer.toString('utf-8');
                case 4:
                case 5:
                    var arrayLength = valueFromHeader(header, reader);
                    var result = [];
                    if (arrayLength !== null) {
                        if (header.type === 5) {
                            arrayLength *= 2;
                        }
                        for(var i = 0; i < arrayLength; i++){
                            result[i] = decodeReader(reader);
                        }
                    } else {
                        var item;
                        while((item = decodeReader(reader)) !== stopCode){
                            result.push(item);
                        }
                    }
                    if (header.type === 5) {
                        var objResult = {};
                        for(var i = 0; i < result.length; i += 2){
                            objResult[result[i]] = result[i + 1];
                        }
                        return objResult;
                    } else {
                        return result;
                    }
                case 6:
                    var tag = valueFromHeader(header, reader);
                    var decoder = semanticDecoders[tag];
                    var result = decodeReader(reader);
                    return decoder ? decoder(result) : result;
                case 7:
                    if (header.value === 25) {
                        return reader.readFloat16();
                    } else if (header.value === 26) {
                        return reader.readFloat32();
                    } else if (header.value === 27) {
                        return reader.readFloat64();
                    }
                    switch(valueFromHeader(header, reader)){
                        case 20:
                            return false;
                        case 21:
                            return true;
                        case 22:
                            return null;
                        case 23:
                            return undefined;
                        case null:
                            return stopCode;
                        default:
                            throw new Error('Unknown fixed value: ' + header.value);
                    }
                default:
                    throw new Error('Unsupported header: ' + JSON.stringify(header));
            }
            throw new Error('not implemented yet');
        }
        function encodeWriter(data, writer) {
            for(var i = 0; i < semanticEncoders.length; i++){
                var replacement = semanticEncoders[i].fn(data);
                if (replacement !== undefined) {
                    writeHeader(6, semanticEncoders[i].tag, writer);
                    return encodeWriter(replacement, writer);
                }
            }
            if (data && typeof data.toCBOR === 'function') {
                data = data.toCBOR();
            }
            if (data === false) {
                writeHeader(7, 20, writer);
            } else if (data === true) {
                writeHeader(7, 21, writer);
            } else if (data === null) {
                writeHeader(7, 22, writer);
            } else if (data === undefined) {
                writeHeader(7, 23, writer);
            } else if (typeof data === 'number') {
                if (Math.floor(data) === data && data < 9007199254740992 && data > -9007199254740992) {
                    // Integer
                    if (data < 0) {
                        writeHeader(1, -1 - data, writer);
                    } else {
                        writeHeader(0, data, writer);
                    }
                } else {
                    writeHeaderRaw(7, 27, writer);
                    writer.writeFloat64(data);
                }
            } else if (typeof data === 'string') {
                writer.writeString(data, function(length) {
                    writeHeader(3, length, writer);
                });
            } else if (writer.canWriteBinary(data)) {
                writer.writeBinary(data, function(length) {
                    writeHeader(2, length, writer);
                });
            } else if (typeof data === 'object') {
                if (api.config.useToJSON && typeof data.toJSON === 'function') {
                    data = data.toJSON();
                }
                if (Array.isArray(data)) {
                    writeHeader(4, data.length, writer);
                    for(var i = 0; i < data.length; i++){
                        encodeWriter(data[i], writer);
                    }
                } else {
                    var keys = Object.keys(data);
                    writeHeader(5, keys.length, writer);
                    for(var i = 0; i < keys.length; i++){
                        encodeWriter(keys[i], writer);
                        encodeWriter(data[keys[i]], writer);
                    }
                }
            } else {
                throw new Error('CBOR encoding not supported: ' + data);
            }
        }
        var readerFunctions = [];
        var writerFunctions = [];
        var api = {
            config: {
                useToJSON: true
            },
            addWriter: function(format, writerFunction) {
                if (typeof format === 'string') {
                    writerFunctions.push(function(f) {
                        if (format === f) return writerFunction(f);
                    });
                } else {
                    writerFunctions.push(format);
                }
            },
            addReader: function(format, readerFunction) {
                if (typeof format === 'string') {
                    readerFunctions.push(function(data, f) {
                        if (format === f) return readerFunction(data, f);
                    });
                } else {
                    readerFunctions.push(format);
                }
            },
            encode: function(data, format) {
                for(var i = 0; i < writerFunctions.length; i++){
                    var func = writerFunctions[i];
                    var writer = func(format);
                    if (writer) {
                        encodeWriter(data, writer);
                        return writer.result();
                    }
                }
                throw new Error('Unsupported output format: ' + format);
            },
            decode: function(data, format) {
                for(var i = 0; i < readerFunctions.length; i++){
                    var func = readerFunctions[i];
                    var reader = func(data, format);
                    if (reader) {
                        return decodeReader(reader);
                    }
                }
                throw new Error('Unsupported input format: ' + format);
            },
            addSemanticEncode: function(tag, fn) {
                if (typeof tag !== 'number' || tag % 1 !== 0 || tag < 0) {
                    throw new Error('Tag must be a positive integer');
                }
                semanticEncoders.push({
                    tag: tag,
                    fn: fn
                });
                return this;
            },
            addSemanticDecode: function(tag, fn) {
                if (typeof tag !== 'number' || tag % 1 !== 0 || tag < 0) {
                    throw new Error('Tag must be a positive integer');
                }
                semanticDecoders[tag] = fn;
                return this;
            },
            Reader: Reader,
            Writer: Writer
        };
        /** Node.js Buffers **/ function BufferReader(buffer) {
            this.buffer = buffer;
            this.pos = 0;
        }
        BufferReader.prototype = Object.create(Reader.prototype);
        BufferReader.prototype.peekByte = function() {
            return this.buffer[this.pos];
        };
        BufferReader.prototype.readByte = function() {
            return this.buffer[this.pos++];
        };
        BufferReader.prototype.readUint16 = function() {
            var result = this.buffer.readUInt16BE(this.pos);
            this.pos += 2;
            return result;
        };
        BufferReader.prototype.readUint32 = function() {
            var result = this.buffer.readUInt32BE(this.pos);
            this.pos += 4;
            return result;
        };
        BufferReader.prototype.readFloat32 = function() {
            var result = this.buffer.readFloatBE(this.pos);
            this.pos += 4;
            return result;
        };
        BufferReader.prototype.readFloat64 = function() {
            var result = this.buffer.readDoubleBE(this.pos);
            this.pos += 8;
            return result;
        };
        BufferReader.prototype.readChunk = function(length) {
            var result = Buffer.alloc(length);
            this.buffer.copy(result, 0, this.pos, this.pos += length);
            return result;
        };
        function BufferWriter(stringFormat) {
            this.byteLength = 0;
            this.defaultBufferLength = 16384; // 16k
            this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
            this.latestBufferOffset = 0;
            this.completeBuffers = [];
            this.stringFormat = stringFormat;
        }
        BufferWriter.prototype = Object.create(Writer.prototype);
        BufferWriter.prototype.writeByte = function(value) {
            this.latestBuffer[this.latestBufferOffset++] = value;
            if (this.latestBufferOffset >= this.latestBuffer.length) {
                this.completeBuffers.push(this.latestBuffer);
                this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
                this.latestBufferOffset = 0;
            }
            this.byteLength++;
        };
        BufferWriter.prototype.writeFloat32 = function(value) {
            var buffer = Buffer.alloc(4);
            buffer.writeFloatBE(value, 0);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.writeFloat64 = function(value) {
            var buffer = Buffer.alloc(8);
            buffer.writeDoubleBE(value, 0);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.writeString = function(string, lengthFunc) {
            var buffer = Buffer.from(string, 'utf-8');
            lengthFunc(buffer.length);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.canWriteBinary = function(data) {
            return data instanceof Buffer;
        };
        BufferWriter.prototype.writeBinary = function(buffer, lengthFunc) {
            lengthFunc(buffer.length);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.writeBuffer = function(chunk) {
            if (!(chunk instanceof Buffer)) throw new TypeError('BufferWriter only accepts Buffers');
            if (!this.latestBufferOffset) {
                this.completeBuffers.push(chunk);
            } else if (this.latestBuffer.length - this.latestBufferOffset >= chunk.length) {
                chunk.copy(this.latestBuffer, this.latestBufferOffset);
                this.latestBufferOffset += chunk.length;
                if (this.latestBufferOffset >= this.latestBuffer.length) {
                    this.completeBuffers.push(this.latestBuffer);
                    this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
                    this.latestBufferOffset = 0;
                }
            } else {
                this.completeBuffers.push(this.latestBuffer.slice(0, this.latestBufferOffset));
                this.completeBuffers.push(chunk);
                this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
                this.latestBufferOffset = 0;
            }
            this.byteLength += chunk.length;
        };
        BufferWriter.prototype.result = function() {
            // Copies them all into a single Buffer
            var result = Buffer.alloc(this.byteLength);
            var offset = 0;
            for(var i = 0; i < this.completeBuffers.length; i++){
                var buffer = this.completeBuffers[i];
                buffer.copy(result, offset, 0, buffer.length);
                offset += buffer.length;
            }
            if (this.latestBufferOffset) {
                this.latestBuffer.copy(result, offset, 0, this.latestBufferOffset);
            }
            if (this.stringFormat) return result.toString(this.stringFormat);
            return result;
        };
        if (typeof Buffer === 'function') {
            api.addReader(function(data, format) {
                if (data instanceof Buffer) {
                    return new BufferReader(data);
                }
                if (format === 'hex' || format === 'base64') {
                    var buffer = Buffer.from(data, format);
                    return new BufferReader(buffer);
                }
            });
            api.addWriter(function(format) {
                if (!format || format === 'buffer') {
                    return new BufferWriter();
                } else if (format === 'hex' || format === 'base64') {
                    return new BufferWriter(format);
                }
            });
        }
        /** Hex-encoding (and Latin1) for browser **/ function HexReader(hex) {
            this.hex = hex;
            this.pos = 0;
        }
        HexReader.prototype = Object.create(Reader.prototype);
        HexReader.prototype.peekByte = function() {
            var pair = this.hex.substring(this.pos, 2);
            return parseInt(pair, 16);
        };
        HexReader.prototype.readByte = function() {
            var pair = this.hex.substring(this.pos, this.pos + 2);
            this.pos += 2;
            return parseInt(pair, 16);
        };
        HexReader.prototype.readChunk = function(length) {
            var hex = this.hex.substring(this.pos, this.pos + length * 2);
            this.pos += length * 2;
            if (typeof Buffer === 'function') return Buffer.from(hex, 'hex');
            return new BinaryHex(hex);
        };
        function HexWriter(finalFormat) {
            this.$hex = '';
            this.finalFormat = finalFormat || 'hex';
        }
        HexWriter.prototype = Object.create(Writer.prototype);
        HexWriter.prototype.writeByte = function(value) {
            if (value < 0 || value > 255) throw new Error('Byte value out of range: ' + value);
            var hex = value.toString(16);
            if (hex.length == 1) {
                hex = '0' + hex;
            }
            this.$hex += hex;
        };
        HexWriter.prototype.canWriteBinary = function(chunk) {
            return chunk instanceof BinaryHex || typeof Buffer === 'function' && chunk instanceof Buffer;
        };
        HexWriter.prototype.writeBinary = function(chunk, lengthFunction) {
            if (chunk instanceof BinaryHex) {
                lengthFunction(chunk.length());
                this.$hex += chunk.$hex;
            } else if (typeof Buffer === 'function' && chunk instanceof Buffer) {
                lengthFunction(chunk.length);
                this.$hex += chunk.toString('hex');
            } else {
                throw new TypeError('HexWriter only accepts BinaryHex or Buffers');
            }
        };
        HexWriter.prototype.result = function() {
            if (this.finalFormat === 'buffer' && typeof Buffer === 'function') {
                return Buffer.from(this.$hex, 'hex');
            }
            return new BinaryHex(this.$hex).toString(this.finalFormat);
        };
        HexWriter.prototype.writeString = function(string, lengthFunction) {
            var buffer = BinaryHex.fromUtf8String(string);
            lengthFunction(buffer.length());
            this.$hex += buffer.$hex;
        };
        api.addReader(function(data, format) {
            if (data instanceof BinaryHex || data.$hex) {
                return new HexReader(data.$hex);
            }
            if (format === 'hex') {
                return new HexReader(data);
            }
        });
        api.addWriter(function(format) {
            if (format === 'hex') {
                return new HexWriter();
            }
        });
        return api;
    }();
    CBOR.addSemanticEncode(0, function(data) {
        if (data instanceof Date) {
            return data.toISOString();
        }
    }).addSemanticDecode(0, function(isoString) {
        return new Date(isoString);
    }).addSemanticDecode(1, function(isoString) {
        return new Date(isoString);
    });
    return CBOR;
});
}}),
"[project]/node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
;
(function(globalObject) {
    'use strict';
    /*
 *      bignumber.js v9.1.2
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */ var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = '[BigNumber Error] ', tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ', BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 0x1fffffffffffff, // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [
        1,
        10,
        100,
        1e3,
        1e4,
        1e5,
        1e6,
        1e7,
        1e8,
        1e9,
        1e10,
        1e11,
        1e12,
        1e13
    ], SQRT_BASE = 1e7, // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9; // 0 to MAX_INT32
    /*
   * Create and return a BigNumber constructor.
   */ function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber.prototype = {
            constructor: BigNumber,
            toString: null,
            valueOf: null
        }, ONE = new BigNumber(1), //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------
        // The default values below must be integers within the inclusive ranges stated.
        // The values can also be changed at run-time using BigNumber.set.
        // The maximum number of decimal places for operations involving division.
        DECIMAL_PLACES = 20, // The rounding mode used when rounding to the above decimal places, and when using
        // toExponential, toFixed, toFormat and toPrecision, and round (default value).
        // UP         0 Away from zero.
        // DOWN       1 Towards zero.
        // CEIL       2 Towards +Infinity.
        // FLOOR      3 Towards -Infinity.
        // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
        // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
        // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
        // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
        // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
        ROUNDING_MODE = 4, // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]
        // The exponent value at and beneath which toString returns exponential notation.
        // Number type: -7
        TO_EXP_NEG = -7, // The exponent value at and above which toString returns exponential notation.
        // Number type: 21
        TO_EXP_POS = 21, // RANGE : [MIN_EXP, MAX_EXP]
        // The minimum exponent value, beneath which underflow to zero occurs.
        // Number type: -324  (5e-324)
        MIN_EXP = -1e7, // The maximum exponent value, above which overflow to Infinity occurs.
        // Number type:  308  (1.7976931348623157e+308)
        // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
        MAX_EXP = 1e7, // Whether to use cryptographically-secure random number generation, if available.
        CRYPTO = false, // The modulo mode used when calculating the modulus: a mod n.
        // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
        // The remainder (r) is calculated as: r = a - n * q.
        //
        // UP        0 The remainder is positive if the dividend is negative, else is negative.
        // DOWN      1 The remainder has the same sign as the dividend.
        //             This modulo mode is commonly known as 'truncated division' and is
        //             equivalent to (a % n) in JavaScript.
        // FLOOR     3 The remainder has the same sign as the divisor (Python %).
        // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
        // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
        //             The remainder is always positive.
        //
        // The truncated division, floored division, Euclidian division and IEEE 754 remainder
        // modes are commonly used for the modulus operation.
        // Although the other rounding modes can also be used, they may not give useful results.
        MODULO_MODE = 1, // The maximum number of significant digits of the result of the exponentiatedBy operation.
        // If POW_PRECISION is 0, there will be unlimited significant digits.
        POW_PRECISION = 0, // The format specification used by the BigNumber.prototype.toFormat method.
        FORMAT = {
            prefix: '',
            groupSize: 3,
            secondaryGroupSize: 0,
            groupSeparator: ',',
            decimalSeparator: '.',
            fractionGroupSize: 0,
            fractionGroupSeparator: '\xA0',
            suffix: ''
        }, // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
        // '-', '.', whitespace, or repeated character.
        // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
        ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz', alphabetHasNormalDecimalDigits = true;
        //------------------------------------------------------------------------------------------
        // CONSTRUCTOR
        /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */ function BigNumber(v, b) {
            var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
            // Enable constructor call without `new`.
            if (!(x instanceof BigNumber)) return new BigNumber(v, b);
            if (b == null) {
                if (v && v._isBigNumber === true) {
                    x.s = v.s;
                    if (!v.c || v.e > MAX_EXP) {
                        x.c = x.e = null;
                    } else if (v.e < MIN_EXP) {
                        x.c = [
                            x.e = 0
                        ];
                    } else {
                        x.e = v.e;
                        x.c = v.c.slice();
                    }
                    return;
                }
                if ((isNum = typeof v == 'number') && v * 0 == 0) {
                    // Use `1 / n` to handle minus zero also.
                    x.s = 1 / v < 0 ? (v = -v, -1) : 1;
                    // Fast path for integers, where n < 2147483648 (2**31).
                    if (v === ~~v) {
                        for(e = 0, i = v; i >= 10; i /= 10, e++);
                        if (e > MAX_EXP) {
                            x.c = x.e = null;
                        } else {
                            x.e = e;
                            x.c = [
                                v
                            ];
                        }
                        return;
                    }
                    str = String(v);
                } else {
                    if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
                    x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
                }
                // Decimal point?
                if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
                // Exponential form?
                if ((i = str.search(/e/i)) > 0) {
                    // Determine exponent.
                    if (e < 0) e = i;
                    e += +str.slice(i + 1);
                    str = str.substring(0, i);
                } else if (e < 0) {
                    // Integer.
                    e = str.length;
                }
            } else {
                // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
                intCheck(b, 2, ALPHABET.length, 'Base');
                // Allow exponential notation to be used with base 10 argument, while
                // also rounding to DECIMAL_PLACES as with other bases.
                if (b == 10 && alphabetHasNormalDecimalDigits) {
                    x = new BigNumber(v);
                    return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
                }
                str = String(v);
                if (isNum = typeof v == 'number') {
                    // Avoid potential interpretation of Infinity and NaN as base 44+ values.
                    if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
                    x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
                    // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
                    if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
                        throw Error(tooManyDigits + v);
                    }
                } else {
                    x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
                }
                alphabet = ALPHABET.slice(0, b);
                e = i = 0;
                // Check that str is a valid base b number.
                // Don't use RegExp, so alphabet can contain special characters.
                for(len = str.length; i < len; i++){
                    if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                        if (c == '.') {
                            // If '.' is not the first character and it has not be found before.
                            if (i > e) {
                                e = len;
                                continue;
                            }
                        } else if (!caseChanged) {
                            // Allow e.g. hexadecimal 'FF' as well as 'ff'.
                            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                                caseChanged = true;
                                i = -1;
                                e = 0;
                                continue;
                            }
                        }
                        return parseNumeric(x, String(v), isNum, b);
                    }
                }
                // Prevent later check for length on converted number.
                isNum = false;
                str = convertBase(str, b, 10, x.s);
                // Decimal point?
                if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
                else e = str.length;
            }
            // Determine leading zeros.
            for(i = 0; str.charCodeAt(i) === 48; i++);
            // Determine trailing zeros.
            for(len = str.length; str.charCodeAt(--len) === 48;);
            if (str = str.slice(i, ++len)) {
                len -= i;
                // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
                if (isNum && BigNumber.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
                    throw Error(tooManyDigits + x.s * v);
                }
                // Overflow?
                if ((e = e - i - 1) > MAX_EXP) {
                    // Infinity.
                    x.c = x.e = null;
                // Underflow?
                } else if (e < MIN_EXP) {
                    // Zero.
                    x.c = [
                        x.e = 0
                    ];
                } else {
                    x.e = e;
                    x.c = [];
                    // Transform base
                    // e is the base 10 exponent.
                    // i is where to slice str to get the first element of the coefficient array.
                    i = (e + 1) % LOG_BASE;
                    if (e < 0) i += LOG_BASE; // i < 1
                    if (i < len) {
                        if (i) x.c.push(+str.slice(0, i));
                        for(len -= LOG_BASE; i < len;){
                            x.c.push(+str.slice(i, i += LOG_BASE));
                        }
                        i = LOG_BASE - (str = str.slice(i)).length;
                    } else {
                        i -= len;
                    }
                    for(; i--; str += '0');
                    x.c.push(+str);
                }
            } else {
                // Zero.
                x.c = [
                    x.e = 0
                ];
            }
        }
        // CONSTRUCTOR PROPERTIES
        BigNumber.clone = clone;
        BigNumber.ROUND_UP = 0;
        BigNumber.ROUND_DOWN = 1;
        BigNumber.ROUND_CEIL = 2;
        BigNumber.ROUND_FLOOR = 3;
        BigNumber.ROUND_HALF_UP = 4;
        BigNumber.ROUND_HALF_DOWN = 5;
        BigNumber.ROUND_HALF_EVEN = 6;
        BigNumber.ROUND_HALF_CEIL = 7;
        BigNumber.ROUND_HALF_FLOOR = 8;
        BigNumber.EUCLID = 9;
        /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */ BigNumber.config = BigNumber.set = function(obj) {
            var p, v;
            if (obj != null) {
                if (typeof obj == 'object') {
                    // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
                    // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
                        v = obj[p];
                        intCheck(v, 0, MAX, p);
                        DECIMAL_PLACES = v;
                    }
                    // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
                    // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
                        v = obj[p];
                        intCheck(v, 0, 8, p);
                        ROUNDING_MODE = v;
                    }
                    // EXPONENTIAL_AT {number|number[]}
                    // Integer, -MAX to MAX inclusive or
                    // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
                    // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
                        v = obj[p];
                        if (v && v.pop) {
                            intCheck(v[0], -MAX, 0, p);
                            intCheck(v[1], 0, MAX, p);
                            TO_EXP_NEG = v[0];
                            TO_EXP_POS = v[1];
                        } else {
                            intCheck(v, -MAX, MAX, p);
                            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                        }
                    }
                    // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
                    // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
                    // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
                    if (obj.hasOwnProperty(p = 'RANGE')) {
                        v = obj[p];
                        if (v && v.pop) {
                            intCheck(v[0], -MAX, -1, p);
                            intCheck(v[1], 1, MAX, p);
                            MIN_EXP = v[0];
                            MAX_EXP = v[1];
                        } else {
                            intCheck(v, -MAX, MAX, p);
                            if (v) {
                                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                            } else {
                                throw Error(bignumberError + p + ' cannot be zero: ' + v);
                            }
                        }
                    }
                    // CRYPTO {boolean} true or false.
                    // '[BigNumber Error] CRYPTO not true or false: {v}'
                    // '[BigNumber Error] crypto unavailable'
                    if (obj.hasOwnProperty(p = 'CRYPTO')) {
                        v = obj[p];
                        if (v === !!v) {
                            if (v) {
                                if (typeof crypto != 'undefined' && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                                    CRYPTO = v;
                                } else {
                                    CRYPTO = !v;
                                    throw Error(bignumberError + 'crypto unavailable');
                                }
                            } else {
                                CRYPTO = v;
                            }
                        } else {
                            throw Error(bignumberError + p + ' not true or false: ' + v);
                        }
                    }
                    // MODULO_MODE {number} Integer, 0 to 9 inclusive.
                    // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
                        v = obj[p];
                        intCheck(v, 0, 9, p);
                        MODULO_MODE = v;
                    }
                    // POW_PRECISION {number} Integer, 0 to MAX inclusive.
                    // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
                        v = obj[p];
                        intCheck(v, 0, MAX, p);
                        POW_PRECISION = v;
                    }
                    // FORMAT {object}
                    // '[BigNumber Error] FORMAT not an object: {v}'
                    if (obj.hasOwnProperty(p = 'FORMAT')) {
                        v = obj[p];
                        if (typeof v == 'object') FORMAT = v;
                        else throw Error(bignumberError + p + ' not an object: ' + v);
                    }
                    // ALPHABET {string}
                    // '[BigNumber Error] ALPHABET invalid: {v}'
                    if (obj.hasOwnProperty(p = 'ALPHABET')) {
                        v = obj[p];
                        // Disallow if less than two characters,
                        // or if it contains '+', '-', '.', whitespace, or a repeated character.
                        if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                            alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
                            ALPHABET = v;
                        } else {
                            throw Error(bignumberError + p + ' invalid: ' + v);
                        }
                    }
                } else {
                    // '[BigNumber Error] Object expected: {v}'
                    throw Error(bignumberError + 'Object expected: ' + obj);
                }
            }
            return {
                DECIMAL_PLACES: DECIMAL_PLACES,
                ROUNDING_MODE: ROUNDING_MODE,
                EXPONENTIAL_AT: [
                    TO_EXP_NEG,
                    TO_EXP_POS
                ],
                RANGE: [
                    MIN_EXP,
                    MAX_EXP
                ],
                CRYPTO: CRYPTO,
                MODULO_MODE: MODULO_MODE,
                POW_PRECISION: POW_PRECISION,
                FORMAT: FORMAT,
                ALPHABET: ALPHABET
            };
        };
        /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */ BigNumber.isBigNumber = function(v) {
            if (!v || v._isBigNumber !== true) return false;
            if (!BigNumber.DEBUG) return true;
            var i, n, c = v.c, e = v.e, s = v.s;
            out: if (({}).toString.call(c) == '[object Array]') {
                if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                    // If the first element is zero, the BigNumber value must be zero.
                    if (c[0] === 0) {
                        if (e === 0 && c.length === 1) return true;
                        break out;
                    }
                    // Calculate number of digits that c[0] should have, based on the exponent.
                    i = (e + 1) % LOG_BASE;
                    if (i < 1) i += LOG_BASE;
                    // Calculate number of digits of c[0].
                    //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
                    if (String(c[0]).length == i) {
                        for(i = 0; i < c.length; i++){
                            n = c[i];
                            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                        }
                        // Last element cannot be zero, unless it is the only element.
                        if (n !== 0) return true;
                    }
                }
            // Infinity/NaN
            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
                return true;
            }
            throw Error(bignumberError + 'Invalid BigNumber: ' + v);
        };
        /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */ BigNumber.maximum = BigNumber.max = function() {
            return maxOrMin(arguments, -1);
        };
        /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */ BigNumber.minimum = BigNumber.min = function() {
            return maxOrMin(arguments, 1);
        };
        /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */ BigNumber.random = function() {
            var pow2_53 = 0x20000000000000;
            // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
            // Check if Math.random() produces more than 32 bits of randomness.
            // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
            // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
            var random53bitInt = Math.random() * pow2_53 & 0x1fffff ? function() {
                return mathfloor(Math.random() * pow2_53);
            } : function() {
                return (Math.random() * 0x40000000 | 0) * 0x800000 + (Math.random() * 0x800000 | 0);
            };
            return function(dp) {
                var a, b, e, k, v, i = 0, c = [], rand = new BigNumber(ONE);
                if (dp == null) dp = DECIMAL_PLACES;
                else intCheck(dp, 0, MAX);
                k = mathceil(dp / LOG_BASE);
                if (CRYPTO) {
                    // Browsers supporting crypto.getRandomValues.
                    if (crypto.getRandomValues) {
                        a = crypto.getRandomValues(new Uint32Array(k *= 2));
                        for(; i < k;){
                            // 53 bits:
                            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                            //                                     11111 11111111 11111111
                            // 0x20000 is 2^21.
                            v = a[i] * 0x20000 + (a[i + 1] >>> 11);
                            // Rejection sampling:
                            // 0 <= v < 9007199254740992
                            // Probability that v >= 9e15, is
                            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                            if (v >= 9e15) {
                                b = crypto.getRandomValues(new Uint32Array(2));
                                a[i] = b[0];
                                a[i + 1] = b[1];
                            } else {
                                // 0 <= v <= 8999999999999999
                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push(v % 1e14);
                                i += 2;
                            }
                        }
                        i = k / 2;
                    // Node.js supporting crypto.randomBytes.
                    } else if (crypto.randomBytes) {
                        // buffer
                        a = crypto.randomBytes(k *= 7);
                        for(; i < k;){
                            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                            // 0x100000000 is 2^32, 0x1000000 is 2^24
                            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                            // 0 <= v < 9007199254740992
                            v = (a[i] & 31) * 0x1000000000000 + a[i + 1] * 0x10000000000 + a[i + 2] * 0x100000000 + a[i + 3] * 0x1000000 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                            if (v >= 9e15) {
                                crypto.randomBytes(7).copy(a, i);
                            } else {
                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push(v % 1e14);
                                i += 7;
                            }
                        }
                        i = k / 7;
                    } else {
                        CRYPTO = false;
                        throw Error(bignumberError + 'crypto unavailable');
                    }
                }
                // Use Math.random.
                if (!CRYPTO) {
                    for(; i < k;){
                        v = random53bitInt();
                        if (v < 9e15) c[i++] = v % 1e14;
                    }
                }
                k = c[--i];
                dp %= LOG_BASE;
                // Convert trailing digits to zeros according to dp.
                if (k && dp) {
                    v = POWS_TEN[LOG_BASE - dp];
                    c[i] = mathfloor(k / v) * v;
                }
                // Remove trailing elements which are zero.
                for(; c[i] === 0; c.pop(), i--);
                // Zero?
                if (i < 0) {
                    c = [
                        e = 0
                    ];
                } else {
                    // Remove leading elements which are zero and adjust exponent accordingly.
                    for(e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);
                    // Count the digits of the first element of c to determine leading zeros, and...
                    for(i = 1, v = c[0]; v >= 10; v /= 10, i++);
                    // adjust the exponent accordingly.
                    if (i < LOG_BASE) e -= LOG_BASE - i;
                }
                rand.e = e;
                rand.c = c;
                return rand;
            };
        }();
        /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */ BigNumber.sum = function() {
            var i = 1, args = arguments, sum = new BigNumber(args[0]);
            for(; i < args.length;)sum = sum.plus(args[i++]);
            return sum;
        };
        // PRIVATE FUNCTIONS
        // Called by BigNumber and BigNumber.prototype.toString.
        convertBase = function() {
            var decimal = '0123456789';
            /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */ function toBaseOut(str, baseIn, baseOut, alphabet) {
                var j, arr = [
                    0
                ], arrL, i = 0, len = str.length;
                for(; i < len;){
                    for(arrL = arr.length; arrL--; arr[arrL] *= baseIn);
                    arr[0] += alphabet.indexOf(str.charAt(i++));
                    for(j = 0; j < arr.length; j++){
                        if (arr[j] > baseOut - 1) {
                            if (arr[j + 1] == null) arr[j + 1] = 0;
                            arr[j + 1] += arr[j] / baseOut | 0;
                            arr[j] %= baseOut;
                        }
                    }
                }
                return arr.reverse();
            }
            // Convert a numeric string of baseIn to a numeric string of baseOut.
            // If the caller is toString, we are converting from base 10 to baseOut.
            // If the caller is BigNumber, we are converting from baseIn to base 10.
            return function(str, baseIn, baseOut, sign, callerIsToString) {
                var alphabet, d, e, k, r, x, xc, y, i = str.indexOf('.'), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
                // Non-integer.
                if (i >= 0) {
                    k = POW_PRECISION;
                    // Unlimited precision.
                    POW_PRECISION = 0;
                    str = str.replace('.', '');
                    y = new BigNumber(baseIn);
                    x = y.pow(str.length - i);
                    POW_PRECISION = k;
                    // Convert str as if an integer, then restore the fraction part by dividing the
                    // result by its base raised to a power.
                    y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'), 10, baseOut, decimal);
                    y.e = y.c.length;
                }
                // Convert the number as integer.
                xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
                // xc now represents str as an integer and converted to baseOut. e is the exponent.
                e = k = xc.length;
                // Remove trailing zeros.
                for(; xc[--k] == 0; xc.pop());
                // Zero?
                if (!xc[0]) return alphabet.charAt(0);
                // Does str represent an integer? If so, no need for the division.
                if (i < 0) {
                    --e;
                } else {
                    x.c = xc;
                    x.e = e;
                    // The sign is needed for correct rounding.
                    x.s = sign;
                    x = div(x, y, dp, rm, baseOut);
                    xc = x.c;
                    r = x.r;
                    e = x.e;
                }
                // xc now represents str converted to baseOut.
                // THe index of the rounding digit.
                d = e + dp + 1;
                // The rounding digit: the digit to the right of the digit that may be rounded up.
                i = xc[d];
                // Look at the rounding digits and mode to determine whether to round up.
                k = baseOut / 2;
                r = r || d < 0 || xc[d + 1] != null;
                r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
                // If the index of the rounding digit is not greater than zero, or xc represents
                // zero, then the result of the base conversion is zero or, if rounding up, a value
                // such as 0.00001.
                if (d < 1 || !xc[0]) {
                    // 1^-dp or 0
                    str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
                } else {
                    // Truncate xc to the required number of decimal places.
                    xc.length = d;
                    // Round up?
                    if (r) {
                        // Rounding up may mean the previous digit has to be rounded up and so on.
                        for(--baseOut; ++xc[--d] > baseOut;){
                            xc[d] = 0;
                            if (!d) {
                                ++e;
                                xc = [
                                    1
                                ].concat(xc);
                            }
                        }
                    }
                    // Determine trailing zeros.
                    for(k = xc.length; !xc[--k];);
                    // E.g. [4, 11, 15] becomes 4bf.
                    for(i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));
                    // Add leading zeros, decimal point and trailing zeros as required.
                    str = toFixedPoint(str, e, alphabet.charAt(0));
                }
                // The caller will add the sign.
                return str;
            };
        }();
        // Perform division in the specified base. Called by div and convertBase.
        div = function() {
            // Assume non-zero x and k.
            function multiply(x, k, base) {
                var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
                for(x = x.slice(); i--;){
                    xlo = x[i] % SQRT_BASE;
                    xhi = x[i] / SQRT_BASE | 0;
                    m = khi * xlo + xhi * klo;
                    temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
                    carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
                    x[i] = temp % base;
                }
                if (carry) x = [
                    carry
                ].concat(x);
                return x;
            }
            function compare(a, b, aL, bL) {
                var i, cmp;
                if (aL != bL) {
                    cmp = aL > bL ? 1 : -1;
                } else {
                    for(i = cmp = 0; i < aL; i++){
                        if (a[i] != b[i]) {
                            cmp = a[i] > b[i] ? 1 : -1;
                            break;
                        }
                    }
                }
                return cmp;
            }
            function subtract(a, b, aL, base) {
                var i = 0;
                // Subtract b from a.
                for(; aL--;){
                    a[aL] -= i;
                    i = a[aL] < b[aL] ? 1 : 0;
                    a[aL] = i * base + a[aL] - b[aL];
                }
                // Remove leading zeros.
                for(; !a[0] && a.length > 1; a.splice(0, 1));
            }
            // x: dividend, y: divisor.
            return function(x, y, dp, rm, base) {
                var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
                // Either NaN, Infinity or 0?
                if (!xc || !xc[0] || !yc || !yc[0]) {
                    return new BigNumber(// Return NaN if either NaN, or both Infinity or 0.
                    !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                    xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
                }
                q = new BigNumber(s);
                qc = q.c = [];
                e = x.e - y.e;
                s = dp + e + 1;
                if (!base) {
                    base = BASE;
                    e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
                    s = s / LOG_BASE | 0;
                }
                // Result exponent may be one less then the current value of e.
                // The coefficients of the BigNumbers from convertBase may have trailing zeros.
                for(i = 0; yc[i] == (xc[i] || 0); i++);
                if (yc[i] > (xc[i] || 0)) e--;
                if (s < 0) {
                    qc.push(1);
                    more = true;
                } else {
                    xL = xc.length;
                    yL = yc.length;
                    i = 0;
                    s += 2;
                    // Normalise xc and yc so highest order digit of yc is >= base / 2.
                    n = mathfloor(base / (yc[0] + 1));
                    // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
                    // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
                    if (n > 1) {
                        yc = multiply(yc, n, base);
                        xc = multiply(xc, n, base);
                        yL = yc.length;
                        xL = xc.length;
                    }
                    xi = yL;
                    rem = xc.slice(0, yL);
                    remL = rem.length;
                    // Add zeros to make remainder as long as divisor.
                    for(; remL < yL; rem[remL++] = 0);
                    yz = yc.slice();
                    yz = [
                        0
                    ].concat(yz);
                    yc0 = yc[0];
                    if (yc[1] >= base / 2) yc0++;
                    // Not necessary, but to prevent trial digit n > base, when using base 3.
                    // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;
                    do {
                        n = 0;
                        // Compare divisor and remainder.
                        cmp = compare(yc, rem, yL, remL);
                        // If divisor < remainder.
                        if (cmp < 0) {
                            // Calculate trial digit, n.
                            rem0 = rem[0];
                            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                            // n is how many times the divisor goes into the current remainder.
                            n = mathfloor(rem0 / yc0);
                            //  Algorithm:
                            //  product = divisor multiplied by trial digit (n).
                            //  Compare product and remainder.
                            //  If product is greater than remainder:
                            //    Subtract divisor from product, decrement trial digit.
                            //  Subtract product from remainder.
                            //  If product was less than remainder at the last compare:
                            //    Compare new remainder and divisor.
                            //    If remainder is greater than divisor:
                            //      Subtract divisor from remainder, increment trial digit.
                            if (n > 1) {
                                // n may be > base only when base is 3.
                                if (n >= base) n = base - 1;
                                // product = divisor * trial digit.
                                prod = multiply(yc, n, base);
                                prodL = prod.length;
                                remL = rem.length;
                                // Compare product and remainder.
                                // If product > remainder then trial digit n too high.
                                // n is 1 too high about 5% of the time, and is not known to have
                                // ever been more than 1 too high.
                                while(compare(prod, rem, prodL, remL) == 1){
                                    n--;
                                    // Subtract divisor from product.
                                    subtract(prod, yL < prodL ? yz : yc, prodL, base);
                                    prodL = prod.length;
                                    cmp = 1;
                                }
                            } else {
                                // n is 0 or 1, cmp is -1.
                                // If n is 0, there is no need to compare yc and rem again below,
                                // so change cmp to 1 to avoid it.
                                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                                if (n == 0) {
                                    // divisor < remainder, so n must be at least 1.
                                    cmp = n = 1;
                                }
                                // product = divisor
                                prod = yc.slice();
                                prodL = prod.length;
                            }
                            if (prodL < remL) prod = [
                                0
                            ].concat(prod);
                            // Subtract product from remainder.
                            subtract(rem, prod, remL, base);
                            remL = rem.length;
                            // If product was < remainder.
                            if (cmp == -1) {
                                // Compare divisor and new remainder.
                                // If divisor < new remainder, subtract divisor from remainder.
                                // Trial digit n too low.
                                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                                while(compare(yc, rem, yL, remL) < 1){
                                    n++;
                                    // Subtract divisor from remainder.
                                    subtract(rem, yL < remL ? yz : yc, remL, base);
                                    remL = rem.length;
                                }
                            }
                        } else if (cmp === 0) {
                            n++;
                            rem = [
                                0
                            ];
                        } // else cmp === 1 and n will be 0
                        // Add the next digit, n, to the result array.
                        qc[i++] = n;
                        // Update the remainder.
                        if (rem[0]) {
                            rem[remL++] = xc[xi] || 0;
                        } else {
                            rem = [
                                xc[xi]
                            ];
                            remL = 1;
                        }
                    }while ((xi++ < xL || rem[0] != null) && s--)
                    more = rem[0] != null;
                    // Leading zero?
                    if (!qc[0]) qc.splice(0, 1);
                }
                if (base == BASE) {
                    // To calculate q.e, first get the number of digits of qc[0].
                    for(i = 1, s = qc[0]; s >= 10; s /= 10, i++);
                    round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
                // Caller is convertBase.
                } else {
                    q.e = e;
                    q.r = +more;
                }
                return q;
            };
        }();
        /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */ function format(n, i, rm, id) {
            var c0, e, ne, len, str;
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            if (!n.c) return n.toString();
            c0 = n.c[0];
            ne = n.e;
            if (i == null) {
                str = coeffToString(n.c);
                str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, '0');
            } else {
                n = round(new BigNumber(n), i, rm);
                // n.e may have changed if the value was rounded up.
                e = n.e;
                str = coeffToString(n.c);
                len = str.length;
                // toPrecision returns exponential notation if the number of significant digits
                // specified is less than the number of digits necessary to represent the integer
                // part of the value in fixed-point notation.
                // Exponential notation.
                if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
                    // Append zeros?
                    for(; len < i; str += '0', len++);
                    str = toExponential(str, e);
                // Fixed-point notation.
                } else {
                    i -= ne;
                    str = toFixedPoint(str, e, '0');
                    // Append zeros?
                    if (e + 1 > len) {
                        if (--i > 0) for(str += '.'; i--; str += '0');
                    } else {
                        i += e - len;
                        if (i > 0) {
                            if (e + 1 == len) str += '.';
                            for(; i--; str += '0');
                        }
                    }
                }
            }
            return n.s < 0 && c0 ? '-' + str : str;
        }
        // Handle BigNumber.max and BigNumber.min.
        // If any number is NaN, return NaN.
        function maxOrMin(args, n) {
            var k, y, i = 1, x = new BigNumber(args[0]);
            for(; i < args.length; i++){
                y = new BigNumber(args[i]);
                if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
                    x = y;
                }
            }
            return x;
        }
        /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */ function normalise(n, c, e) {
            var i = 1, j = c.length;
            // Remove trailing zeros.
            for(; !c[--j]; c.pop());
            // Calculate the base 10 exponent. First get the number of digits of c[0].
            for(j = c[0]; j >= 10; j /= 10, i++);
            // Overflow?
            if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
                // Infinity.
                n.c = n.e = null;
            // Underflow?
            } else if (e < MIN_EXP) {
                // Zero.
                n.c = [
                    n.e = 0
                ];
            } else {
                n.e = e;
                n.c = c;
            }
            return n;
        }
        // Handle values that fail the validity test in BigNumber.
        parseNumeric = function() {
            var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
            return function(x, str, isNum, b) {
                var base, s = isNum ? str : str.replace(whitespaceOrPlus, '');
                // No exception on ±Infinity or NaN.
                if (isInfinityOrNaN.test(s)) {
                    x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                } else {
                    if (!isNum) {
                        // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                        s = s.replace(basePrefix, function(m, p1, p2) {
                            base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
                            return !b || b == base ? p1 : m;
                        });
                        if (b) {
                            base = b;
                            // E.g. '1.' to '1', '.1' to '0.1'
                            s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
                        }
                        if (str != s) return new BigNumber(s, base);
                    }
                    // '[BigNumber Error] Not a number: {n}'
                    // '[BigNumber Error] Not a base {b} number: {n}'
                    if (BigNumber.DEBUG) {
                        throw Error(bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
                    }
                    // NaN
                    x.s = null;
                }
                x.c = x.e = null;
            };
        }();
        /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */ function round(x, sd, rm, r) {
            var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
            // if x is not Infinity or NaN...
            if (xc) {
                // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
                // n is a base 1e14 number, the value of the element of array x.c containing rd.
                // ni is the index of n within x.c.
                // d is the number of digits of n.
                // i is the index of rd within n including leading zeros.
                // j is the actual index of rd within n (if < 0, rd is a leading zero).
                out: {
                    // Get the number of digits of the first element of xc.
                    for(d = 1, k = xc[0]; k >= 10; k /= 10, d++);
                    i = sd - d;
                    // If the rounding digit is in the first element of xc...
                    if (i < 0) {
                        i += LOG_BASE;
                        j = sd;
                        n = xc[ni = 0];
                        // Get the rounding digit at index j of n.
                        rd = mathfloor(n / pows10[d - j - 1] % 10);
                    } else {
                        ni = mathceil((i + 1) / LOG_BASE);
                        if (ni >= xc.length) {
                            if (r) {
                                // Needed by sqrt.
                                for(; xc.length <= ni; xc.push(0));
                                n = rd = 0;
                                d = 1;
                                i %= LOG_BASE;
                                j = i - LOG_BASE + 1;
                            } else {
                                break out;
                            }
                        } else {
                            n = k = xc[ni];
                            // Get the number of digits of n.
                            for(d = 1; k >= 10; k /= 10, d++);
                            // Get the index of rd within n.
                            i %= LOG_BASE;
                            // Get the index of rd within n, adjusted for leading zeros.
                            // The number of leading zeros of n is given by LOG_BASE - d.
                            j = i - LOG_BASE + d;
                            // Get the rounding digit at index j of n.
                            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                        }
                    }
                    r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
                    // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
                    // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                    xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
                    r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
                    (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
                    if (sd < 1 || !xc[0]) {
                        xc.length = 0;
                        if (r) {
                            // Convert sd to decimal places.
                            sd -= x.e + 1;
                            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                            x.e = -sd || 0;
                        } else {
                            // Zero.
                            xc[0] = x.e = 0;
                        }
                        return x;
                    }
                    // Remove excess digits.
                    if (i == 0) {
                        xc.length = ni;
                        k = 1;
                        ni--;
                    } else {
                        xc.length = ni + 1;
                        k = pows10[LOG_BASE - i];
                        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                        // j > 0 means i > number of leading zeros of n.
                        xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
                    }
                    // Round up?
                    if (r) {
                        for(;;){
                            // If the digit to be rounded up is in the first element of xc...
                            if (ni == 0) {
                                // i will be the length of xc[0] before k is added.
                                for(i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                                j = xc[0] += k;
                                for(k = 1; j >= 10; j /= 10, k++);
                                // if i != k the length has increased.
                                if (i != k) {
                                    x.e++;
                                    if (xc[0] == BASE) xc[0] = 1;
                                }
                                break;
                            } else {
                                xc[ni] += k;
                                if (xc[ni] != BASE) break;
                                xc[ni--] = 0;
                                k = 1;
                            }
                        }
                    }
                    // Remove trailing zeros.
                    for(i = xc.length; xc[--i] === 0; xc.pop());
                }
                // Overflow? Infinity.
                if (x.e > MAX_EXP) {
                    x.c = x.e = null;
                // Underflow? Zero.
                } else if (x.e < MIN_EXP) {
                    x.c = [
                        x.e = 0
                    ];
                }
            }
            return x;
        }
        function valueOf(n) {
            var str, e = n.e;
            if (e === null) return n.toString();
            str = coeffToString(n.c);
            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, '0');
            return n.s < 0 ? '-' + str : str;
        }
        // PROTOTYPE/INSTANCE METHODS
        /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */ P.absoluteValue = P.abs = function() {
            var x = new BigNumber(this);
            if (x.s < 0) x.s = 1;
            return x;
        };
        /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */ P.comparedTo = function(y, b) {
            return compare(this, new BigNumber(y, b));
        };
        /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */ P.decimalPlaces = P.dp = function(dp, rm) {
            var c, n, v, x = this;
            if (dp != null) {
                intCheck(dp, 0, MAX);
                if (rm == null) rm = ROUNDING_MODE;
                else intCheck(rm, 0, 8);
                return round(new BigNumber(x), dp + x.e + 1, rm);
            }
            if (!(c = x.c)) return null;
            n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
            // Subtract the number of trailing zeros of the last number.
            if (v = c[v]) for(; v % 10 == 0; v /= 10, n--);
            if (n < 0) n = 0;
            return n;
        };
        /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */ P.dividedBy = P.div = function(y, b) {
            return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */ P.dividedToIntegerBy = P.idiv = function(y, b) {
            return div(this, new BigNumber(y, b), 0, 1);
        };
        /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */ P.exponentiatedBy = P.pow = function(n, m) {
            var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
            n = new BigNumber(n);
            // Allow NaN and ±Infinity, but not other non-integers.
            if (n.c && !n.isInteger()) {
                throw Error(bignumberError + 'Exponent not an integer: ' + valueOf(n));
            }
            if (m != null) m = new BigNumber(m);
            // Exponent of MAX_SAFE_INTEGER is 15.
            nIsBig = n.e > 14;
            // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
            if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
                // The sign of the result of pow when x is negative depends on the evenness of n.
                // If +n overflows to ±Infinity, the evenness of n would be not be known.
                y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
                return m ? y.mod(m) : y;
            }
            nIsNeg = n.s < 0;
            if (m) {
                // x % m returns NaN if abs(m) is zero, or m is NaN.
                if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);
                isModExp = !nIsNeg && x.isInteger() && m.isInteger();
                if (isModExp) x = x.mod(m);
            // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
            // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
            } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
                // If x is negative and n is odd, k = -0, else k = 0.
                k = x.s < 0 && isOdd(n) ? -0 : 0;
                // If x >= 1, k = ±Infinity.
                if (x.e > -1) k = 1 / k;
                // If n is negative return ±0, else return ±Infinity.
                return new BigNumber(nIsNeg ? 1 / k : k);
            } else if (POW_PRECISION) {
                // Truncating each coefficient array to a length of k after each multiplication
                // equates to truncating significant digits to POW_PRECISION + [28, 41],
                // i.e. there will be a minimum of 28 guard digits retained.
                k = mathceil(POW_PRECISION / LOG_BASE + 2);
            }
            if (nIsBig) {
                half = new BigNumber(0.5);
                if (nIsNeg) n.s = 1;
                nIsOdd = isOdd(n);
            } else {
                i = Math.abs(+valueOf(n));
                nIsOdd = i % 2;
            }
            y = new BigNumber(ONE);
            // Performs 54 loop iterations for n of 9007199254740991.
            for(;;){
                if (nIsOdd) {
                    y = y.times(x);
                    if (!y.c) break;
                    if (k) {
                        if (y.c.length > k) y.c.length = k;
                    } else if (isModExp) {
                        y = y.mod(m); //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
                    }
                }
                if (i) {
                    i = mathfloor(i / 2);
                    if (i === 0) break;
                    nIsOdd = i % 2;
                } else {
                    n = n.times(half);
                    round(n, n.e + 1, 1);
                    if (n.e > 14) {
                        nIsOdd = isOdd(n);
                    } else {
                        i = +valueOf(n);
                        if (i === 0) break;
                        nIsOdd = i % 2;
                    }
                }
                x = x.times(x);
                if (k) {
                    if (x.c && x.c.length > k) x.c.length = k;
                } else if (isModExp) {
                    x = x.mod(m); //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
                }
            }
            if (isModExp) return y;
            if (nIsNeg) y = ONE.div(y);
            return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */ P.integerValue = function(rm) {
            var n = new BigNumber(this);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(n, n.e + 1, rm);
        };
        /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */ P.isEqualTo = P.eq = function(y, b) {
            return compare(this, new BigNumber(y, b)) === 0;
        };
        /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */ P.isFinite = function() {
            return !!this.c;
        };
        /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */ P.isGreaterThan = P.gt = function(y, b) {
            return compare(this, new BigNumber(y, b)) > 0;
        };
        /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */ P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
            return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;
        };
        /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */ P.isInteger = function() {
            return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */ P.isLessThan = P.lt = function(y, b) {
            return compare(this, new BigNumber(y, b)) < 0;
        };
        /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */ P.isLessThanOrEqualTo = P.lte = function(y, b) {
            return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
        };
        /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */ P.isNaN = function() {
            return !this.s;
        };
        /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */ P.isNegative = function() {
            return this.s < 0;
        };
        /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */ P.isPositive = function() {
            return this.s > 0;
        };
        /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */ P.isZero = function() {
            return !!this.c && this.c[0] == 0;
        };
        /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */ P.minus = function(y, b) {
            var i, j, t, xLTy, x = this, a = x.s;
            y = new BigNumber(y, b);
            b = y.s;
            // Either NaN?
            if (!a || !b) return new BigNumber(NaN);
            // Signs differ?
            if (a != b) {
                y.s = -b;
                return x.plus(y);
            }
            var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
            if (!xe || !ye) {
                // Either Infinity?
                if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);
                // Either zero?
                if (!xc[0] || !yc[0]) {
                    // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                    return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x : // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                    ROUNDING_MODE == 3 ? -0 : 0);
                }
            }
            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();
            // Determine which is the bigger number.
            if (a = xe - ye) {
                if (xLTy = a < 0) {
                    a = -a;
                    t = xc;
                } else {
                    ye = xe;
                    t = yc;
                }
                t.reverse();
                // Prepend zeros to equalise exponents.
                for(b = a; b--; t.push(0));
                t.reverse();
            } else {
                // Exponents equal. Check digit by digit.
                j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
                for(a = b = 0; b < j; b++){
                    if (xc[b] != yc[b]) {
                        xLTy = xc[b] < yc[b];
                        break;
                    }
                }
            }
            // x < y? Point xc to the array of the bigger number.
            if (xLTy) {
                t = xc;
                xc = yc;
                yc = t;
                y.s = -y.s;
            }
            b = (j = yc.length) - (i = xc.length);
            // Append zeros to xc if shorter.
            // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
            if (b > 0) for(; b--; xc[i++] = 0);
            b = BASE - 1;
            // Subtract yc from xc.
            for(; j > a;){
                if (xc[--j] < yc[j]) {
                    for(i = j; i && !xc[--i]; xc[i] = b);
                    --xc[i];
                    xc[j] += BASE;
                }
                xc[j] -= yc[j];
            }
            // Remove leading zeros and adjust exponent accordingly.
            for(; xc[0] == 0; xc.splice(0, 1), --ye);
            // Zero?
            if (!xc[0]) {
                // Following IEEE 754 (2008) 6.3,
                // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
                y.s = ROUNDING_MODE == 3 ? -1 : 1;
                y.c = [
                    y.e = 0
                ];
                return y;
            }
            // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
            // for finite x and y.
            return normalise(y, xc, ye);
        };
        /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */ P.modulo = P.mod = function(y, b) {
            var q, s, x = this;
            y = new BigNumber(y, b);
            // Return NaN if x is Infinity or NaN, or y is NaN or zero.
            if (!x.c || !y.s || y.c && !y.c[0]) {
                return new BigNumber(NaN);
            // Return x if y is Infinity or x is zero.
            } else if (!y.c || x.c && !x.c[0]) {
                return new BigNumber(x);
            }
            if (MODULO_MODE == 9) {
                // Euclidian division: q = sign(y) * floor(x / abs(y))
                // r = x - qy    where  0 <= r < abs(y)
                s = y.s;
                y.s = 1;
                q = div(x, y, 0, 3);
                y.s = s;
                q.s *= s;
            } else {
                q = div(x, y, 0, MODULO_MODE);
            }
            y = x.minus(q.times(y));
            // To match JavaScript %, ensure sign of zero is sign of dividend.
            if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
            return y;
        };
        /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */ P.multipliedBy = P.times = function(y, b) {
            var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber(y, b)).c;
            // Either NaN, ±Infinity or ±0?
            if (!xc || !yc || !xc[0] || !yc[0]) {
                // Return NaN if either is NaN, or one is 0 and the other is Infinity.
                if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
                    y.c = y.e = y.s = null;
                } else {
                    y.s *= x.s;
                    // Return ±Infinity if either is ±Infinity.
                    if (!xc || !yc) {
                        y.c = y.e = null;
                    // Return ±0 if either is ±0.
                    } else {
                        y.c = [
                            0
                        ];
                        y.e = 0;
                    }
                }
                return y;
            }
            e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
            y.s *= x.s;
            xcL = xc.length;
            ycL = yc.length;
            // Ensure xc points to longer array and xcL to its length.
            if (xcL < ycL) {
                zc = xc;
                xc = yc;
                yc = zc;
                i = xcL;
                xcL = ycL;
                ycL = i;
            }
            // Initialise the result array with zeros.
            for(i = xcL + ycL, zc = []; i--; zc.push(0));
            base = BASE;
            sqrtBase = SQRT_BASE;
            for(i = ycL; --i >= 0;){
                c = 0;
                ylo = yc[i] % sqrtBase;
                yhi = yc[i] / sqrtBase | 0;
                for(k = xcL, j = i + k; j > i;){
                    xlo = xc[--k] % sqrtBase;
                    xhi = xc[k] / sqrtBase | 0;
                    m = yhi * xlo + xhi * ylo;
                    xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
                    c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
                    zc[j--] = xlo % base;
                }
                zc[j] = c;
            }
            if (c) {
                ++e;
            } else {
                zc.splice(0, 1);
            }
            return normalise(y, zc, e);
        };
        /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */ P.negated = function() {
            var x = new BigNumber(this);
            x.s = -x.s || null;
            return x;
        };
        /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */ P.plus = function(y, b) {
            var t, x = this, a = x.s;
            y = new BigNumber(y, b);
            b = y.s;
            // Either NaN?
            if (!a || !b) return new BigNumber(NaN);
            // Signs differ?
            if (a != b) {
                y.s = -b;
                return x.minus(y);
            }
            var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
            if (!xe || !ye) {
                // Return ±Infinity if either ±Infinity.
                if (!xc || !yc) return new BigNumber(a / 0);
                // Either zero?
                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
            }
            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();
            // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
            if (a = xe - ye) {
                if (a > 0) {
                    ye = xe;
                    t = yc;
                } else {
                    a = -a;
                    t = xc;
                }
                t.reverse();
                for(; a--; t.push(0));
                t.reverse();
            }
            a = xc.length;
            b = yc.length;
            // Point xc to the longer array, and b to the shorter length.
            if (a - b < 0) {
                t = yc;
                yc = xc;
                xc = t;
                b = a;
            }
            // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
            for(a = 0; b;){
                a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
                xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
            }
            if (a) {
                xc = [
                    a
                ].concat(xc);
                ++ye;
            }
            // No need to check for zero, as +x + +y != 0 && -x + -y != 0
            // ye = MAX_EXP + 1 possible
            return normalise(y, xc, ye);
        };
        /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */ P.precision = P.sd = function(sd, rm) {
            var c, n, v, x = this;
            if (sd != null && sd !== !!sd) {
                intCheck(sd, 1, MAX);
                if (rm == null) rm = ROUNDING_MODE;
                else intCheck(rm, 0, 8);
                return round(new BigNumber(x), sd, rm);
            }
            if (!(c = x.c)) return null;
            v = c.length - 1;
            n = v * LOG_BASE + 1;
            if (v = c[v]) {
                // Subtract the number of trailing zeros of the last element.
                for(; v % 10 == 0; v /= 10, n--);
                // Add the number of digits of the first element.
                for(v = c[0]; v >= 10; v /= 10, n++);
            }
            if (sd && x.e + 1 > n) n = x.e + 1;
            return n;
        };
        /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */ P.shiftedBy = function(k) {
            intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
            return this.times('1e' + k);
        };
        /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */ P.squareRoot = P.sqrt = function() {
            var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber('0.5');
            // Negative/NaN/Infinity/zero?
            if (s !== 1 || !c || !c[0]) {
                return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
            }
            // Initial estimate.
            s = Math.sqrt(+valueOf(x));
            // Math.sqrt underflow/overflow?
            // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
            if (s == 0 || s == 1 / 0) {
                n = coeffToString(c);
                if ((n.length + e) % 2 == 0) n += '0';
                s = Math.sqrt(+n);
                e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
                if (s == 1 / 0) {
                    n = '5e' + e;
                } else {
                    n = s.toExponential();
                    n = n.slice(0, n.indexOf('e') + 1) + e;
                }
                r = new BigNumber(n);
            } else {
                r = new BigNumber(s + '');
            }
            // Check for zero.
            // r could be zero if MIN_EXP is changed after the this value was created.
            // This would cause a division by zero (x/t) and hence Infinity below, which would cause
            // coeffToString to throw.
            if (r.c[0]) {
                e = r.e;
                s = e + dp;
                if (s < 3) s = 0;
                // Newton-Raphson iteration.
                for(;;){
                    t = r;
                    r = half.times(t.plus(div(x, t, dp, 1)));
                    if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                        // The exponent of r may here be one less than the final result exponent,
                        // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
                        // are indexed correctly.
                        if (r.e < e) --s;
                        n = n.slice(s - 3, s + 1);
                        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                        // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                        // iteration.
                        if (n == '9999' || !rep && n == '4999') {
                            // On the first iteration only, check to see if rounding up gives the
                            // exact result as the nines may infinitely repeat.
                            if (!rep) {
                                round(t, t.e + DECIMAL_PLACES + 2, 0);
                                if (t.times(t).eq(x)) {
                                    r = t;
                                    break;
                                }
                            }
                            dp += 4;
                            s += 4;
                            rep = 1;
                        } else {
                            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                            // result. If not, then there are further digits and m will be truthy.
                            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
                                // Truncate to the first rounding digit.
                                round(r, r.e + DECIMAL_PLACES + 2, 1);
                                m = !r.times(r).eq(x);
                            }
                            break;
                        }
                    }
                }
            }
            return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */ P.toExponential = function(dp, rm) {
            if (dp != null) {
                intCheck(dp, 0, MAX);
                dp++;
            }
            return format(this, dp, rm, 1);
        };
        /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */ P.toFixed = function(dp, rm) {
            if (dp != null) {
                intCheck(dp, 0, MAX);
                dp = dp + this.e + 1;
            }
            return format(this, dp, rm);
        };
        /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */ P.toFormat = function(dp, rm, format) {
            var str, x = this;
            if (format == null) {
                if (dp != null && rm && typeof rm == 'object') {
                    format = rm;
                    rm = null;
                } else if (dp && typeof dp == 'object') {
                    format = dp;
                    dp = rm = null;
                } else {
                    format = FORMAT;
                }
            } else if (typeof format != 'object') {
                throw Error(bignumberError + 'Argument not an object: ' + format);
            }
            str = x.toFixed(dp, rm);
            if (x.c) {
                var i, arr = str.split('.'), g1 = +format.groupSize, g2 = +format.secondaryGroupSize, groupSeparator = format.groupSeparator || '', intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
                if (g2) {
                    i = g1;
                    g1 = g2;
                    g2 = i;
                    len -= i;
                }
                if (g1 > 0 && len > 0) {
                    i = len % g1 || g1;
                    intPart = intDigits.substr(0, i);
                    for(; i < len; i += g1)intPart += groupSeparator + intDigits.substr(i, g1);
                    if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
                    if (isNeg) intPart = '-' + intPart;
                }
                str = fractionPart ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize) ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'), '$&' + (format.fractionGroupSeparator || '')) : fractionPart) : intPart;
            }
            return (format.prefix || '') + str + (format.suffix || '');
        };
        /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */ P.toFraction = function(md) {
            var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
            if (md != null) {
                n = new BigNumber(md);
                // Throw if md is less than one or is not an integer, unless it is Infinity.
                if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
                    throw Error(bignumberError + 'Argument ' + (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
                }
            }
            if (!xc) return new BigNumber(x);
            d = new BigNumber(ONE);
            n1 = d0 = new BigNumber(ONE);
            d1 = n0 = new BigNumber(ONE);
            s = coeffToString(xc);
            // Determine initial denominator.
            // d is a power of 10 and the minimum max denominator that specifies the value exactly.
            e = d.e = s.length - x.e - 1;
            d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
            md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
            exp = MAX_EXP;
            MAX_EXP = 1 / 0;
            n = new BigNumber(s);
            // n0 = d1 = 0
            n0.c[0] = 0;
            for(;;){
                q = div(n, d, 0, 1);
                d2 = d0.plus(q.times(d1));
                if (d2.comparedTo(md) == 1) break;
                d0 = d1;
                d1 = d2;
                n1 = n0.plus(q.times(d2 = n1));
                n0 = d2;
                d = n.minus(q.times(d2 = d));
                n = d2;
            }
            d2 = div(md.minus(d0), d1, 0, 1);
            n0 = n0.plus(d2.times(n1));
            d0 = d0.plus(d2.times(d1));
            n0.s = n1.s = x.s;
            e = e * 2;
            // Determine which fraction is closer to x, n0/d0 or n1/d1
            r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [
                n1,
                d1
            ] : [
                n0,
                d0
            ];
            MAX_EXP = exp;
            return r;
        };
        /*
     * Return the value of this BigNumber converted to a number primitive.
     */ P.toNumber = function() {
            return +valueOf(this);
        };
        /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */ P.toPrecision = function(sd, rm) {
            if (sd != null) intCheck(sd, 1, MAX);
            return format(this, sd, rm, 2);
        };
        /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */ P.toString = function(b) {
            var str, n = this, s = n.s, e = n.e;
            // Infinity or NaN?
            if (e === null) {
                if (s) {
                    str = 'Infinity';
                    if (s < 0) str = '-' + str;
                } else {
                    str = 'NaN';
                }
            } else {
                if (b == null) {
                    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, '0');
                } else if (b === 10 && alphabetHasNormalDecimalDigits) {
                    n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
                    str = toFixedPoint(coeffToString(n.c), n.e, '0');
                } else {
                    intCheck(b, 2, ALPHABET.length, 'Base');
                    str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
                }
                if (s < 0 && n.c[0]) str = '-' + str;
            }
            return str;
        };
        /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */ P.valueOf = P.toJSON = function() {
            return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null) BigNumber.set(configObject);
        return BigNumber;
    }
    // PRIVATE HELPER FUNCTIONS
    // These functions don't need access to variables,
    // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.
    function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
    }
    // Return a coefficient array as a string of base 10 digits.
    function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + '';
        for(; i < j;){
            s = a[i++] + '';
            z = LOG_BASE - s.length;
            for(; z--; s = '0' + s);
            r += s;
        }
        // Determine trailing zeros.
        for(j = r.length; r.charCodeAt(--j) === 48;);
        return r.slice(0, j + 1 || 1);
    }
    // Compare the value of BigNumbers x and y.
    function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        // Either NaN?
        if (!i || !j) return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        // Either zero?
        if (a || b) return a ? b ? 0 : -j : i;
        // Signs differ?
        if (i != j) return i;
        a = i < 0;
        b = k == l;
        // Either Infinity?
        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
        // Compare exponents.
        if (!b) return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        // Compare digit by digit.
        for(i = 0; i < j; i++)if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
        // Compare lengths.
        return k == l ? 0 : k > l ^ a ? 1 : -1;
    }
    /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */ function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
            throw Error(bignumberError + (name || 'Argument') + (typeof n == 'number' ? n < min || n > max ? ' out of range: ' : ' not an integer: ' : ' not a primitive number: ') + String(n));
        }
    }
    // Assumes finite n.
    function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
    }
    function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) + (e < 0 ? 'e' : 'e+') + e;
    }
    function toFixedPoint(str, e, z) {
        var len, zs;
        // Negative exponent?
        if (e < 0) {
            // Prepend zeros.
            for(zs = z + '.'; ++e; zs += z);
            str = zs + str;
        // Positive exponent
        } else {
            len = str.length;
            // Append zeros.
            if (++e > len) {
                for(zs = z, e -= len; --e; zs += z);
                str += zs;
            } else if (e < len) {
                str = str.slice(0, e) + '.' + str.slice(e);
            }
        }
        return str;
    }
    // EXPORT
    BigNumber = clone();
    BigNumber['default'] = BigNumber.BigNumber = BigNumber;
    // AMD.
    if (typeof define == 'function' && define.amd) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return BigNumber;
        }(__turbopack_context__.r, exports, module));
    // Node.js and other environments that support module.exports.
    } else if (("TURBOPACK compile-time value", "object") != 'undefined' && module.exports) {
        module.exports = BigNumber;
    // Browser.
    } else {
        if (!globalObject) {
            globalObject = typeof self != 'undefined' && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
    }
})(this);
}}),
"[project]/node_modules/.pnpm/jsbi@3.2.5/node_modules/jsbi/dist/jsbi.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
class JSBI extends Array {
    constructor(i, _){
        if (super(i), this.sign = _, i > JSBI.__kMaxLength) throw new RangeError("Maximum BigInt size exceeded");
    }
    static BigInt(i) {
        var _ = Math.floor, t = Number.isFinite;
        if ("number" == typeof i) {
            if (0 === i) return JSBI.__zero();
            if (JSBI.__isOneDigitInt(i)) return 0 > i ? JSBI.__oneDigit(-i, !0) : JSBI.__oneDigit(i, !1);
            if (!t(i) || _(i) !== i) throw new RangeError("The number " + i + " cannot be converted to BigInt because it is not an integer");
            return JSBI.__fromDouble(i);
        }
        if ("string" == typeof i) {
            const _ = JSBI.__fromString(i);
            if (null === _) throw new SyntaxError("Cannot convert " + i + " to a BigInt");
            return _;
        }
        if ("boolean" == typeof i) return !0 === i ? JSBI.__oneDigit(1, !1) : JSBI.__zero();
        if ("object" == typeof i) {
            if (i.constructor === JSBI) return i;
            const _ = JSBI.__toPrimitive(i);
            return JSBI.BigInt(_);
        }
        throw new TypeError("Cannot convert " + i + " to a BigInt");
    }
    toDebugString() {
        const i = [
            "BigInt["
        ];
        for (const _ of this)i.push((_ ? (_ >>> 0).toString(16) : _) + ", ");
        return i.push("]"), i.join("");
    }
    toString(i = 10) {
        if (2 > i || 36 < i) throw new RangeError("toString() radix argument must be between 2 and 36");
        return 0 === this.length ? "0" : 0 == (i & i - 1) ? JSBI.__toStringBasePowerOfTwo(this, i) : JSBI.__toStringGeneric(this, i, !1);
    }
    static toNumber(i) {
        const _ = i.length;
        if (0 === _) return 0;
        if (1 === _) {
            const _ = i.__unsignedDigit(0);
            return i.sign ? -_ : _;
        }
        const t = i.__digit(_ - 1), e = JSBI.__clz30(t), n = 30 * _ - e;
        if (1024 < n) return i.sign ? -Infinity : 1 / 0;
        let g = n - 1, o = t, s = _ - 1;
        const l = e + 3;
        let r = 32 === l ? 0 : o << l;
        r >>>= 12;
        const a = l - 12;
        let u = 12 <= l ? 0 : o << 20 + l, d = 20 + l;
        for(0 < a && 0 < s && (s--, o = i.__digit(s), r |= o >>> 30 - a, u = o << a + 2, d = a + 2); 0 < d && 0 < s;)s--, o = i.__digit(s), u |= 30 <= d ? o << d - 30 : o >>> 30 - d, d -= 30;
        const h = JSBI.__decideRounding(i, d, s, o);
        if ((1 === h || 0 === h && 1 == (1 & u)) && (u = u + 1 >>> 0, 0 === u && (r++, 0 != r >>> 20 && (r = 0, g++, 1023 < g)))) return i.sign ? -Infinity : 1 / 0;
        const m = i.sign ? -2147483648 : 0;
        return g = g + 1023 << 20, JSBI.__kBitConversionInts[1] = m | g | r, JSBI.__kBitConversionInts[0] = u, JSBI.__kBitConversionDouble[0];
    }
    static unaryMinus(i) {
        if (0 === i.length) return i;
        const _ = i.__copy();
        return _.sign = !i.sign, _;
    }
    static bitwiseNot(i) {
        return i.sign ? JSBI.__absoluteSubOne(i).__trim() : JSBI.__absoluteAddOne(i, !0);
    }
    static exponentiate(i, _) {
        if (_.sign) throw new RangeError("Exponent must be positive");
        if (0 === _.length) return JSBI.__oneDigit(1, !1);
        if (0 === i.length) return i;
        if (1 === i.length && 1 === i.__digit(0)) return i.sign && 0 == (1 & _.__digit(0)) ? JSBI.unaryMinus(i) : i;
        if (1 < _.length) throw new RangeError("BigInt too big");
        let t = _.__unsignedDigit(0);
        if (1 === t) return i;
        if (t >= JSBI.__kMaxLengthBits) throw new RangeError("BigInt too big");
        if (1 === i.length && 2 === i.__digit(0)) {
            const _ = 1 + (0 | t / 30), e = i.sign && 0 != (1 & t), n = new JSBI(_, e);
            n.__initializeDigits();
            const g = 1 << t % 30;
            return n.__setDigit(_ - 1, g), n;
        }
        let e = null, n = i;
        for(0 != (1 & t) && (e = i), t >>= 1; 0 !== t; t >>= 1)n = JSBI.multiply(n, n), 0 != (1 & t) && (null === e ? e = n : e = JSBI.multiply(e, n));
        return e;
    }
    static multiply(_, t) {
        if (0 === _.length) return _;
        if (0 === t.length) return t;
        let i = _.length + t.length;
        30 <= _.__clzmsd() + t.__clzmsd() && i--;
        const e = new JSBI(i, _.sign !== t.sign);
        e.__initializeDigits();
        for(let n = 0; n < _.length; n++)JSBI.__multiplyAccumulate(t, _.__digit(n), e, n);
        return e.__trim();
    }
    static divide(i, _) {
        if (0 === _.length) throw new RangeError("Division by zero");
        if (0 > JSBI.__absoluteCompare(i, _)) return JSBI.__zero();
        const t = i.sign !== _.sign, e = _.__unsignedDigit(0);
        let n;
        if (1 === _.length && 32767 >= e) {
            if (1 === e) return t === i.sign ? i : JSBI.unaryMinus(i);
            n = JSBI.__absoluteDivSmall(i, e, null);
        } else n = JSBI.__absoluteDivLarge(i, _, !0, !1);
        return n.sign = t, n.__trim();
    }
    static remainder(i, _) {
        if (0 === _.length) throw new RangeError("Division by zero");
        if (0 > JSBI.__absoluteCompare(i, _)) return i;
        const t = _.__unsignedDigit(0);
        if (1 === _.length && 32767 >= t) {
            if (1 === t) return JSBI.__zero();
            const _ = JSBI.__absoluteModSmall(i, t);
            return 0 === _ ? JSBI.__zero() : JSBI.__oneDigit(_, i.sign);
        }
        const e = JSBI.__absoluteDivLarge(i, _, !1, !0);
        return e.sign = i.sign, e.__trim();
    }
    static add(i, _) {
        const t = i.sign;
        return t === _.sign ? JSBI.__absoluteAdd(i, _, t) : 0 <= JSBI.__absoluteCompare(i, _) ? JSBI.__absoluteSub(i, _, t) : JSBI.__absoluteSub(_, i, !t);
    }
    static subtract(i, _) {
        const t = i.sign;
        return t === _.sign ? 0 <= JSBI.__absoluteCompare(i, _) ? JSBI.__absoluteSub(i, _, t) : JSBI.__absoluteSub(_, i, !t) : JSBI.__absoluteAdd(i, _, t);
    }
    static leftShift(i, _) {
        return 0 === _.length || 0 === i.length ? i : _.sign ? JSBI.__rightShiftByAbsolute(i, _) : JSBI.__leftShiftByAbsolute(i, _);
    }
    static signedRightShift(i, _) {
        return 0 === _.length || 0 === i.length ? i : _.sign ? JSBI.__leftShiftByAbsolute(i, _) : JSBI.__rightShiftByAbsolute(i, _);
    }
    static unsignedRightShift() {
        throw new TypeError("BigInts have no unsigned right shift; use >> instead");
    }
    static lessThan(i, _) {
        return 0 > JSBI.__compareToBigInt(i, _);
    }
    static lessThanOrEqual(i, _) {
        return 0 >= JSBI.__compareToBigInt(i, _);
    }
    static greaterThan(i, _) {
        return 0 < JSBI.__compareToBigInt(i, _);
    }
    static greaterThanOrEqual(i, _) {
        return 0 <= JSBI.__compareToBigInt(i, _);
    }
    static equal(_, t) {
        if (_.sign !== t.sign) return !1;
        if (_.length !== t.length) return !1;
        for(let e = 0; e < _.length; e++)if (_.__digit(e) !== t.__digit(e)) return !1;
        return !0;
    }
    static notEqual(i, _) {
        return !JSBI.equal(i, _);
    }
    static bitwiseAnd(i, _) {
        var t = Math.max;
        if (!i.sign && !_.sign) return JSBI.__absoluteAnd(i, _).__trim();
        if (i.sign && _.sign) {
            const e = t(i.length, _.length) + 1;
            let n = JSBI.__absoluteSubOne(i, e);
            const g = JSBI.__absoluteSubOne(_);
            return n = JSBI.__absoluteOr(n, g, n), JSBI.__absoluteAddOne(n, !0, n).__trim();
        }
        return i.sign && ([i, _] = [
            _,
            i
        ]), JSBI.__absoluteAndNot(i, JSBI.__absoluteSubOne(_)).__trim();
    }
    static bitwiseXor(i, _) {
        var t = Math.max;
        if (!i.sign && !_.sign) return JSBI.__absoluteXor(i, _).__trim();
        if (i.sign && _.sign) {
            const e = t(i.length, _.length), n = JSBI.__absoluteSubOne(i, e), g = JSBI.__absoluteSubOne(_);
            return JSBI.__absoluteXor(n, g, n).__trim();
        }
        const e = t(i.length, _.length) + 1;
        i.sign && ([i, _] = [
            _,
            i
        ]);
        let n = JSBI.__absoluteSubOne(_, e);
        return n = JSBI.__absoluteXor(n, i, n), JSBI.__absoluteAddOne(n, !0, n).__trim();
    }
    static bitwiseOr(i, _) {
        var t = Math.max;
        const e = t(i.length, _.length);
        if (!i.sign && !_.sign) return JSBI.__absoluteOr(i, _).__trim();
        if (i.sign && _.sign) {
            let t = JSBI.__absoluteSubOne(i, e);
            const n = JSBI.__absoluteSubOne(_);
            return t = JSBI.__absoluteAnd(t, n, t), JSBI.__absoluteAddOne(t, !0, t).__trim();
        }
        i.sign && ([i, _] = [
            _,
            i
        ]);
        let n = JSBI.__absoluteSubOne(_, e);
        return n = JSBI.__absoluteAndNot(n, i, n), JSBI.__absoluteAddOne(n, !0, n).__trim();
    }
    static asIntN(_, t) {
        var i = Math.floor;
        if (0 === t.length) return t;
        if (_ = i(_), 0 > _) throw new RangeError("Invalid value: not (convertible to) a safe integer");
        if (0 === _) return JSBI.__zero();
        if (_ >= JSBI.__kMaxLengthBits) return t;
        const e = 0 | (_ + 29) / 30;
        if (t.length < e) return t;
        const g = t.__unsignedDigit(e - 1), o = 1 << (_ - 1) % 30;
        if (t.length === e && g < o) return t;
        if (!((g & o) === o)) return JSBI.__truncateToNBits(_, t);
        if (!t.sign) return JSBI.__truncateAndSubFromPowerOfTwo(_, t, !0);
        if (0 == (g & o - 1)) {
            for(let n = e - 2; 0 <= n; n--)if (0 !== t.__digit(n)) return JSBI.__truncateAndSubFromPowerOfTwo(_, t, !1);
            return t.length === e && g === o ? t : JSBI.__truncateToNBits(_, t);
        }
        return JSBI.__truncateAndSubFromPowerOfTwo(_, t, !1);
    }
    static asUintN(i, _) {
        var t = Math.floor;
        if (0 === _.length) return _;
        if (i = t(i), 0 > i) throw new RangeError("Invalid value: not (convertible to) a safe integer");
        if (0 === i) return JSBI.__zero();
        if (_.sign) {
            if (i > JSBI.__kMaxLengthBits) throw new RangeError("BigInt too big");
            return JSBI.__truncateAndSubFromPowerOfTwo(i, _, !1);
        }
        if (i >= JSBI.__kMaxLengthBits) return _;
        const e = 0 | (i + 29) / 30;
        if (_.length < e) return _;
        const g = i % 30;
        if (_.length == e) {
            if (0 === g) return _;
            const i = _.__digit(e - 1);
            if (0 == i >>> g) return _;
        }
        return JSBI.__truncateToNBits(i, _);
    }
    static ADD(i, _) {
        if (i = JSBI.__toPrimitive(i), _ = JSBI.__toPrimitive(_), "string" == typeof i) return "string" != typeof _ && (_ = _.toString()), i + _;
        if ("string" == typeof _) return i.toString() + _;
        if (i = JSBI.__toNumeric(i), _ = JSBI.__toNumeric(_), JSBI.__isBigInt(i) && JSBI.__isBigInt(_)) return JSBI.add(i, _);
        if ("number" == typeof i && "number" == typeof _) return i + _;
        throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
    }
    static LT(i, _) {
        return JSBI.__compare(i, _, 0);
    }
    static LE(i, _) {
        return JSBI.__compare(i, _, 1);
    }
    static GT(i, _) {
        return JSBI.__compare(i, _, 2);
    }
    static GE(i, _) {
        return JSBI.__compare(i, _, 3);
    }
    static EQ(i, _) {
        for(;;){
            if (JSBI.__isBigInt(i)) return JSBI.__isBigInt(_) ? JSBI.equal(i, _) : JSBI.EQ(_, i);
            if ("number" == typeof i) {
                if (JSBI.__isBigInt(_)) return JSBI.__equalToNumber(_, i);
                if ("object" != typeof _) return i == _;
                _ = JSBI.__toPrimitive(_);
            } else if ("string" == typeof i) {
                if (JSBI.__isBigInt(_)) return i = JSBI.__fromString(i), null !== i && JSBI.equal(i, _);
                if ("object" != typeof _) return i == _;
                _ = JSBI.__toPrimitive(_);
            } else if ("boolean" == typeof i) {
                if (JSBI.__isBigInt(_)) return JSBI.__equalToNumber(_, +i);
                if ("object" != typeof _) return i == _;
                _ = JSBI.__toPrimitive(_);
            } else if ("symbol" == typeof i) {
                if (JSBI.__isBigInt(_)) return !1;
                if ("object" != typeof _) return i == _;
                _ = JSBI.__toPrimitive(_);
            } else if ("object" == typeof i) {
                if ("object" == typeof _ && _.constructor !== JSBI) return i == _;
                i = JSBI.__toPrimitive(i);
            } else return i == _;
        }
    }
    static NE(i, _) {
        return !JSBI.EQ(i, _);
    }
    static __zero() {
        return new JSBI(0, !1);
    }
    static __oneDigit(i, _) {
        const t = new JSBI(1, _);
        return t.__setDigit(0, i), t;
    }
    __copy() {
        const _ = new JSBI(this.length, this.sign);
        for(let t = 0; t < this.length; t++)_[t] = this[t];
        return _;
    }
    __trim() {
        let i = this.length, _ = this[i - 1];
        for(; 0 === _;)i--, _ = this[i - 1], this.pop();
        return 0 === i && (this.sign = !1), this;
    }
    __initializeDigits() {
        for(let _ = 0; _ < this.length; _++)this[_] = 0;
    }
    static __decideRounding(i, _, t, e) {
        if (0 < _) return -1;
        let n;
        if (0 > _) n = -_ - 1;
        else {
            if (0 === t) return -1;
            t--, e = i.__digit(t), n = 29;
        }
        let g = 1 << n;
        if (0 == (e & g)) return -1;
        if (g -= 1, 0 != (e & g)) return 1;
        for(; 0 < t;)if (t--, 0 !== i.__digit(t)) return 1;
        return 0;
    }
    static __fromDouble(i) {
        JSBI.__kBitConversionDouble[0] = i;
        const _ = 2047 & JSBI.__kBitConversionInts[1] >>> 20, t = _ - 1023, e = (0 | t / 30) + 1, n = new JSBI(e, 0 > i);
        let g = 1048575 & JSBI.__kBitConversionInts[1] | 1048576, o = JSBI.__kBitConversionInts[0];
        const s = 20, l = t % 30;
        let r, a = 0;
        if (l < 20) {
            const i = s - l;
            a = i + 32, r = g >>> i, g = g << 32 - i | o >>> i, o <<= 32 - i;
        } else if (l === 20) a = 32, r = g, g = o, o = 0;
        else {
            const i = l - s;
            a = 32 - i, r = g << i | o >>> 32 - i, g = o << i, o = 0;
        }
        n.__setDigit(e - 1, r);
        for(let _ = e - 2; 0 <= _; _--)0 < a ? (a -= 30, r = g >>> 2, g = g << 30 | o >>> 2, o <<= 30) : r = 0, n.__setDigit(_, r);
        return n.__trim();
    }
    static __isWhitespace(i) {
        return !!(13 >= i && 9 <= i) || (159 >= i ? 32 == i : 131071 >= i ? 160 == i || 5760 == i : 196607 >= i ? (i &= 131071, 10 >= i || 40 == i || 41 == i || 47 == i || 95 == i || 4096 == i) : 65279 == i);
    }
    static __fromString(i, _ = 0) {
        let t = 0;
        const e = i.length;
        let n = 0;
        if (n === e) return JSBI.__zero();
        let g = i.charCodeAt(n);
        for(; JSBI.__isWhitespace(g);){
            if (++n === e) return JSBI.__zero();
            g = i.charCodeAt(n);
        }
        if (43 === g) {
            if (++n === e) return null;
            g = i.charCodeAt(n), t = 1;
        } else if (45 === g) {
            if (++n === e) return null;
            g = i.charCodeAt(n), t = -1;
        }
        if (0 === _) {
            if (_ = 10, 48 === g) {
                if (++n === e) return JSBI.__zero();
                if (g = i.charCodeAt(n), 88 === g || 120 === g) {
                    if (_ = 16, ++n === e) return null;
                    g = i.charCodeAt(n);
                } else if (79 === g || 111 === g) {
                    if (_ = 8, ++n === e) return null;
                    g = i.charCodeAt(n);
                } else if (66 === g || 98 === g) {
                    if (_ = 2, ++n === e) return null;
                    g = i.charCodeAt(n);
                }
            }
        } else if (16 === _ && 48 === g) {
            if (++n === e) return JSBI.__zero();
            if (g = i.charCodeAt(n), 88 === g || 120 === g) {
                if (++n === e) return null;
                g = i.charCodeAt(n);
            }
        }
        if (0 != t && 10 !== _) return null;
        for(; 48 === g;){
            if (++n === e) return JSBI.__zero();
            g = i.charCodeAt(n);
        }
        const o = e - n;
        let s = JSBI.__kMaxBitsPerChar[_], l = JSBI.__kBitsPerCharTableMultiplier - 1;
        if (o > 1073741824 / s) return null;
        const r = s * o + l >>> JSBI.__kBitsPerCharTableShift, a = new JSBI(0 | (r + 29) / 30, !1), u = 10 > _ ? _ : 10, h = 10 < _ ? _ - 10 : 0;
        if (0 == (_ & _ - 1)) {
            s >>= JSBI.__kBitsPerCharTableShift;
            const _ = [], t = [];
            let o = !1;
            do {
                let l = 0, r = 0;
                for(;;){
                    let _;
                    if (g - 48 >>> 0 < u) _ = g - 48;
                    else if ((32 | g) - 97 >>> 0 < h) _ = (32 | g) - 87;
                    else {
                        o = !0;
                        break;
                    }
                    if (r += s, l = l << s | _, ++n === e) {
                        o = !0;
                        break;
                    }
                    if (g = i.charCodeAt(n), 30 < r + s) break;
                }
                _.push(l), t.push(r);
            }while (!o)
            JSBI.__fillFromParts(a, _, t);
        } else {
            a.__initializeDigits();
            let t = !1, o = 0;
            do {
                let r = 0, b = 1;
                for(;;){
                    let s;
                    if (g - 48 >>> 0 < u) s = g - 48;
                    else if ((32 | g) - 97 >>> 0 < h) s = (32 | g) - 87;
                    else {
                        t = !0;
                        break;
                    }
                    const l = b * _;
                    if (1073741823 < l) break;
                    if (b = l, r = r * _ + s, o++, ++n === e) {
                        t = !0;
                        break;
                    }
                    g = i.charCodeAt(n);
                }
                l = 30 * JSBI.__kBitsPerCharTableMultiplier - 1;
                const D = 0 | (s * o + l >>> JSBI.__kBitsPerCharTableShift) / 30;
                a.__inplaceMultiplyAdd(b, r, D);
            }while (!t)
        }
        if (n !== e) {
            if (!JSBI.__isWhitespace(g)) return null;
            for(n++; n < e; n++)if (g = i.charCodeAt(n), !JSBI.__isWhitespace(g)) return null;
        }
        return a.sign = -1 == t, a.__trim();
    }
    static __fillFromParts(_, t, e) {
        let n = 0, g = 0, o = 0;
        for(let s = t.length - 1; 0 <= s; s--){
            const i = t[s], l = e[s];
            g |= i << o, o += l, 30 === o ? (_.__setDigit(n++, g), o = 0, g = 0) : 30 < o && (_.__setDigit(n++, 1073741823 & g), o -= 30, g = i >>> l - o);
        }
        if (0 !== g) {
            if (n >= _.length) throw new Error("implementation bug");
            _.__setDigit(n++, g);
        }
        for(; n < _.length; n++)_.__setDigit(n, 0);
    }
    static __toStringBasePowerOfTwo(_, i) {
        const t = _.length;
        let e = i - 1;
        e = (85 & e >>> 1) + (85 & e), e = (51 & e >>> 2) + (51 & e), e = (15 & e >>> 4) + (15 & e);
        const n = e, g = i - 1, o = _.__digit(t - 1), s = JSBI.__clz30(o);
        let l = 0 | (30 * t - s + n - 1) / n;
        if (_.sign && l++, 268435456 < l) throw new Error("string too long");
        const r = Array(l);
        let a = l - 1, u = 0, d = 0;
        for(let e = 0; e < t - 1; e++){
            const i = _.__digit(e), t = (u | i << d) & g;
            r[a--] = JSBI.__kConversionChars[t];
            const o = n - d;
            for(u = i >>> o, d = 30 - o; d >= n;)r[a--] = JSBI.__kConversionChars[u & g], u >>>= n, d -= n;
        }
        const h = (u | o << d) & g;
        for(r[a--] = JSBI.__kConversionChars[h], u = o >>> n - d; 0 !== u;)r[a--] = JSBI.__kConversionChars[u & g], u >>>= n;
        if (_.sign && (r[a--] = "-"), -1 != a) throw new Error("implementation bug");
        return r.join("");
    }
    static __toStringGeneric(_, i, t) {
        const e = _.length;
        if (0 === e) return "";
        if (1 === e) {
            let e = _.__unsignedDigit(0).toString(i);
            return !1 === t && _.sign && (e = "-" + e), e;
        }
        const n = 30 * e - JSBI.__clz30(_.__digit(e - 1)), g = JSBI.__kMaxBitsPerChar[i], o = g - 1;
        let s = n * JSBI.__kBitsPerCharTableMultiplier;
        s += o - 1, s = 0 | s / o;
        const l = s + 1 >> 1, r = JSBI.exponentiate(JSBI.__oneDigit(i, !1), JSBI.__oneDigit(l, !1));
        let a, u;
        const d = r.__unsignedDigit(0);
        if (1 === r.length && 32767 >= d) {
            a = new JSBI(_.length, !1), a.__initializeDigits();
            let t = 0;
            for(let e = 2 * _.length - 1; 0 <= e; e--){
                const i = t << 15 | _.__halfDigit(e);
                a.__setHalfDigit(e, 0 | i / d), t = 0 | i % d;
            }
            u = t.toString(i);
        } else {
            const t = JSBI.__absoluteDivLarge(_, r, !0, !0);
            a = t.quotient;
            const e = t.remainder.__trim();
            u = JSBI.__toStringGeneric(e, i, !0);
        }
        a.__trim();
        let h = JSBI.__toStringGeneric(a, i, !0);
        for(; u.length < l;)u = "0" + u;
        return !1 === t && _.sign && (h = "-" + h), h + u;
    }
    static __unequalSign(i) {
        return i ? -1 : 1;
    }
    static __absoluteGreater(i) {
        return i ? -1 : 1;
    }
    static __absoluteLess(i) {
        return i ? 1 : -1;
    }
    static __compareToBigInt(i, _) {
        const t = i.sign;
        if (t !== _.sign) return JSBI.__unequalSign(t);
        const e = JSBI.__absoluteCompare(i, _);
        return 0 < e ? JSBI.__absoluteGreater(t) : 0 > e ? JSBI.__absoluteLess(t) : 0;
    }
    static __compareToNumber(i, _) {
        if (JSBI.__isOneDigitInt(_)) {
            const t = i.sign, e = 0 > _;
            if (t !== e) return JSBI.__unequalSign(t);
            if (0 === i.length) {
                if (e) throw new Error("implementation bug");
                return 0 === _ ? 0 : -1;
            }
            if (1 < i.length) return JSBI.__absoluteGreater(t);
            const n = Math.abs(_), g = i.__unsignedDigit(0);
            return g > n ? JSBI.__absoluteGreater(t) : g < n ? JSBI.__absoluteLess(t) : 0;
        }
        return JSBI.__compareToDouble(i, _);
    }
    static __compareToDouble(i, _) {
        if (_ !== _) return _;
        if (_ === 1 / 0) return -1;
        if (_ === -Infinity) return 1;
        const t = i.sign;
        if (t !== 0 > _) return JSBI.__unequalSign(t);
        if (0 === _) throw new Error("implementation bug: should be handled elsewhere");
        if (0 === i.length) return -1;
        JSBI.__kBitConversionDouble[0] = _;
        const e = 2047 & JSBI.__kBitConversionInts[1] >>> 20;
        if (2047 == e) throw new Error("implementation bug: handled elsewhere");
        const n = e - 1023;
        if (0 > n) return JSBI.__absoluteGreater(t);
        const g = i.length;
        let o = i.__digit(g - 1);
        const s = JSBI.__clz30(o), l = 30 * g - s, r = n + 1;
        if (l < r) return JSBI.__absoluteLess(t);
        if (l > r) return JSBI.__absoluteGreater(t);
        let a = 1048576 | 1048575 & JSBI.__kBitConversionInts[1], u = JSBI.__kBitConversionInts[0];
        const d = 20, h = 29 - s;
        if (h !== (0 | (l - 1) % 30)) throw new Error("implementation bug");
        let m, b = 0;
        if (20 > h) {
            const i = d - h;
            b = i + 32, m = a >>> i, a = a << 32 - i | u >>> i, u <<= 32 - i;
        } else if (20 === h) b = 32, m = a, a = u, u = 0;
        else {
            const i = h - d;
            b = 32 - i, m = a << i | u >>> 32 - i, a = u << i, u = 0;
        }
        if (o >>>= 0, m >>>= 0, o > m) return JSBI.__absoluteGreater(t);
        if (o < m) return JSBI.__absoluteLess(t);
        for(let e = g - 2; 0 <= e; e--){
            0 < b ? (b -= 30, m = a >>> 2, a = a << 30 | u >>> 2, u <<= 30) : m = 0;
            const _ = i.__unsignedDigit(e);
            if (_ > m) return JSBI.__absoluteGreater(t);
            if (_ < m) return JSBI.__absoluteLess(t);
        }
        if (0 !== a || 0 !== u) {
            if (0 === b) throw new Error("implementation bug");
            return JSBI.__absoluteLess(t);
        }
        return 0;
    }
    static __equalToNumber(i, _) {
        var t = Math.abs;
        return JSBI.__isOneDigitInt(_) ? 0 === _ ? 0 === i.length : 1 === i.length && i.sign === 0 > _ && i.__unsignedDigit(0) === t(_) : 0 === JSBI.__compareToDouble(i, _);
    }
    static __comparisonResultToBool(i, _) {
        return 0 === _ ? 0 > i : 1 === _ ? 0 >= i : 2 === _ ? 0 < i : 3 === _ ? 0 <= i : void 0;
    }
    static __compare(i, _, t) {
        if (i = JSBI.__toPrimitive(i), _ = JSBI.__toPrimitive(_), "string" == typeof i && "string" == typeof _) switch(t){
            case 0:
                return i < _;
            case 1:
                return i <= _;
            case 2:
                return i > _;
            case 3:
                return i >= _;
        }
        if (JSBI.__isBigInt(i) && "string" == typeof _) return _ = JSBI.__fromString(_), null !== _ && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i, _), t);
        if ("string" == typeof i && JSBI.__isBigInt(_)) return i = JSBI.__fromString(i), null !== i && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i, _), t);
        if (i = JSBI.__toNumeric(i), _ = JSBI.__toNumeric(_), JSBI.__isBigInt(i)) {
            if (JSBI.__isBigInt(_)) return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i, _), t);
            if ("number" != typeof _) throw new Error("implementation bug");
            return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(i, _), t);
        }
        if ("number" != typeof i) throw new Error("implementation bug");
        if (JSBI.__isBigInt(_)) return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(_, i), 2 ^ t);
        if ("number" != typeof _) throw new Error("implementation bug");
        return 0 === t ? i < _ : 1 === t ? i <= _ : 2 === t ? i > _ : 3 === t ? i >= _ : void 0;
    }
    __clzmsd() {
        return JSBI.__clz30(this.__digit(this.length - 1));
    }
    static __absoluteAdd(_, t, e) {
        if (_.length < t.length) return JSBI.__absoluteAdd(t, _, e);
        if (0 === _.length) return _;
        if (0 === t.length) return _.sign === e ? _ : JSBI.unaryMinus(_);
        let n = _.length;
        (0 === _.__clzmsd() || t.length === _.length && 0 === t.__clzmsd()) && n++;
        const g = new JSBI(n, e);
        let o = 0, s = 0;
        for(; s < t.length; s++){
            const i = _.__digit(s) + t.__digit(s) + o;
            o = i >>> 30, g.__setDigit(s, 1073741823 & i);
        }
        for(; s < _.length; s++){
            const i = _.__digit(s) + o;
            o = i >>> 30, g.__setDigit(s, 1073741823 & i);
        }
        return s < g.length && g.__setDigit(s, o), g.__trim();
    }
    static __absoluteSub(_, t, e) {
        if (0 === _.length) return _;
        if (0 === t.length) return _.sign === e ? _ : JSBI.unaryMinus(_);
        const n = new JSBI(_.length, e);
        let g = 0, o = 0;
        for(; o < t.length; o++){
            const i = _.__digit(o) - t.__digit(o) - g;
            g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
        }
        for(; o < _.length; o++){
            const i = _.__digit(o) - g;
            g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
        }
        return n.__trim();
    }
    static __absoluteAddOne(_, i, t = null) {
        const e = _.length;
        null === t ? t = new JSBI(e, i) : t.sign = i;
        let n = 1;
        for(let g = 0; g < e; g++){
            const i = _.__digit(g) + n;
            n = i >>> 30, t.__setDigit(g, 1073741823 & i);
        }
        return 0 != n && t.__setDigitGrow(e, 1), t;
    }
    static __absoluteSubOne(_, t) {
        const e = _.length;
        t = t || e;
        const n = new JSBI(t, !1);
        let g = 1;
        for(let o = 0; o < e; o++){
            const i = _.__digit(o) - g;
            g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
        }
        if (0 != g) throw new Error("implementation bug");
        for(let g = e; g < t; g++)n.__setDigit(g, 0);
        return n;
    }
    static __absoluteAnd(_, t, e = null) {
        let n = _.length, g = t.length, o = g;
        if (n < g) {
            o = n;
            const i = _, e = n;
            _ = t, n = g, t = i, g = e;
        }
        let s = o;
        null === e ? e = new JSBI(s, !1) : s = e.length;
        let l = 0;
        for(; l < o; l++)e.__setDigit(l, _.__digit(l) & t.__digit(l));
        for(; l < s; l++)e.__setDigit(l, 0);
        return e;
    }
    static __absoluteAndNot(_, t, e = null) {
        const n = _.length, g = t.length;
        let o = g;
        n < g && (o = n);
        let s = n;
        null === e ? e = new JSBI(s, !1) : s = e.length;
        let l = 0;
        for(; l < o; l++)e.__setDigit(l, _.__digit(l) & ~t.__digit(l));
        for(; l < n; l++)e.__setDigit(l, _.__digit(l));
        for(; l < s; l++)e.__setDigit(l, 0);
        return e;
    }
    static __absoluteOr(_, t, e = null) {
        let n = _.length, g = t.length, o = g;
        if (n < g) {
            o = n;
            const i = _, e = n;
            _ = t, n = g, t = i, g = e;
        }
        let s = n;
        null === e ? e = new JSBI(s, !1) : s = e.length;
        let l = 0;
        for(; l < o; l++)e.__setDigit(l, _.__digit(l) | t.__digit(l));
        for(; l < n; l++)e.__setDigit(l, _.__digit(l));
        for(; l < s; l++)e.__setDigit(l, 0);
        return e;
    }
    static __absoluteXor(_, t, e = null) {
        let n = _.length, g = t.length, o = g;
        if (n < g) {
            o = n;
            const i = _, e = n;
            _ = t, n = g, t = i, g = e;
        }
        let s = n;
        null === e ? e = new JSBI(s, !1) : s = e.length;
        let l = 0;
        for(; l < o; l++)e.__setDigit(l, _.__digit(l) ^ t.__digit(l));
        for(; l < n; l++)e.__setDigit(l, _.__digit(l));
        for(; l < s; l++)e.__setDigit(l, 0);
        return e;
    }
    static __absoluteCompare(_, t) {
        const e = _.length - t.length;
        if (0 != e) return e;
        let n = _.length - 1;
        for(; 0 <= n && _.__digit(n) === t.__digit(n);)n--;
        return 0 > n ? 0 : _.__unsignedDigit(n) > t.__unsignedDigit(n) ? 1 : -1;
    }
    static __multiplyAccumulate(_, t, e, n) {
        if (0 === t) return;
        const g = 32767 & t, o = t >>> 15;
        let s = 0, l = 0;
        for(let r, a = 0; a < _.length; a++, n++){
            r = e.__digit(n);
            const i = _.__digit(a), t = 32767 & i, u = i >>> 15, d = JSBI.__imul(t, g), h = JSBI.__imul(t, o), m = JSBI.__imul(u, g), b = JSBI.__imul(u, o);
            r += l + d + s, s = r >>> 30, r &= 1073741823, r += ((32767 & h) << 15) + ((32767 & m) << 15), s += r >>> 30, l = b + (h >>> 15) + (m >>> 15), e.__setDigit(n, 1073741823 & r);
        }
        for(; 0 != s || 0 !== l; n++){
            let i = e.__digit(n);
            i += s + l, l = 0, s = i >>> 30, e.__setDigit(n, 1073741823 & i);
        }
    }
    static __internalMultiplyAdd(_, t, e, g, o) {
        let s = e, l = 0;
        for(let n = 0; n < g; n++){
            const i = _.__digit(n), e = JSBI.__imul(32767 & i, t), g = JSBI.__imul(i >>> 15, t), a = e + ((32767 & g) << 15) + l + s;
            s = a >>> 30, l = g >>> 15, o.__setDigit(n, 1073741823 & a);
        }
        if (o.length > g) for(o.__setDigit(g++, s + l); g < o.length;)o.__setDigit(g++, 0);
        else if (0 !== s + l) throw new Error("implementation bug");
    }
    __inplaceMultiplyAdd(i, _, t) {
        t > this.length && (t = this.length);
        const e = 32767 & i, n = i >>> 15;
        let g = 0, o = _;
        for(let s = 0; s < t; s++){
            const i = this.__digit(s), _ = 32767 & i, t = i >>> 15, l = JSBI.__imul(_, e), r = JSBI.__imul(_, n), a = JSBI.__imul(t, e), u = JSBI.__imul(t, n);
            let d = o + l + g;
            g = d >>> 30, d &= 1073741823, d += ((32767 & r) << 15) + ((32767 & a) << 15), g += d >>> 30, o = u + (r >>> 15) + (a >>> 15), this.__setDigit(s, 1073741823 & d);
        }
        if (0 != g || 0 !== o) throw new Error("implementation bug");
    }
    static __absoluteDivSmall(_, t, e = null) {
        null === e && (e = new JSBI(_.length, !1));
        let n = 0;
        for(let g, o = 2 * _.length - 1; 0 <= o; o -= 2){
            g = (n << 15 | _.__halfDigit(o)) >>> 0;
            const i = 0 | g / t;
            n = 0 | g % t, g = (n << 15 | _.__halfDigit(o - 1)) >>> 0;
            const s = 0 | g / t;
            n = 0 | g % t, e.__setDigit(o >>> 1, i << 15 | s);
        }
        return e;
    }
    static __absoluteModSmall(_, t) {
        let e = 0;
        for(let n = 2 * _.length - 1; 0 <= n; n--){
            const i = (e << 15 | _.__halfDigit(n)) >>> 0;
            e = 0 | i % t;
        }
        return e;
    }
    static __absoluteDivLarge(i, _, t, e) {
        const g = _.__halfDigitLength(), n = _.length, o = i.__halfDigitLength() - g;
        let s = null;
        t && (s = new JSBI(o + 2 >>> 1, !1), s.__initializeDigits());
        const l = new JSBI(g + 2 >>> 1, !1);
        l.__initializeDigits();
        const r = JSBI.__clz15(_.__halfDigit(g - 1));
        0 < r && (_ = JSBI.__specialLeftShift(_, r, 0));
        const a = JSBI.__specialLeftShift(i, r, 1), u = _.__halfDigit(g - 1);
        let d = 0;
        for(let r, h = o; 0 <= h; h--){
            r = 32767;
            const i = a.__halfDigit(h + g);
            if (i !== u) {
                const t = (i << 15 | a.__halfDigit(h + g - 1)) >>> 0;
                r = 0 | t / u;
                let e = 0 | t % u;
                const n = _.__halfDigit(g - 2), o = a.__halfDigit(h + g - 2);
                for(; JSBI.__imul(r, n) >>> 0 > (e << 16 | o) >>> 0 && (r--, e += u, !(32767 < e)););
            }
            JSBI.__internalMultiplyAdd(_, r, 0, n, l);
            let e = a.__inplaceSub(l, h, g + 1);
            0 !== e && (e = a.__inplaceAdd(_, h, g), a.__setHalfDigit(h + g, 32767 & a.__halfDigit(h + g) + e), r--), t && (1 & h ? d = r << 15 : s.__setDigit(h >>> 1, d | r));
        }
        if (e) return a.__inplaceRightShift(r), t ? {
            quotient: s,
            remainder: a
        } : a;
        if (t) return s;
        throw new Error("unreachable");
    }
    static __clz15(i) {
        return JSBI.__clz30(i) - 15;
    }
    __inplaceAdd(_, t, e) {
        let n = 0;
        for(let g = 0; g < e; g++){
            const i = this.__halfDigit(t + g) + _.__halfDigit(g) + n;
            n = i >>> 15, this.__setHalfDigit(t + g, 32767 & i);
        }
        return n;
    }
    __inplaceSub(_, t, e) {
        let n = 0;
        if (1 & t) {
            t >>= 1;
            let g = this.__digit(t), o = 32767 & g, s = 0;
            for(; s < e - 1 >>> 1; s++){
                const i = _.__digit(s), e = (g >>> 15) - (32767 & i) - n;
                n = 1 & e >>> 15, this.__setDigit(t + s, (32767 & e) << 15 | 32767 & o), g = this.__digit(t + s + 1), o = (32767 & g) - (i >>> 15) - n, n = 1 & o >>> 15;
            }
            const i = _.__digit(s), l = (g >>> 15) - (32767 & i) - n;
            n = 1 & l >>> 15, this.__setDigit(t + s, (32767 & l) << 15 | 32767 & o);
            if (t + s + 1 >= this.length) throw new RangeError("out of bounds");
            0 == (1 & e) && (g = this.__digit(t + s + 1), o = (32767 & g) - (i >>> 15) - n, n = 1 & o >>> 15, this.__setDigit(t + _.length, 1073709056 & g | 32767 & o));
        } else {
            t >>= 1;
            let g = 0;
            for(; g < _.length - 1; g++){
                const i = this.__digit(t + g), e = _.__digit(g), o = (32767 & i) - (32767 & e) - n;
                n = 1 & o >>> 15;
                const s = (i >>> 15) - (e >>> 15) - n;
                n = 1 & s >>> 15, this.__setDigit(t + g, (32767 & s) << 15 | 32767 & o);
            }
            const i = this.__digit(t + g), o = _.__digit(g), s = (32767 & i) - (32767 & o) - n;
            n = 1 & s >>> 15;
            let l = 0;
            0 == (1 & e) && (l = (i >>> 15) - (o >>> 15) - n, n = 1 & l >>> 15), this.__setDigit(t + g, (32767 & l) << 15 | 32767 & s);
        }
        return n;
    }
    __inplaceRightShift(_) {
        if (0 === _) return;
        let t = this.__digit(0) >>> _;
        const e = this.length - 1;
        for(let n = 0; n < e; n++){
            const i = this.__digit(n + 1);
            this.__setDigit(n, 1073741823 & i << 30 - _ | t), t = i >>> _;
        }
        this.__setDigit(e, t);
    }
    static __specialLeftShift(_, t, e) {
        const g = _.length, n = new JSBI(g + e, !1);
        if (0 === t) {
            for(let t = 0; t < g; t++)n.__setDigit(t, _.__digit(t));
            return 0 < e && n.__setDigit(g, 0), n;
        }
        let o = 0;
        for(let s = 0; s < g; s++){
            const i = _.__digit(s);
            n.__setDigit(s, 1073741823 & i << t | o), o = i >>> 30 - t;
        }
        return 0 < e && n.__setDigit(g, o), n;
    }
    static __leftShiftByAbsolute(_, i) {
        const t = JSBI.__toShiftAmount(i);
        if (0 > t) throw new RangeError("BigInt too big");
        const e = 0 | t / 30, n = t % 30, g = _.length, o = 0 !== n && 0 != _.__digit(g - 1) >>> 30 - n, s = g + e + (o ? 1 : 0), l = new JSBI(s, _.sign);
        if (0 === n) {
            let t = 0;
            for(; t < e; t++)l.__setDigit(t, 0);
            for(; t < s; t++)l.__setDigit(t, _.__digit(t - e));
        } else {
            let t = 0;
            for(let _ = 0; _ < e; _++)l.__setDigit(_, 0);
            for(let o = 0; o < g; o++){
                const i = _.__digit(o);
                l.__setDigit(o + e, 1073741823 & i << n | t), t = i >>> 30 - n;
            }
            if (o) l.__setDigit(g + e, t);
            else if (0 !== t) throw new Error("implementation bug");
        }
        return l.__trim();
    }
    static __rightShiftByAbsolute(_, i) {
        const t = _.length, e = _.sign, n = JSBI.__toShiftAmount(i);
        if (0 > n) return JSBI.__rightShiftByMaximum(e);
        const g = 0 | n / 30, o = n % 30;
        let s = t - g;
        if (0 >= s) return JSBI.__rightShiftByMaximum(e);
        let l = !1;
        if (e) {
            if (0 != (_.__digit(g) & (1 << o) - 1)) l = !0;
            else for(let t = 0; t < g; t++)if (0 !== _.__digit(t)) {
                l = !0;
                break;
            }
        }
        if (l && 0 === o) {
            const i = _.__digit(t - 1);
            0 == ~i && s++;
        }
        let r = new JSBI(s, e);
        if (0 === o) {
            r.__setDigit(s - 1, 0);
            for(let e = g; e < t; e++)r.__setDigit(e - g, _.__digit(e));
        } else {
            let e = _.__digit(g) >>> o;
            const n = t - g - 1;
            for(let t = 0; t < n; t++){
                const i = _.__digit(t + g + 1);
                r.__setDigit(t, 1073741823 & i << 30 - o | e), e = i >>> o;
            }
            r.__setDigit(n, e);
        }
        return l && (r = JSBI.__absoluteAddOne(r, !0, r)), r.__trim();
    }
    static __rightShiftByMaximum(i) {
        return i ? JSBI.__oneDigit(1, !0) : JSBI.__zero();
    }
    static __toShiftAmount(i) {
        if (1 < i.length) return -1;
        const _ = i.__unsignedDigit(0);
        return _ > JSBI.__kMaxLengthBits ? -1 : _;
    }
    static __toPrimitive(i, _ = "default") {
        if ("object" != typeof i) return i;
        if (i.constructor === JSBI) return i;
        if ("undefined" != typeof Symbol && "symbol" == typeof Symbol.toPrimitive) {
            const t = i[Symbol.toPrimitive];
            if (t) {
                const i = t(_);
                if ("object" != typeof i) return i;
                throw new TypeError("Cannot convert object to primitive value");
            }
        }
        const t = i.valueOf;
        if (t) {
            const _ = t.call(i);
            if ("object" != typeof _) return _;
        }
        const e = i.toString;
        if (e) {
            const _ = e.call(i);
            if ("object" != typeof _) return _;
        }
        throw new TypeError("Cannot convert object to primitive value");
    }
    static __toNumeric(i) {
        return JSBI.__isBigInt(i) ? i : +i;
    }
    static __isBigInt(i) {
        return "object" == typeof i && null !== i && i.constructor === JSBI;
    }
    static __truncateToNBits(i, _) {
        const t = 0 | (i + 29) / 30, e = new JSBI(t, _.sign), n = t - 1;
        for(let t = 0; t < n; t++)e.__setDigit(t, _.__digit(t));
        let g = _.__digit(n);
        if (0 != i % 30) {
            const _ = 32 - i % 30;
            g = g << _ >>> _;
        }
        return e.__setDigit(n, g), e.__trim();
    }
    static __truncateAndSubFromPowerOfTwo(_, t, e) {
        var n = Math.min;
        const g = 0 | (_ + 29) / 30, o = new JSBI(g, e);
        let s = 0;
        const l = g - 1;
        let a = 0;
        for(const i = n(l, t.length); s < i; s++){
            const i = 0 - t.__digit(s) - a;
            a = 1 & i >>> 30, o.__setDigit(s, 1073741823 & i);
        }
        for(; s < l; s++)o.__setDigit(s, 0 | 1073741823 & -a);
        let u = l < t.length ? t.__digit(l) : 0;
        const d = _ % 30;
        let h;
        if (0 == d) h = 0 - u - a, h &= 1073741823;
        else {
            const i = 32 - d;
            u = u << i >>> i;
            const _ = 1 << 32 - i;
            h = _ - u - a, h &= _ - 1;
        }
        return o.__setDigit(l, h), o.__trim();
    }
    __digit(_) {
        return this[_];
    }
    __unsignedDigit(_) {
        return this[_] >>> 0;
    }
    __setDigit(_, i) {
        this[_] = 0 | i;
    }
    __setDigitGrow(_, i) {
        this[_] = 0 | i;
    }
    __halfDigitLength() {
        const i = this.length;
        return 32767 >= this.__unsignedDigit(i - 1) ? 2 * i - 1 : 2 * i;
    }
    __halfDigit(_) {
        return 32767 & this[_ >>> 1] >>> 15 * (1 & _);
    }
    __setHalfDigit(_, i) {
        const t = _ >>> 1, e = this.__digit(t), n = 1 & _ ? 32767 & e | i << 15 : 1073709056 & e | 32767 & i;
        this.__setDigit(t, n);
    }
    static __digitPow(i, _) {
        let t = 1;
        for(; 0 < _;)1 & _ && (t *= i), _ >>>= 1, i *= i;
        return t;
    }
    static __isOneDigitInt(i) {
        return (1073741823 & i) === i;
    }
}
JSBI.__kMaxLength = 33554432, JSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5, JSBI.__kMaxBitsPerChar = [
    0,
    0,
    32,
    51,
    64,
    75,
    83,
    90,
    96,
    102,
    107,
    111,
    115,
    119,
    122,
    126,
    128,
    131,
    134,
    136,
    139,
    141,
    143,
    145,
    147,
    149,
    151,
    153,
    154,
    156,
    158,
    159,
    160,
    162,
    163,
    165,
    166
], JSBI.__kBitsPerCharTableShift = 5, JSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift, JSBI.__kConversionChars = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z"
], JSBI.__kBitConversionBuffer = new ArrayBuffer(8), JSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer), JSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer), JSBI.__clz30 = Math.clz32 ? function(i) {
    return Math.clz32(i) - 2;
} : function(i) {
    return 0 === i ? 30 : 0 | 29 - (0 | Math.log(i >>> 0) / Math.LN2);
}, JSBI.__imul = Math.imul || function(i, _) {
    return 0 | i * _;
};
const __TURBOPACK__default__export__ = JSBI;
 //# sourceMappingURL=jsbi.mjs.map
}}),
"[project]/node_modules/.pnpm/@keystonehq+alias-sampling@0.1.2/node_modules/@keystonehq/alias-sampling/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var precomputeAlias = function(p, n) {
    var sum = p.reduce(function(acc, val) {
        if (val < 0) {
            throw new Error('Probability must be a positive: p[' + p.indexOf(val) + ']=' + val);
        }
        return acc + val;
    }, 0);
    if (sum === 0) {
        throw new Error('Probability sum must be greater than zero.');
    }
    var scaledProbabilities = p.map(function(prob) {
        return prob * n / sum;
    });
    var aliasData = {
        prob: new Array(n),
        alias: new Array(n)
    };
    var small = [];
    var large = [];
    for(var i = n - 1; i >= 0; i--){
        if (scaledProbabilities[i] < 1) {
            small.push(i);
        } else {
            large.push(i);
        }
    }
    while(small.length > 0 && large.length > 0){
        var less = small.pop();
        var more = large.pop();
        aliasData.prob[less] = scaledProbabilities[less];
        aliasData.alias[less] = more;
        scaledProbabilities[more] = scaledProbabilities[more] + scaledProbabilities[less] - 1;
        if (scaledProbabilities[more] < 1) {
            small.push(more);
        } else {
            large.push(more);
        }
    }
    while(large.length > 0){
        aliasData.prob[large.pop()] = 1;
    }
    while(small.length > 0){
        aliasData.prob[small.pop()] = 1;
    }
    return aliasData;
};
var draw = function(aliasData, outcomes, rng) {
    var c = Math.floor(rng() * aliasData.prob.length);
    return outcomes[rng() < aliasData.prob[c] ? c : aliasData.alias[c]];
};
var next = function(aliasData, outcomes, rng, numOfSamples) {
    if (numOfSamples === void 0) {
        numOfSamples = 1;
    }
    if (numOfSamples === 1) {
        return draw(aliasData, outcomes, rng);
    }
    var samples = [];
    for(var i = 0; i < numOfSamples; i++){
        samples.push(draw(aliasData, outcomes, rng));
    }
    return samples;
};
var sample = function(probabilities, outcomes, rng) {
    if (rng === void 0) {
        rng = Math.random;
    }
    if (!Array.isArray(probabilities)) {
        throw new Error('Probabilities must be an array.');
    }
    if (probabilities.length === 0) {
        throw new Error('Probabilities array must not be empty.');
    }
    var n = probabilities.length;
    var indexedOutcomes = outcomes !== null && outcomes !== void 0 ? outcomes : Array.from({
        length: n
    }, function(_, i) {
        return i;
    });
    var aliasData = precomputeAlias(probabilities, n);
    return {
        next: function(numOfSamples) {
            if (numOfSamples === void 0) {
                numOfSamples = 1;
            }
            return next(aliasData, indexedOutcomes, rng, numOfSamples);
        }
    };
};
const __TURBOPACK__default__export__ = sample;
}}),
"[project]/node_modules/.pnpm/@keystonehq+bc-ur-registry-sol@0.9.5/node_modules/@keystonehq/bc-ur-registry-sol/dist/bc-ur-registry-sol.cjs.development.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var bcUrRegistry = __turbopack_context__.r("[project]/node_modules/.pnpm/@keystonehq+bc-ur-registry@0.7.0/node_modules/@keystonehq/bc-ur-registry/dist/index.js [app-ssr] (ecmascript)");
var uuid = __turbopack_context__.r("[project]/node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/index.js [app-ssr] (ecmascript)");
const ExtendedRegistryTypes = {
    SOL_SIGN_REQUEST: /*#__PURE__*/ new bcUrRegistry.RegistryType("sol-sign-request", 1101),
    SOL_SIGNATURE: /*#__PURE__*/ new bcUrRegistry.RegistryType("sol-signature", 1102),
    SOL_NFT_ITEM: /*#__PURE__*/ new bcUrRegistry.RegistryType("sol-nft-item", 1104)
};
const { decodeToDataItem, RegistryTypes } = bcUrRegistry.extend;
(function(SignType) {
    SignType[SignType["Transaction"] = 1] = "Transaction";
    SignType[SignType["Message"] = 2] = "Message";
})(exports.SignType || (exports.SignType = {}));
var Keys;
(function(Keys) {
    Keys[Keys["requestId"] = 1] = "requestId";
    Keys[Keys["signData"] = 2] = "signData";
    Keys[Keys["derivationPath"] = 3] = "derivationPath";
    Keys[Keys["address"] = 4] = "address";
    Keys[Keys["origin"] = 5] = "origin";
    Keys[Keys["signType"] = 6] = "signType";
})(Keys || (Keys = {}));
class SolSignRequest extends bcUrRegistry.RegistryItem {
    constructor(args){
        super();
        this.getRegistryType = ()=>ExtendedRegistryTypes.SOL_SIGN_REQUEST;
        this.getRequestId = ()=>this.requestId;
        this.getSignData = ()=>this.signData;
        this.getDerivationPath = ()=>this.derivationPath.getPath();
        this.getSignRequestAddress = ()=>this.address;
        this.getOrigin = ()=>this.origin;
        this.getSignType = ()=>this.signType;
        this.toDataItem = ()=>{
            const map = {};
            if (this.requestId) {
                map[Keys.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes.UUID.getTag());
            }
            if (this.address) {
                map[Keys.address] = this.address;
            }
            if (this.origin) {
                map[Keys.origin] = this.origin;
            }
            map[Keys.signData] = this.signData;
            map[Keys.signType] = this.signType;
            const keyPath = this.derivationPath.toDataItem();
            keyPath.setTag(this.derivationPath.getRegistryType().getTag());
            map[Keys.derivationPath] = keyPath;
            return new bcUrRegistry.DataItem(map);
        };
        this.requestId = args.requestId;
        this.signData = args.signData;
        this.derivationPath = args.derivationPath;
        this.address = args.address;
        this.origin = args.origin;
        this.signType = args.signType;
    }
    static constructSOLRequest(signData, hdPath, xfp, signType, uuidString, address, origin) {
        const paths = hdPath.replace(/[m|M]\//, "").split("/");
        const hdpathObject = new bcUrRegistry.CryptoKeypath(paths.map((path)=>{
            const index = parseInt(path.replace("'", ""));
            let isHardened = false;
            if (path.endsWith("'")) {
                isHardened = true;
            }
            return new bcUrRegistry.PathComponent({
                index,
                hardened: isHardened
            });
        }), Buffer.from(xfp, "hex"));
        return new SolSignRequest({
            requestId: uuidString ? Buffer.from(uuid.parse(uuidString)) : undefined,
            signData,
            derivationPath: hdpathObject,
            address: address ? Buffer.from(address.replace("0x", ""), "hex") : undefined,
            origin: origin || undefined,
            signType
        });
    }
}
SolSignRequest.fromDataItem = (dataItem)=>{
    const map = dataItem.getData();
    const signData = map[Keys.signData];
    const derivationPath = bcUrRegistry.CryptoKeypath.fromDataItem(map[Keys.derivationPath]);
    const address = map[Keys.address] ? map[Keys.address] : undefined;
    const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;
    const origin = map[Keys.origin] ? map[Keys.origin] : undefined;
    const signType = map[Keys.signType];
    return new SolSignRequest({
        requestId,
        signData,
        derivationPath,
        address,
        origin,
        signType
    });
};
SolSignRequest.fromCBOR = (_cborPayload)=>{
    const dataItem = decodeToDataItem(_cborPayload);
    return SolSignRequest.fromDataItem(dataItem);
};
const { RegistryTypes: RegistryTypes$1, decodeToDataItem: decodeToDataItem$1 } = bcUrRegistry.extend;
var Keys$1;
(function(Keys) {
    Keys[Keys["requestId"] = 1] = "requestId";
    Keys[Keys["signature"] = 2] = "signature";
})(Keys$1 || (Keys$1 = {}));
class SolSignature extends bcUrRegistry.RegistryItem {
    constructor(signature, requestId){
        super();
        this.getRegistryType = ()=>ExtendedRegistryTypes.SOL_SIGNATURE;
        this.getRequestId = ()=>this.requestId;
        this.getSignature = ()=>this.signature;
        this.toDataItem = ()=>{
            const map = {};
            if (this.requestId) {
                map[Keys$1.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes$1.UUID.getTag());
            }
            map[Keys$1.signature] = this.signature;
            return new bcUrRegistry.DataItem(map);
        };
        this.signature = signature;
        this.requestId = requestId;
    }
}
SolSignature.fromDataItem = (dataItem)=>{
    const map = dataItem.getData();
    const signature = map[Keys$1.signature];
    const requestId = map[Keys$1.requestId] ? map[Keys$1.requestId].getData() : undefined;
    return new SolSignature(signature, requestId);
};
SolSignature.fromCBOR = (_cborPayload)=>{
    const dataItem = decodeToDataItem$1(_cborPayload);
    return SolSignature.fromDataItem(dataItem);
};
const { decodeToDataItem: decodeToDataItem$2 } = bcUrRegistry.extend;
var Keys$2;
(function(Keys) {
    Keys[Keys["mintAddress"] = 1] = "mintAddress";
    Keys[Keys["collectionName"] = 2] = "collectionName";
    Keys[Keys["name"] = 3] = "name";
    Keys[Keys["mediaData"] = 4] = "mediaData";
})(Keys$2 || (Keys$2 = {}));
class SOLNFTItem extends bcUrRegistry.RegistryItem {
    constructor(args){
        super();
        this.getRegistryType = ()=>ExtendedRegistryTypes.SOL_NFT_ITEM;
        this.getName = ()=>this.name;
        this.getMediaData = ()=>this.mediaData;
        this.getMintAddress = ()=>this.mintAddress;
        this.getCollectionName = ()=>this.collectionName;
        this.toDataItem = ()=>{
            const map = {};
            map[Keys$2.name] = this.name;
            map[Keys$2.mintAddress] = this.mintAddress;
            map[Keys$2.collectionName] = this.collectionName;
            map[Keys$2.mediaData] = this.mediaData;
            return new bcUrRegistry.DataItem(map);
        };
        this.name = args.name;
        this.mintAddress = args.mintAddress;
        this.collectionName = args.collectionName;
        this.mediaData = args.mediaData; // remove the data perfix for android usage
    }
    static constructETHNFTItem(mintAddress, collectionName, name, mediaData) {
        return new SOLNFTItem({
            mintAddress,
            collectionName,
            mediaData,
            name
        });
    }
}
SOLNFTItem.fromDataItem = (dataItem)=>{
    const map = dataItem.getData();
    const name = map[Keys$2.name];
    const mediaData = map[Keys$2.mediaData];
    const mintAddress = map[Keys$2.mintAddress];
    const collectionName = map[Keys$2.collectionName];
    return new SOLNFTItem({
        name,
        mintAddress,
        collectionName,
        mediaData
    });
};
SOLNFTItem.fromCBOR = (_cborPayload)=>{
    const dataItem = decodeToDataItem$2(_cborPayload);
    return SOLNFTItem.fromDataItem(dataItem);
};
bcUrRegistry.patchTags(Object.values(ExtendedRegistryTypes).filter((rt)=>!!rt.getTag()).map((rt)=>rt.getTag()));
Object.keys(bcUrRegistry).forEach(function(k) {
    if (k !== 'default') Object.defineProperty(exports, k, {
        enumerable: true,
        get: function() {
            return bcUrRegistry[k];
        }
    });
});
exports.SOLNFTItem = SOLNFTItem;
exports.SolSignRequest = SolSignRequest;
exports.SolSignature = SolSignature; //# sourceMappingURL=bc-ur-registry-sol.cjs.development.js.map
}}),
"[project]/node_modules/.pnpm/@keystonehq+bc-ur-registry-sol@0.9.5/node_modules/@keystonehq/bc-ur-registry-sol/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/@keystonehq+bc-ur-registry-sol@0.9.5/node_modules/@keystonehq/bc-ur-registry-sol/dist/bc-ur-registry-sol.cjs.development.js [app-ssr] (ecmascript)");
}
}}),
"[project]/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/cjs/react-is.development.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
if ("TURBOPACK compile-time truthy", 1) {
    (function() {
        'use strict';
        // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
        // nor polyfill, then a plain number is used for performance.
        var hasSymbol = typeof Symbol === 'function' && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
        // (unstable) APIs that have been removed. Can we remove the symbols?
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;
        function isValidElementType(type) {
            return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
            type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
            if (typeof object === 'object' && object !== null) {
                var $$typeof = object.$$typeof;
                switch($$typeof){
                    case REACT_ELEMENT_TYPE:
                        var type = object.type;
                        switch(type){
                            case REACT_ASYNC_MODE_TYPE:
                            case REACT_CONCURRENT_MODE_TYPE:
                            case REACT_FRAGMENT_TYPE:
                            case REACT_PROFILER_TYPE:
                            case REACT_STRICT_MODE_TYPE:
                            case REACT_SUSPENSE_TYPE:
                                return type;
                            default:
                                var $$typeofType = type && type.$$typeof;
                                switch($$typeofType){
                                    case REACT_CONTEXT_TYPE:
                                    case REACT_FORWARD_REF_TYPE:
                                    case REACT_LAZY_TYPE:
                                    case REACT_MEMO_TYPE:
                                    case REACT_PROVIDER_TYPE:
                                        return $$typeofType;
                                    default:
                                        return $$typeof;
                                }
                        }
                    case REACT_PORTAL_TYPE:
                        return $$typeof;
                }
            }
            return undefined;
        } // AsyncMode is deprecated along with isAsyncMode
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated
        function isAsyncMode(object) {
            {
                if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                    hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint
                    console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
                }
            }
            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
    })();
}
}}),
"[project]/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/cjs/react-is.development.js [app-ssr] (ecmascript)");
}
}}),
"[project]/node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/ 'use strict';
/* eslint-disable no-unused-vars */ var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
    if (val === null || val === undefined) {
        throw new TypeError('Object.assign cannot be called with null or undefined');
    }
    return Object(val);
}
function shouldUseNative() {
    try {
        if ("TURBOPACK compile-time falsy", 0) {
            "TURBOPACK unreachable";
        }
        // Detect buggy property enumeration order in older V8 versions.
        // https://bugs.chromium.org/p/v8/issues/detail?id=4118
        var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
        test1[5] = 'de';
        if (Object.getOwnPropertyNames(test1)[0] === '5') {
            return false;
        }
        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test2 = {};
        for(var i = 0; i < 10; i++){
            test2['_' + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
        });
        if (order2.join('') !== '0123456789') {
            return false;
        }
        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test3 = {};
        'abcdefghijklmnopqrst'.split('').forEach(function(letter) {
            test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
            return false;
        }
        return true;
    } catch (err) {
        // We don't expect any of the above to throw, but better to be safe.
        return false;
    }
}
module.exports = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for(var s = 1; s < arguments.length; s++){
        from = Object(arguments[s]);
        for(var key in from){
            if (hasOwnProperty.call(from, key)) {
                to[key] = from[key];
            }
        }
        if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for(var i = 0; i < symbols.length; i++){
                if (propIsEnumerable.call(from, symbols[i])) {
                    to[symbols[i]] = from[symbols[i]];
                }
            }
        }
    }
    return to;
};
}}),
"[project]/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/ReactPropTypesSecret.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
module.exports = ReactPropTypesSecret;
}}),
"[project]/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/has.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
}}),
"[project]/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/checkPropTypes.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
var printWarning = function() {};
if ("TURBOPACK compile-time truthy", 1) {
    var ReactPropTypesSecret = __turbopack_context__.r("[project]/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/ReactPropTypesSecret.js [app-ssr] (ecmascript)");
    var loggedTypeFailures = {};
    var has = __turbopack_context__.r("[project]/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/has.js [app-ssr] (ecmascript)");
    printWarning = function(text) {
        var message = 'Warning: ' + text;
        if (typeof console !== 'undefined') {
            console.error(message);
        }
        try {
            // --- Welcome to debugging React ---
            // This error was thrown as a convenience so that you can use this stack
            // to find the callsite that caused this warning to fire.
            throw new Error(message);
        } catch (x) {}
    };
}
/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */ function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
    if ("TURBOPACK compile-time truthy", 1) {
        for(var typeSpecName in typeSpecs){
            if (has(typeSpecs, typeSpecName)) {
                var error;
                // Prop type validation may throw. In case they do, we don't want to
                // fail the render phase where it didn't fail before. So we log it.
                // After these have been cleaned up, we'll let them throw.
                try {
                    // This is intentionally an invariant that gets caught. It's the same
                    // behavior as without this statement except with a better message.
                    if (typeof typeSpecs[typeSpecName] !== 'function') {
                        var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                        err.name = 'Invariant Violation';
                        throw err;
                    }
                    error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
                } catch (ex) {
                    error = ex;
                }
                if (error && !(error instanceof Error)) {
                    printWarning((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
                }
                if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                    // Only monitor this failure once because there tends to be a lot of the
                    // same error.
                    loggedTypeFailures[error.message] = true;
                    var stack = getStack ? getStack() : '';
                    printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
                }
            }
        }
    }
}
/**
 * Resets warning cache when testing.
 *
 * @private
 */ checkPropTypes.resetWarningCache = function() {
    if (("TURBOPACK compile-time value", "development") !== 'production') {
        loggedTypeFailures = {};
    }
};
module.exports = checkPropTypes;
}}),
"[project]/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/factoryWithTypeCheckers.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
var ReactIs = __turbopack_context__.r("[project]/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/index.js [app-ssr] (ecmascript)");
var assign = __turbopack_context__.r("[project]/node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js [app-ssr] (ecmascript)");
var ReactPropTypesSecret = __turbopack_context__.r("[project]/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/ReactPropTypesSecret.js [app-ssr] (ecmascript)");
var has = __turbopack_context__.r("[project]/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/has.js [app-ssr] (ecmascript)");
var checkPropTypes = __turbopack_context__.r("[project]/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/checkPropTypes.js [app-ssr] (ecmascript)");
var printWarning = function() {};
if ("TURBOPACK compile-time truthy", 1) {
    printWarning = function(text) {
        var message = 'Warning: ' + text;
        if (typeof console !== 'undefined') {
            console.error(message);
        }
        try {
            // --- Welcome to debugging React ---
            // This error was thrown as a convenience so that you can use this stack
            // to find the callsite that caused this warning to fire.
            throw new Error(message);
        } catch (x) {}
    };
}
function emptyFunctionThatReturnsNull() {
    return null;
}
module.exports = function(isValidElement, throwOnDirectAccess) {
    /* global Symbol */ var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
    /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */ function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === 'function') {
            return iteratorFn;
        }
    }
    /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */ var ANONYMOUS = '<<anonymous>>';
    // Important!
    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
    var ReactPropTypes = {
        array: createPrimitiveTypeChecker('array'),
        bigint: createPrimitiveTypeChecker('bigint'),
        bool: createPrimitiveTypeChecker('boolean'),
        func: createPrimitiveTypeChecker('function'),
        number: createPrimitiveTypeChecker('number'),
        object: createPrimitiveTypeChecker('object'),
        string: createPrimitiveTypeChecker('string'),
        symbol: createPrimitiveTypeChecker('symbol'),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
    };
    /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */ /*eslint-disable no-self-compare*/ function is(x, y) {
        // SameValue algorithm
        if (x === y) {
            // Steps 1-5, 7-10
            // Steps 6.b-6.e: +0 != -0
            return x !== 0 || 1 / x === 1 / y;
        } else {
            // Step 6.a: NaN == NaN
            return x !== x && y !== y;
        }
    }
    /*eslint-enable no-self-compare*/ /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */ function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === 'object' ? data : {};
        this.stack = '';
    }
    // Make `instanceof Error` still work for returned errors.
    PropTypeError.prototype = Error.prototype;
    function createChainableTypeChecker(validate) {
        if (("TURBOPACK compile-time value", "development") !== 'production') {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret) {
                if (throwOnDirectAccess) {
                    // New behavior only for users of `prop-types` package
                    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
                    err.name = 'Invariant Violation';
                    throw err;
                } else if (("TURBOPACK compile-time value", "development") !== 'production' && typeof console !== 'undefined') {
                    // Old behavior for people using React.PropTypes
                    var cacheKey = componentName + ':' + propName;
                    if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                    manualPropTypeWarningCount < 3) {
                        printWarning('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
                        manualPropTypeCallCache[cacheKey] = true;
                        manualPropTypeWarningCount++;
                    }
                }
            }
            if (props[propName] == null) {
                if (isRequired) {
                    if (props[propName] === null) {
                        return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
                    }
                    return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
                }
                return null;
            } else {
                return validate(props, propName, componentName, location, propFullName);
            }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
    }
    function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
                // `propValue` being instance of, say, date/regexp, pass the 'object'
                // check, but we can offer a more precise error message here rather than
                // 'of type `object`'.
                var preciseType = getPreciseType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'), {
                    expectedType: expectedType
                });
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }
    function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== 'function') {
                return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
            }
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
            }
            for(var i = 0; i < propValue.length; i++){
                var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
                if (error instanceof Error) {
                    return error;
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!isValidElement(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!ReactIs.isValidElementType(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
                var expectedClassName = expectedClass.name || ANONYMOUS;
                var actualClassName = getClassName(props[propName]);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
            if ("TURBOPACK compile-time truthy", 1) {
                if (arguments.length > 1) {
                    printWarning('Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' + 'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).');
                } else {
                    printWarning('Invalid argument supplied to oneOf, expected an array.');
                }
            }
            return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            for(var i = 0; i < expectedValues.length; i++){
                if (is(propValue, expectedValues[i])) {
                    return null;
                }
            }
            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
                var type = getPreciseType(value);
                if (type === 'symbol') {
                    return String(value);
                }
                return value;
            });
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
        }
        return createChainableTypeChecker(validate);
    }
    function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== 'function') {
                return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
            }
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== 'object') {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
            }
            for(var key in propValue){
                if (has(propValue, key)) {
                    var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                    if (error instanceof Error) {
                        return error;
                    }
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
            ("TURBOPACK compile-time truthy", 1) ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : ("TURBOPACK unreachable", undefined);
            return emptyFunctionThatReturnsNull;
        }
        for(var i = 0; i < arrayOfTypeCheckers.length; i++){
            var checker = arrayOfTypeCheckers[i];
            if (typeof checker !== 'function') {
                printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
                return emptyFunctionThatReturnsNull;
            }
        }
        function validate(props, propName, componentName, location, propFullName) {
            var expectedTypes = [];
            for(var i = 0; i < arrayOfTypeCheckers.length; i++){
                var checker = arrayOfTypeCheckers[i];
                var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
                if (checkerResult == null) {
                    return null;
                }
                if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
                    expectedTypes.push(checkerResult.data.expectedType);
                }
            }
            var expectedTypesMessage = expectedTypes.length > 0 ? ', expected one of type [' + expectedTypes.join(', ') + ']' : '';
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
        }
        return createChainableTypeChecker(validate);
    }
    function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            if (!isNode(props[propName])) {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError((componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + type + '`.');
    }
    function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== 'object') {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
            }
            for(var key in shapeTypes){
                var checker = shapeTypes[key];
                if (typeof checker !== 'function') {
                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
                }
                var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                if (error) {
                    return error;
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== 'object') {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
            }
            // We need to check all keys in case some are required but missing from props.
            var allKeys = assign({}, props[propName], shapeTypes);
            for(var key in allKeys){
                var checker = shapeTypes[key];
                if (has(shapeTypes, key) && typeof checker !== 'function') {
                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
                }
                if (!checker) {
                    return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
                }
                var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                if (error) {
                    return error;
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function isNode(propValue) {
        switch(typeof propValue){
            case 'number':
            case 'string':
            case 'undefined':
                return true;
            case 'boolean':
                return !propValue;
            case 'object':
                if (Array.isArray(propValue)) {
                    return propValue.every(isNode);
                }
                if (propValue === null || isValidElement(propValue)) {
                    return true;
                }
                var iteratorFn = getIteratorFn(propValue);
                if (iteratorFn) {
                    var iterator = iteratorFn.call(propValue);
                    var step;
                    if (iteratorFn !== propValue.entries) {
                        while(!(step = iterator.next()).done){
                            if (!isNode(step.value)) {
                                return false;
                            }
                        }
                    } else {
                        // Iterator will provide entry [k,v] tuples rather than values.
                        while(!(step = iterator.next()).done){
                            var entry = step.value;
                            if (entry) {
                                if (!isNode(entry[1])) {
                                    return false;
                                }
                            }
                        }
                    }
                } else {
                    return false;
                }
                return true;
            default:
                return false;
        }
    }
    function isSymbol(propType, propValue) {
        // Native Symbol.
        if (propType === 'symbol') {
            return true;
        }
        // falsy value can't be a Symbol
        if (!propValue) {
            return false;
        }
        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
        if (propValue['@@toStringTag'] === 'Symbol') {
            return true;
        }
        // Fallback for non-spec compliant Symbols which are polyfilled.
        if (typeof Symbol === 'function' && propValue instanceof Symbol) {
            return true;
        }
        return false;
    }
    // Equivalent of `typeof` but with special handling for array and regexp.
    function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
            return 'array';
        }
        if (propValue instanceof RegExp) {
            // Old webkits (at least until Android 4.0) return 'function' rather than
            // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
            // passes PropTypes.object.
            return 'object';
        }
        if (isSymbol(propType, propValue)) {
            return 'symbol';
        }
        return propType;
    }
    // This handles more types than `getPropType`. Only used for error messages.
    // See `createPrimitiveTypeChecker`.
    function getPreciseType(propValue) {
        if (typeof propValue === 'undefined' || propValue === null) {
            return '' + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === 'object') {
            if (propValue instanceof Date) {
                return 'date';
            } else if (propValue instanceof RegExp) {
                return 'regexp';
            }
        }
        return propType;
    }
    // Returns a string that is postfixed to a warning about an invalid type.
    // For example, "undefined" or "of type array"
    function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch(type){
            case 'array':
            case 'object':
                return 'an ' + type;
            case 'boolean':
            case 'date':
            case 'regexp':
                return 'a ' + type;
            default:
                return type;
        }
    }
    // Returns class name of the object, if any.
    function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
        }
        return propValue.constructor.name;
    }
    ReactPropTypes.checkPropTypes = checkPropTypes;
    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
};
}}),
"[project]/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ if ("TURBOPACK compile-time truthy", 1) {
    var ReactIs = __turbopack_context__.r("[project]/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/index.js [app-ssr] (ecmascript)");
    // By explicitly using `prop-types` you are opting into new development behavior.
    // http://fb.me/prop-types-in-prod
    var throwOnDirectAccess = true;
    module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/factoryWithTypeCheckers.js [app-ssr] (ecmascript)")(ReactIs.isElement, throwOnDirectAccess);
} else {
    "TURBOPACK unreachable";
}
}}),
"[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/tabbable.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = findTabbableDescendants;
/*!
 * Adapted from jQuery UI core
 *
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */ var DISPLAY_NONE = "none";
var DISPLAY_CONTENTS = "contents";
// match the whole word to prevent fuzzy searching
var tabbableNode = /^(input|select|textarea|button|object|iframe)$/;
function isNotOverflowing(element, style) {
    return style.getPropertyValue("overflow") !== "visible" || // if 'overflow: visible' set, check if there is actually any overflow
    element.scrollWidth <= 0 && element.scrollHeight <= 0;
}
function hidesContents(element) {
    var zeroSize = element.offsetWidth <= 0 && element.offsetHeight <= 0;
    // If the node is empty, this is good enough
    if (zeroSize && !element.innerHTML) return true;
    try {
        // Otherwise we need to check some styles
        var style = window.getComputedStyle(element);
        var displayValue = style.getPropertyValue("display");
        return zeroSize ? displayValue !== DISPLAY_CONTENTS && isNotOverflowing(element, style) : displayValue === DISPLAY_NONE;
    } catch (exception) {
        // eslint-disable-next-line no-console
        console.warn("Failed to inspect element style");
        return false;
    }
}
function visible(element) {
    var parentElement = element;
    var rootNode = element.getRootNode && element.getRootNode();
    while(parentElement){
        if (parentElement === document.body) break;
        // if we are not hidden yet, skip to checking outside the Web Component
        if (rootNode && parentElement === rootNode) parentElement = rootNode.host.parentNode;
        if (hidesContents(parentElement)) return false;
        parentElement = parentElement.parentNode;
    }
    return true;
}
function focusable(element, isTabIndexNotNaN) {
    var nodeName = element.nodeName.toLowerCase();
    var res = tabbableNode.test(nodeName) && !element.disabled || (nodeName === "a" ? element.href || isTabIndexNotNaN : isTabIndexNotNaN);
    return res && visible(element);
}
function tabbable(element) {
    var tabIndex = element.getAttribute("tabindex");
    if (tabIndex === null) tabIndex = undefined;
    var isTabIndexNaN = isNaN(tabIndex);
    return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
}
function findTabbableDescendants(element) {
    var descendants = [].slice.call(element.querySelectorAll("*"), 0).reduce(function(finished, el) {
        return finished.concat(!el.shadowRoot ? [
            el
        ] : findTabbableDescendants(el.shadowRoot));
    }, []);
    return descendants.filter(tabbable);
}
module.exports = exports["default"];
}}),
"[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/focusManager.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.resetState = resetState;
exports.log = log;
exports.handleBlur = handleBlur;
exports.handleFocus = handleFocus;
exports.markForFocusLater = markForFocusLater;
exports.returnFocus = returnFocus;
exports.popWithoutFocus = popWithoutFocus;
exports.setupScopedFocus = setupScopedFocus;
exports.teardownScopedFocus = teardownScopedFocus;
var _tabbable = __turbopack_context__.r("[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/tabbable.js [app-ssr] (ecmascript)");
var _tabbable2 = _interopRequireDefault(_tabbable);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var focusLaterElements = [];
var modalElement = null;
var needToFocus = false;
/* eslint-disable no-console */ /* istanbul ignore next */ function resetState() {
    focusLaterElements = [];
}
/* istanbul ignore next */ function log() {
    if ("TURBOPACK compile-time truthy", 1) {
        console.log("focusManager ----------");
        focusLaterElements.forEach(function(f) {
            var check = f || {};
            console.log(check.nodeName, check.className, check.id);
        });
        console.log("end focusManager ----------");
    }
}
/* eslint-enable no-console */ function handleBlur() {
    needToFocus = true;
}
function handleFocus() {
    if (needToFocus) {
        needToFocus = false;
        if (!modalElement) {
            return;
        }
        // need to see how jQuery shims document.on('focusin') so we don't need the
        // setTimeout, firefox doesn't support focusin, if it did, we could focus
        // the element outside of a setTimeout. Side-effect of this implementation
        // is that the document.body gets focus, and then we focus our element right
        // after, seems fine.
        setTimeout(function() {
            if (modalElement.contains(document.activeElement)) {
                return;
            }
            var el = (0, _tabbable2.default)(modalElement)[0] || modalElement;
            el.focus();
        }, 0);
    }
}
function markForFocusLater() {
    focusLaterElements.push(document.activeElement);
}
/* eslint-disable no-console */ function returnFocus() {
    var preventScroll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var toFocus = null;
    try {
        if (focusLaterElements.length !== 0) {
            toFocus = focusLaterElements.pop();
            toFocus.focus({
                preventScroll: preventScroll
            });
        }
        return;
    } catch (e) {
        console.warn([
            "You tried to return focus to",
            toFocus,
            "but it is not in the DOM anymore"
        ].join(" "));
    }
}
/* eslint-enable no-console */ function popWithoutFocus() {
    focusLaterElements.length > 0 && focusLaterElements.pop();
}
function setupScopedFocus(element) {
    modalElement = element;
    if (window.addEventListener) {
        window.addEventListener("blur", handleBlur, false);
        document.addEventListener("focus", handleFocus, true);
    } else {
        window.attachEvent("onBlur", handleBlur);
        document.attachEvent("onFocus", handleFocus);
    }
}
function teardownScopedFocus() {
    modalElement = null;
    if (window.addEventListener) {
        window.removeEventListener("blur", handleBlur);
        document.removeEventListener("focus", handleFocus);
    } else {
        window.detachEvent("onBlur", handleBlur);
        document.detachEvent("onFocus", handleFocus);
    }
}
}}),
"[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/scopeTab.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = scopeTab;
var _tabbable = __turbopack_context__.r("[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/tabbable.js [app-ssr] (ecmascript)");
var _tabbable2 = _interopRequireDefault(_tabbable);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function getActiveElement() {
    var el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
    return el.activeElement.shadowRoot ? getActiveElement(el.activeElement.shadowRoot) : el.activeElement;
}
function scopeTab(node, event) {
    var tabbable = (0, _tabbable2.default)(node);
    if (!tabbable.length) {
        // Do nothing, since there are no elements that can receive focus.
        event.preventDefault();
        return;
    }
    var target = void 0;
    var shiftKey = event.shiftKey;
    var head = tabbable[0];
    var tail = tabbable[tabbable.length - 1];
    var activeElement = getActiveElement();
    // proceed with default browser behavior on tab.
    // Focus on last element on shift + tab.
    if (node === activeElement) {
        if (!shiftKey) return;
        target = tail;
    }
    if (tail === activeElement && !shiftKey) {
        target = head;
    }
    if (head === activeElement && shiftKey) {
        target = tail;
    }
    if (target) {
        event.preventDefault();
        target.focus();
        return;
    }
    // Safari radio issue.
    //
    // Safari does not move the focus to the radio button,
    // so we need to force it to really walk through all elements.
    //
    // This is very error prone, since we are trying to guess
    // if it is a safari browser from the first occurence between
    // chrome or safari.
    //
    // The chrome user agent contains the first ocurrence
    // as the 'chrome/version' and later the 'safari/version'.
    var checkSafari = /(\bChrome\b|\bSafari\b)\//.exec(navigator.userAgent);
    var isSafariDesktop = checkSafari != null && checkSafari[1] != "Chrome" && /\biPod\b|\biPad\b/g.exec(navigator.userAgent) == null;
    // If we are not in safari desktop, let the browser control
    // the focus
    if (!isSafariDesktop) return;
    var x = tabbable.indexOf(activeElement);
    if (x > -1) {
        x += shiftKey ? -1 : 1;
    }
    target = tabbable[x];
    // If the tabbable element does not exist,
    // focus head/tail based on shiftKey
    if (typeof target === "undefined") {
        event.preventDefault();
        target = shiftKey ? tail : head;
        target.focus();
        return;
    }
    event.preventDefault();
    target.focus();
}
module.exports = exports["default"];
}}),
"[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/safeHTMLElement.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.canUseDOM = exports.SafeNodeList = exports.SafeHTMLCollection = undefined;
var _exenv = __turbopack_context__.r("[project]/node_modules/.pnpm/exenv@1.2.2/node_modules/exenv/index.js [app-ssr] (ecmascript)");
var _exenv2 = _interopRequireDefault(_exenv);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var EE = _exenv2.default;
var SafeHTMLElement = EE.canUseDOM ? window.HTMLElement : {};
var SafeHTMLCollection = exports.SafeHTMLCollection = EE.canUseDOM ? window.HTMLCollection : {};
var SafeNodeList = exports.SafeNodeList = EE.canUseDOM ? window.NodeList : {};
var canUseDOM = exports.canUseDOM = EE.canUseDOM;
exports.default = SafeHTMLElement;
}}),
"[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/ariaAppHider.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.resetState = resetState;
exports.log = log;
exports.assertNodeList = assertNodeList;
exports.setElement = setElement;
exports.validateElement = validateElement;
exports.hide = hide;
exports.show = show;
exports.documentNotReadyOrSSRTesting = documentNotReadyOrSSRTesting;
var _warning = __turbopack_context__.r("[project]/node_modules/.pnpm/warning@4.0.3/node_modules/warning/warning.js [app-ssr] (ecmascript)");
var _warning2 = _interopRequireDefault(_warning);
var _safeHTMLElement = __turbopack_context__.r("[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/safeHTMLElement.js [app-ssr] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var globalElement = null;
/* eslint-disable no-console */ /* istanbul ignore next */ function resetState() {
    if (globalElement) {
        if (globalElement.removeAttribute) {
            globalElement.removeAttribute("aria-hidden");
        } else if (globalElement.length != null) {
            globalElement.forEach(function(element) {
                return element.removeAttribute("aria-hidden");
            });
        } else {
            document.querySelectorAll(globalElement).forEach(function(element) {
                return element.removeAttribute("aria-hidden");
            });
        }
    }
    globalElement = null;
}
/* istanbul ignore next */ function log() {
    if ("TURBOPACK compile-time truthy", 1) {
        var check = globalElement || {};
        console.log("ariaAppHider ----------");
        console.log(check.nodeName, check.className, check.id);
        console.log("end ariaAppHider ----------");
    }
}
/* eslint-enable no-console */ function assertNodeList(nodeList, selector) {
    if (!nodeList || !nodeList.length) {
        throw new Error("react-modal: No elements were found for selector " + selector + ".");
    }
}
function setElement(element) {
    var useElement = element;
    if (typeof useElement === "string" && _safeHTMLElement.canUseDOM) {
        var el = document.querySelectorAll(useElement);
        assertNodeList(el, useElement);
        useElement = el;
    }
    globalElement = useElement || globalElement;
    return globalElement;
}
function validateElement(appElement) {
    var el = appElement || globalElement;
    if (el) {
        return Array.isArray(el) || el instanceof HTMLCollection || el instanceof NodeList ? el : [
            el
        ];
    } else {
        (0, _warning2.default)(false, [
            "react-modal: App element is not defined.",
            "Please use `Modal.setAppElement(el)` or set `appElement={el}`.",
            "This is needed so screen readers don't see main content",
            "when modal is opened. It is not recommended, but you can opt-out",
            "by setting `ariaHideApp={false}`."
        ].join(" "));
        return [];
    }
}
function hide(appElement) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;
    try {
        for(var _iterator = validateElement(appElement)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var el = _step.value;
            el.setAttribute("aria-hidden", "true");
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}
function show(appElement) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;
    try {
        for(var _iterator2 = validateElement(appElement)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
            var el = _step2.value;
            el.removeAttribute("aria-hidden");
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally{
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }
}
function documentNotReadyOrSSRTesting() {
    globalElement = null;
}
}}),
"[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/classList.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.resetState = resetState;
exports.log = log;
var htmlClassList = {};
var docBodyClassList = {};
/* eslint-disable no-console */ /* istanbul ignore next */ function removeClass(at, cls) {
    at.classList.remove(cls);
}
/* istanbul ignore next */ function resetState() {
    var htmlElement = document.getElementsByTagName("html")[0];
    for(var cls in htmlClassList){
        removeClass(htmlElement, htmlClassList[cls]);
    }
    var body = document.body;
    for(var _cls in docBodyClassList){
        removeClass(body, docBodyClassList[_cls]);
    }
    htmlClassList = {};
    docBodyClassList = {};
}
/* istanbul ignore next */ function log() {
    if ("TURBOPACK compile-time truthy", 1) {
        var classes = document.getElementsByTagName("html")[0].className;
        var buffer = "Show tracked classes:\n\n";
        buffer += "<html /> (" + classes + "):\n  ";
        for(var x in htmlClassList){
            buffer += "  " + x + " " + htmlClassList[x] + "\n  ";
        }
        classes = document.body.className;
        buffer += "\n\ndoc.body (" + classes + "):\n  ";
        for(var _x in docBodyClassList){
            buffer += "  " + _x + " " + docBodyClassList[_x] + "\n  ";
        }
        buffer += "\n";
        console.log(buffer);
    }
}
/* eslint-enable no-console */ /**
 * Track the number of reference of a class.
 * @param {object} poll The poll to receive the reference.
 * @param {string} className The class name.
 * @return {string}
 */ var incrementReference = function incrementReference(poll, className) {
    if (!poll[className]) {
        poll[className] = 0;
    }
    poll[className] += 1;
    return className;
};
/**
 * Drop the reference of a class.
 * @param {object} poll The poll to receive the reference.
 * @param {string} className The class name.
 * @return {string}
 */ var decrementReference = function decrementReference(poll, className) {
    if (poll[className]) {
        poll[className] -= 1;
    }
    return className;
};
/**
 * Track a class and add to the given class list.
 * @param {Object} classListRef A class list of an element.
 * @param {Object} poll         The poll to be used.
 * @param {Array}  classes      The list of classes to be tracked.
 */ var trackClass = function trackClass(classListRef, poll, classes) {
    classes.forEach(function(className) {
        incrementReference(poll, className);
        classListRef.add(className);
    });
};
/**
 * Untrack a class and remove from the given class list if the reference
 * reaches 0.
 * @param {Object} classListRef A class list of an element.
 * @param {Object} poll         The poll to be used.
 * @param {Array}  classes      The list of classes to be untracked.
 */ var untrackClass = function untrackClass(classListRef, poll, classes) {
    classes.forEach(function(className) {
        decrementReference(poll, className);
        poll[className] === 0 && classListRef.remove(className);
    });
};
/**
 * Public inferface to add classes to the document.body.
 * @param {string} bodyClass The class string to be added.
 *                           It may contain more then one class
 *                           with ' ' as separator.
 */ var add = exports.add = function add(element, classString) {
    return trackClass(element.classList, element.nodeName.toLowerCase() == "html" ? htmlClassList : docBodyClassList, classString.split(" "));
};
/**
 * Public inferface to remove classes from the document.body.
 * @param {string} bodyClass The class string to be added.
 *                           It may contain more then one class
 *                           with ' ' as separator.
 */ var remove = exports.remove = function remove(element, classString) {
    return untrackClass(element.classList, element.nodeName.toLowerCase() == "html" ? htmlClassList : docBodyClassList, classString.split(" "));
};
}}),
"[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/portalOpenInstances.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.log = log;
exports.resetState = resetState;
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
// Tracks portals that are open and emits events to subscribers
var PortalOpenInstances = function PortalOpenInstances() {
    var _this = this;
    _classCallCheck(this, PortalOpenInstances);
    this.register = function(openInstance) {
        if (_this.openInstances.indexOf(openInstance) !== -1) {
            if ("TURBOPACK compile-time truthy", 1) {
                // eslint-disable-next-line no-console
                console.warn("React-Modal: Cannot register modal instance that's already open");
            }
            return;
        }
        _this.openInstances.push(openInstance);
        _this.emit("register");
    };
    this.deregister = function(openInstance) {
        var index = _this.openInstances.indexOf(openInstance);
        if (index === -1) {
            if ("TURBOPACK compile-time truthy", 1) {
                // eslint-disable-next-line no-console
                console.warn("React-Modal: Unable to deregister " + openInstance + " as " + "it was never registered");
            }
            return;
        }
        _this.openInstances.splice(index, 1);
        _this.emit("deregister");
    };
    this.subscribe = function(callback) {
        _this.subscribers.push(callback);
    };
    this.emit = function(eventType) {
        _this.subscribers.forEach(function(subscriber) {
            return subscriber(eventType, // shallow copy to avoid accidental mutation
            _this.openInstances.slice());
        });
    };
    this.openInstances = [];
    this.subscribers = [];
};
var portalOpenInstances = new PortalOpenInstances();
/* eslint-disable no-console */ /* istanbul ignore next */ function log() {
    console.log("portalOpenInstances ----------");
    console.log(portalOpenInstances.openInstances.length);
    portalOpenInstances.openInstances.forEach(function(p) {
        return console.log(p);
    });
    console.log("end portalOpenInstances ----------");
}
/* istanbul ignore next */ function resetState() {
    portalOpenInstances = new PortalOpenInstances();
}
/* eslint-enable no-console */ exports.default = portalOpenInstances;
}}),
"[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/bodyTrap.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.resetState = resetState;
exports.log = log;
var _portalOpenInstances = __turbopack_context__.r("[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/portalOpenInstances.js [app-ssr] (ecmascript)");
var _portalOpenInstances2 = _interopRequireDefault(_portalOpenInstances);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Body focus trap see Issue #742
var before = void 0, after = void 0, instances = [];
/* eslint-disable no-console */ /* istanbul ignore next */ function resetState() {
    var _arr = [
        before,
        after
    ];
    for(var _i = 0; _i < _arr.length; _i++){
        var item = _arr[_i];
        if (!item) continue;
        item.parentNode && item.parentNode.removeChild(item);
    }
    before = after = null;
    instances = [];
}
/* istanbul ignore next */ function log() {
    console.log("bodyTrap ----------");
    console.log(instances.length);
    var _arr2 = [
        before,
        after
    ];
    for(var _i2 = 0; _i2 < _arr2.length; _i2++){
        var item = _arr2[_i2];
        var check = item || {};
        console.log(check.nodeName, check.className, check.id);
    }
    console.log("edn bodyTrap ----------");
}
/* eslint-enable no-console */ function focusContent() {
    if (instances.length === 0) {
        if ("TURBOPACK compile-time truthy", 1) {
            // eslint-disable-next-line no-console
            console.warn("React-Modal: Open instances > 0 expected");
        }
        return;
    }
    instances[instances.length - 1].focusContent();
}
function bodyTrap(eventType, openInstances) {
    if (!before && !after) {
        before = document.createElement("div");
        before.setAttribute("data-react-modal-body-trap", "");
        before.style.position = "absolute";
        before.style.opacity = "0";
        before.setAttribute("tabindex", "0");
        before.addEventListener("focus", focusContent);
        after = before.cloneNode();
        after.addEventListener("focus", focusContent);
    }
    instances = openInstances;
    if (instances.length > 0) {
        // Add focus trap
        if (document.body.firstChild !== before) {
            document.body.insertBefore(before, document.body.firstChild);
        }
        if (document.body.lastChild !== after) {
            document.body.appendChild(after);
        }
    } else {
        // Remove focus trap
        if (before.parentElement) {
            before.parentElement.removeChild(before);
        }
        if (after.parentElement) {
            after.parentElement.removeChild(after);
        }
    }
}
_portalOpenInstances2.default.subscribe(bodyTrap);
}}),
"[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/components/ModalPortal.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _extends = Object.assign || function(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i];
        for(var key in source){
            if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }
    return target;
};
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
} : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var _createClass = function() {
    function defineProperties(target, props) {
        for(var i = 0; i < props.length; i++){
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();
var _react = __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.2.3_@babel+core@7.26.10_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var _propTypes = __turbopack_context__.r("[project]/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js [app-ssr] (ecmascript)");
var _propTypes2 = _interopRequireDefault(_propTypes);
var _focusManager = __turbopack_context__.r("[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/focusManager.js [app-ssr] (ecmascript)");
var focusManager = _interopRequireWildcard(_focusManager);
var _scopeTab = __turbopack_context__.r("[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/scopeTab.js [app-ssr] (ecmascript)");
var _scopeTab2 = _interopRequireDefault(_scopeTab);
var _ariaAppHider = __turbopack_context__.r("[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/ariaAppHider.js [app-ssr] (ecmascript)");
var ariaAppHider = _interopRequireWildcard(_ariaAppHider);
var _classList = __turbopack_context__.r("[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/classList.js [app-ssr] (ecmascript)");
var classList = _interopRequireWildcard(_classList);
var _safeHTMLElement = __turbopack_context__.r("[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/safeHTMLElement.js [app-ssr] (ecmascript)");
var _safeHTMLElement2 = _interopRequireDefault(_safeHTMLElement);
var _portalOpenInstances = __turbopack_context__.r("[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/portalOpenInstances.js [app-ssr] (ecmascript)");
var _portalOpenInstances2 = _interopRequireDefault(_portalOpenInstances);
__turbopack_context__.r("[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/bodyTrap.js [app-ssr] (ecmascript)");
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};
        if (obj != null) {
            for(var key in obj){
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }
        newObj.default = obj;
        return newObj;
    }
}
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
// so that our CSS is statically analyzable
var CLASS_NAMES = {
    overlay: "ReactModal__Overlay",
    content: "ReactModal__Content"
};
/**
 * We need to support the deprecated `KeyboardEvent.keyCode` in addition to
 * `KeyboardEvent.code` for apps that still support IE11. Can be removed when
 * `react-modal` only supports React >18 (which dropped IE support).
 */ var isTabKey = function isTabKey(event) {
    return event.code === "Tab" || event.keyCode === 9;
};
var isEscKey = function isEscKey(event) {
    return event.code === "Escape" || event.keyCode === 27;
};
var ariaHiddenInstances = 0;
var ModalPortal = function(_Component) {
    _inherits(ModalPortal, _Component);
    function ModalPortal(props) {
        _classCallCheck(this, ModalPortal);
        var _this = _possibleConstructorReturn(this, (ModalPortal.__proto__ || Object.getPrototypeOf(ModalPortal)).call(this, props));
        _this.setOverlayRef = function(overlay) {
            _this.overlay = overlay;
            _this.props.overlayRef && _this.props.overlayRef(overlay);
        };
        _this.setContentRef = function(content) {
            _this.content = content;
            _this.props.contentRef && _this.props.contentRef(content);
        };
        _this.afterClose = function() {
            var _this$props = _this.props, appElement = _this$props.appElement, ariaHideApp = _this$props.ariaHideApp, htmlOpenClassName = _this$props.htmlOpenClassName, bodyOpenClassName = _this$props.bodyOpenClassName, parentSelector = _this$props.parentSelector;
            var parentDocument = parentSelector && parentSelector().ownerDocument || document;
            // Remove classes.
            bodyOpenClassName && classList.remove(parentDocument.body, bodyOpenClassName);
            htmlOpenClassName && classList.remove(parentDocument.getElementsByTagName("html")[0], htmlOpenClassName);
            // Reset aria-hidden attribute if all modals have been removed
            if (ariaHideApp && ariaHiddenInstances > 0) {
                ariaHiddenInstances -= 1;
                if (ariaHiddenInstances === 0) {
                    ariaAppHider.show(appElement);
                }
            }
            if (_this.props.shouldFocusAfterRender) {
                if (_this.props.shouldReturnFocusAfterClose) {
                    focusManager.returnFocus(_this.props.preventScroll);
                    focusManager.teardownScopedFocus();
                } else {
                    focusManager.popWithoutFocus();
                }
            }
            if (_this.props.onAfterClose) {
                _this.props.onAfterClose();
            }
            _portalOpenInstances2.default.deregister(_this);
        };
        _this.open = function() {
            _this.beforeOpen();
            if (_this.state.afterOpen && _this.state.beforeClose) {
                clearTimeout(_this.closeTimer);
                _this.setState({
                    beforeClose: false
                });
            } else {
                if (_this.props.shouldFocusAfterRender) {
                    focusManager.setupScopedFocus(_this.node);
                    focusManager.markForFocusLater();
                }
                _this.setState({
                    isOpen: true
                }, function() {
                    _this.openAnimationFrame = requestAnimationFrame(function() {
                        _this.setState({
                            afterOpen: true
                        });
                        if (_this.props.isOpen && _this.props.onAfterOpen) {
                            _this.props.onAfterOpen({
                                overlayEl: _this.overlay,
                                contentEl: _this.content
                            });
                        }
                    });
                });
            }
        };
        _this.close = function() {
            if (_this.props.closeTimeoutMS > 0) {
                _this.closeWithTimeout();
            } else {
                _this.closeWithoutTimeout();
            }
        };
        _this.focusContent = function() {
            return _this.content && !_this.contentHasFocus() && _this.content.focus({
                preventScroll: true
            });
        };
        _this.closeWithTimeout = function() {
            var closesAt = Date.now() + _this.props.closeTimeoutMS;
            _this.setState({
                beforeClose: true,
                closesAt: closesAt
            }, function() {
                _this.closeTimer = setTimeout(_this.closeWithoutTimeout, _this.state.closesAt - Date.now());
            });
        };
        _this.closeWithoutTimeout = function() {
            _this.setState({
                beforeClose: false,
                isOpen: false,
                afterOpen: false,
                closesAt: null
            }, _this.afterClose);
        };
        _this.handleKeyDown = function(event) {
            if (isTabKey(event)) {
                (0, _scopeTab2.default)(_this.content, event);
            }
            if (_this.props.shouldCloseOnEsc && isEscKey(event)) {
                event.stopPropagation();
                _this.requestClose(event);
            }
        };
        _this.handleOverlayOnClick = function(event) {
            if (_this.shouldClose === null) {
                _this.shouldClose = true;
            }
            if (_this.shouldClose && _this.props.shouldCloseOnOverlayClick) {
                if (_this.ownerHandlesClose()) {
                    _this.requestClose(event);
                } else {
                    _this.focusContent();
                }
            }
            _this.shouldClose = null;
        };
        _this.handleContentOnMouseUp = function() {
            _this.shouldClose = false;
        };
        _this.handleOverlayOnMouseDown = function(event) {
            if (!_this.props.shouldCloseOnOverlayClick && event.target == _this.overlay) {
                event.preventDefault();
            }
        };
        _this.handleContentOnClick = function() {
            _this.shouldClose = false;
        };
        _this.handleContentOnMouseDown = function() {
            _this.shouldClose = false;
        };
        _this.requestClose = function(event) {
            return _this.ownerHandlesClose() && _this.props.onRequestClose(event);
        };
        _this.ownerHandlesClose = function() {
            return _this.props.onRequestClose;
        };
        _this.shouldBeClosed = function() {
            return !_this.state.isOpen && !_this.state.beforeClose;
        };
        _this.contentHasFocus = function() {
            return document.activeElement === _this.content || _this.content.contains(document.activeElement);
        };
        _this.buildClassName = function(which, additional) {
            var classNames = (typeof additional === "undefined" ? "undefined" : _typeof(additional)) === "object" ? additional : {
                base: CLASS_NAMES[which],
                afterOpen: CLASS_NAMES[which] + "--after-open",
                beforeClose: CLASS_NAMES[which] + "--before-close"
            };
            var className = classNames.base;
            if (_this.state.afterOpen) {
                className = className + " " + classNames.afterOpen;
            }
            if (_this.state.beforeClose) {
                className = className + " " + classNames.beforeClose;
            }
            return typeof additional === "string" && additional ? className + " " + additional : className;
        };
        _this.attributesFromObject = function(prefix, items) {
            return Object.keys(items).reduce(function(acc, name) {
                acc[prefix + "-" + name] = items[name];
                return acc;
            }, {});
        };
        _this.state = {
            afterOpen: false,
            beforeClose: false
        };
        _this.shouldClose = null;
        _this.moveFromContentToOverlay = null;
        return _this;
    }
    _createClass(ModalPortal, [
        {
            key: "componentDidMount",
            value: function componentDidMount() {
                if (this.props.isOpen) {
                    this.open();
                }
            }
        },
        {
            key: "componentDidUpdate",
            value: function componentDidUpdate(prevProps, prevState) {
                if ("TURBOPACK compile-time truthy", 1) {
                    if (prevProps.bodyOpenClassName !== this.props.bodyOpenClassName) {
                        // eslint-disable-next-line no-console
                        console.warn('React-Modal: "bodyOpenClassName" prop has been modified. ' + "This may cause unexpected behavior when multiple modals are open.");
                    }
                    if (prevProps.htmlOpenClassName !== this.props.htmlOpenClassName) {
                        // eslint-disable-next-line no-console
                        console.warn('React-Modal: "htmlOpenClassName" prop has been modified. ' + "This may cause unexpected behavior when multiple modals are open.");
                    }
                }
                if (this.props.isOpen && !prevProps.isOpen) {
                    this.open();
                } else if (!this.props.isOpen && prevProps.isOpen) {
                    this.close();
                }
                // Focus only needs to be set once when the modal is being opened
                if (this.props.shouldFocusAfterRender && this.state.isOpen && !prevState.isOpen) {
                    this.focusContent();
                }
            }
        },
        {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                if (this.state.isOpen) {
                    this.afterClose();
                }
                clearTimeout(this.closeTimer);
                cancelAnimationFrame(this.openAnimationFrame);
            }
        },
        {
            key: "beforeOpen",
            value: function beforeOpen() {
                var _props = this.props, appElement = _props.appElement, ariaHideApp = _props.ariaHideApp, htmlOpenClassName = _props.htmlOpenClassName, bodyOpenClassName = _props.bodyOpenClassName, parentSelector = _props.parentSelector;
                var parentDocument = parentSelector && parentSelector().ownerDocument || document;
                // Add classes.
                bodyOpenClassName && classList.add(parentDocument.body, bodyOpenClassName);
                htmlOpenClassName && classList.add(parentDocument.getElementsByTagName("html")[0], htmlOpenClassName);
                if (ariaHideApp) {
                    ariaHiddenInstances += 1;
                    ariaAppHider.hide(appElement);
                }
                _portalOpenInstances2.default.register(this);
            }
        },
        {
            key: "render",
            value: function render() {
                var _props2 = this.props, id = _props2.id, className = _props2.className, overlayClassName = _props2.overlayClassName, defaultStyles = _props2.defaultStyles, children = _props2.children;
                var contentStyles = className ? {} : defaultStyles.content;
                var overlayStyles = overlayClassName ? {} : defaultStyles.overlay;
                if (this.shouldBeClosed()) {
                    return null;
                }
                var overlayProps = {
                    ref: this.setOverlayRef,
                    className: this.buildClassName("overlay", overlayClassName),
                    style: _extends({}, overlayStyles, this.props.style.overlay),
                    onClick: this.handleOverlayOnClick,
                    onMouseDown: this.handleOverlayOnMouseDown
                };
                var contentProps = _extends({
                    id: id,
                    ref: this.setContentRef,
                    style: _extends({}, contentStyles, this.props.style.content),
                    className: this.buildClassName("content", className),
                    tabIndex: "-1",
                    onKeyDown: this.handleKeyDown,
                    onMouseDown: this.handleContentOnMouseDown,
                    onMouseUp: this.handleContentOnMouseUp,
                    onClick: this.handleContentOnClick,
                    role: this.props.role,
                    "aria-label": this.props.contentLabel
                }, this.attributesFromObject("aria", _extends({
                    modal: true
                }, this.props.aria)), this.attributesFromObject("data", this.props.data || {}), {
                    "data-testid": this.props.testId
                });
                var contentElement = this.props.contentElement(contentProps, children);
                return this.props.overlayElement(overlayProps, contentElement);
            }
        }
    ]);
    return ModalPortal;
}(_react.Component);
ModalPortal.defaultProps = {
    style: {
        overlay: {},
        content: {}
    },
    defaultStyles: {}
};
ModalPortal.propTypes = {
    isOpen: _propTypes2.default.bool.isRequired,
    defaultStyles: _propTypes2.default.shape({
        content: _propTypes2.default.object,
        overlay: _propTypes2.default.object
    }),
    style: _propTypes2.default.shape({
        content: _propTypes2.default.object,
        overlay: _propTypes2.default.object
    }),
    className: _propTypes2.default.oneOfType([
        _propTypes2.default.string,
        _propTypes2.default.object
    ]),
    overlayClassName: _propTypes2.default.oneOfType([
        _propTypes2.default.string,
        _propTypes2.default.object
    ]),
    parentSelector: _propTypes2.default.func,
    bodyOpenClassName: _propTypes2.default.string,
    htmlOpenClassName: _propTypes2.default.string,
    ariaHideApp: _propTypes2.default.bool,
    appElement: _propTypes2.default.oneOfType([
        _propTypes2.default.instanceOf(_safeHTMLElement2.default),
        _propTypes2.default.instanceOf(_safeHTMLElement.SafeHTMLCollection),
        _propTypes2.default.instanceOf(_safeHTMLElement.SafeNodeList),
        _propTypes2.default.arrayOf(_propTypes2.default.instanceOf(_safeHTMLElement2.default))
    ]),
    onAfterOpen: _propTypes2.default.func,
    onAfterClose: _propTypes2.default.func,
    onRequestClose: _propTypes2.default.func,
    closeTimeoutMS: _propTypes2.default.number,
    shouldFocusAfterRender: _propTypes2.default.bool,
    shouldCloseOnOverlayClick: _propTypes2.default.bool,
    shouldReturnFocusAfterClose: _propTypes2.default.bool,
    preventScroll: _propTypes2.default.bool,
    role: _propTypes2.default.string,
    contentLabel: _propTypes2.default.string,
    aria: _propTypes2.default.object,
    data: _propTypes2.default.object,
    children: _propTypes2.default.node,
    shouldCloseOnEsc: _propTypes2.default.bool,
    overlayRef: _propTypes2.default.func,
    contentRef: _propTypes2.default.func,
    id: _propTypes2.default.string,
    overlayElement: _propTypes2.default.func,
    contentElement: _propTypes2.default.func,
    testId: _propTypes2.default.string
};
exports.default = ModalPortal;
module.exports = exports["default"];
}}),
"[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/components/Modal.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bodyOpenClassName = exports.portalClassName = undefined;
var _extends = Object.assign || function(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i];
        for(var key in source){
            if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }
    return target;
};
var _createClass = function() {
    function defineProperties(target, props) {
        for(var i = 0; i < props.length; i++){
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();
var _react = __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.2.3_@babel+core@7.26.10_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var _react2 = _interopRequireDefault(_react);
var _reactDom = __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.2.3_@babel+core@7.26.10_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js [app-ssr] (ecmascript)");
var _reactDom2 = _interopRequireDefault(_reactDom);
var _propTypes = __turbopack_context__.r("[project]/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js [app-ssr] (ecmascript)");
var _propTypes2 = _interopRequireDefault(_propTypes);
var _ModalPortal = __turbopack_context__.r("[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/components/ModalPortal.js [app-ssr] (ecmascript)");
var _ModalPortal2 = _interopRequireDefault(_ModalPortal);
var _ariaAppHider = __turbopack_context__.r("[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/ariaAppHider.js [app-ssr] (ecmascript)");
var ariaAppHider = _interopRequireWildcard(_ariaAppHider);
var _safeHTMLElement = __turbopack_context__.r("[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/helpers/safeHTMLElement.js [app-ssr] (ecmascript)");
var _safeHTMLElement2 = _interopRequireDefault(_safeHTMLElement);
var _reactLifecyclesCompat = __turbopack_context__.r("[project]/node_modules/.pnpm/react-lifecycles-compat@3.0.4/node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js [app-ssr] (ecmascript)");
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};
        if (obj != null) {
            for(var key in obj){
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }
        newObj.default = obj;
        return newObj;
    }
}
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var portalClassName = exports.portalClassName = "ReactModalPortal";
var bodyOpenClassName = exports.bodyOpenClassName = "ReactModal__Body--open";
var isReact16 = _safeHTMLElement.canUseDOM && _reactDom2.default.createPortal !== undefined;
var createHTMLElement = function createHTMLElement(name) {
    return document.createElement(name);
};
var getCreatePortal = function getCreatePortal() {
    return isReact16 ? _reactDom2.default.createPortal : _reactDom2.default.unstable_renderSubtreeIntoContainer;
};
function getParentElement(parentSelector) {
    return parentSelector();
}
var Modal = function(_Component) {
    _inherits(Modal, _Component);
    function Modal() {
        var _ref;
        var _temp, _this, _ret;
        _classCallCheck(this, Modal);
        for(var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Modal.__proto__ || Object.getPrototypeOf(Modal)).call.apply(_ref, [
            this
        ].concat(args))), _this), _this.removePortal = function() {
            !isReact16 && _reactDom2.default.unmountComponentAtNode(_this.node);
            var parent = getParentElement(_this.props.parentSelector);
            if (parent && parent.contains(_this.node)) {
                parent.removeChild(_this.node);
            } else {
                // eslint-disable-next-line no-console
                console.warn('React-Modal: "parentSelector" prop did not returned any DOM ' + "element. Make sure that the parent element is unmounted to " + "avoid any memory leaks.");
            }
        }, _this.portalRef = function(ref) {
            _this.portal = ref;
        }, _this.renderPortal = function(props) {
            var createPortal = getCreatePortal();
            var portal = createPortal(_this, _react2.default.createElement(_ModalPortal2.default, _extends({
                defaultStyles: Modal.defaultStyles
            }, props)), _this.node);
            _this.portalRef(portal);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }
    _createClass(Modal, [
        {
            key: "componentDidMount",
            value: function componentDidMount() {
                if (!_safeHTMLElement.canUseDOM) return;
                if (!isReact16) {
                    this.node = createHTMLElement("div");
                }
                this.node.className = this.props.portalClassName;
                var parent = getParentElement(this.props.parentSelector);
                parent.appendChild(this.node);
                !isReact16 && this.renderPortal(this.props);
            }
        },
        {
            key: "getSnapshotBeforeUpdate",
            value: function getSnapshotBeforeUpdate(prevProps) {
                var prevParent = getParentElement(prevProps.parentSelector);
                var nextParent = getParentElement(this.props.parentSelector);
                return {
                    prevParent: prevParent,
                    nextParent: nextParent
                };
            }
        },
        {
            key: "componentDidUpdate",
            value: function componentDidUpdate(prevProps, _, snapshot) {
                if (!_safeHTMLElement.canUseDOM) return;
                var _props = this.props, isOpen = _props.isOpen, portalClassName = _props.portalClassName;
                if (prevProps.portalClassName !== portalClassName) {
                    this.node.className = portalClassName;
                }
                var prevParent = snapshot.prevParent, nextParent = snapshot.nextParent;
                if (nextParent !== prevParent) {
                    prevParent.removeChild(this.node);
                    nextParent.appendChild(this.node);
                }
                // Stop unnecessary renders if modal is remaining closed
                if (!prevProps.isOpen && !isOpen) return;
                !isReact16 && this.renderPortal(this.props);
            }
        },
        {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                if (!_safeHTMLElement.canUseDOM || !this.node || !this.portal) return;
                var state = this.portal.state;
                var now = Date.now();
                var closesAt = state.isOpen && this.props.closeTimeoutMS && (state.closesAt || now + this.props.closeTimeoutMS);
                if (closesAt) {
                    if (!state.beforeClose) {
                        this.portal.closeWithTimeout();
                    }
                    setTimeout(this.removePortal, closesAt - now);
                } else {
                    this.removePortal();
                }
            }
        },
        {
            key: "render",
            value: function render() {
                if (!_safeHTMLElement.canUseDOM || !isReact16) {
                    return null;
                }
                if (!this.node && isReact16) {
                    this.node = createHTMLElement("div");
                }
                var createPortal = getCreatePortal();
                return createPortal(_react2.default.createElement(_ModalPortal2.default, _extends({
                    ref: this.portalRef,
                    defaultStyles: Modal.defaultStyles
                }, this.props)), this.node);
            }
        }
    ], [
        {
            key: "setAppElement",
            value: function setAppElement(element) {
                ariaAppHider.setElement(element);
            }
        }
    ]);
    return Modal;
}(_react.Component);
Modal.propTypes = {
    isOpen: _propTypes2.default.bool.isRequired,
    style: _propTypes2.default.shape({
        content: _propTypes2.default.object,
        overlay: _propTypes2.default.object
    }),
    portalClassName: _propTypes2.default.string,
    bodyOpenClassName: _propTypes2.default.string,
    htmlOpenClassName: _propTypes2.default.string,
    className: _propTypes2.default.oneOfType([
        _propTypes2.default.string,
        _propTypes2.default.shape({
            base: _propTypes2.default.string.isRequired,
            afterOpen: _propTypes2.default.string.isRequired,
            beforeClose: _propTypes2.default.string.isRequired
        })
    ]),
    overlayClassName: _propTypes2.default.oneOfType([
        _propTypes2.default.string,
        _propTypes2.default.shape({
            base: _propTypes2.default.string.isRequired,
            afterOpen: _propTypes2.default.string.isRequired,
            beforeClose: _propTypes2.default.string.isRequired
        })
    ]),
    appElement: _propTypes2.default.oneOfType([
        _propTypes2.default.instanceOf(_safeHTMLElement2.default),
        _propTypes2.default.instanceOf(_safeHTMLElement.SafeHTMLCollection),
        _propTypes2.default.instanceOf(_safeHTMLElement.SafeNodeList),
        _propTypes2.default.arrayOf(_propTypes2.default.instanceOf(_safeHTMLElement2.default))
    ]),
    onAfterOpen: _propTypes2.default.func,
    onRequestClose: _propTypes2.default.func,
    closeTimeoutMS: _propTypes2.default.number,
    ariaHideApp: _propTypes2.default.bool,
    shouldFocusAfterRender: _propTypes2.default.bool,
    shouldCloseOnOverlayClick: _propTypes2.default.bool,
    shouldReturnFocusAfterClose: _propTypes2.default.bool,
    preventScroll: _propTypes2.default.bool,
    parentSelector: _propTypes2.default.func,
    aria: _propTypes2.default.object,
    data: _propTypes2.default.object,
    role: _propTypes2.default.string,
    contentLabel: _propTypes2.default.string,
    shouldCloseOnEsc: _propTypes2.default.bool,
    overlayRef: _propTypes2.default.func,
    contentRef: _propTypes2.default.func,
    id: _propTypes2.default.string,
    overlayElement: _propTypes2.default.func,
    contentElement: _propTypes2.default.func
};
Modal.defaultProps = {
    isOpen: false,
    portalClassName: portalClassName,
    bodyOpenClassName: bodyOpenClassName,
    role: "dialog",
    ariaHideApp: true,
    closeTimeoutMS: 0,
    shouldFocusAfterRender: true,
    shouldCloseOnEsc: true,
    shouldCloseOnOverlayClick: true,
    shouldReturnFocusAfterClose: true,
    preventScroll: false,
    parentSelector: function parentSelector() {
        return document.body;
    },
    overlayElement: function overlayElement(props, contentEl) {
        return _react2.default.createElement("div", props, contentEl);
    },
    contentElement: function contentElement(props, children) {
        return _react2.default.createElement("div", props, children);
    }
};
Modal.defaultStyles = {
    overlay: {
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: "rgba(255, 255, 255, 0.75)"
    },
    content: {
        position: "absolute",
        top: "40px",
        left: "40px",
        right: "40px",
        bottom: "40px",
        border: "1px solid #ccc",
        background: "#fff",
        overflow: "auto",
        WebkitOverflowScrolling: "touch",
        borderRadius: "4px",
        outline: "none",
        padding: "20px"
    }
};
(0, _reactLifecyclesCompat.polyfill)(Modal);
if ("TURBOPACK compile-time truthy", 1) {
    Modal.setCreateHTMLElement = function(fn) {
        return createHTMLElement = fn;
    };
}
exports.default = Modal;
}}),
"[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _Modal = __turbopack_context__.r("[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/components/Modal.js [app-ssr] (ecmascript)");
var _Modal2 = _interopRequireDefault(_Modal);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
exports.default = _Modal2.default;
module.exports = exports["default"];
}}),
"[project]/node_modules/.pnpm/warning@4.0.3/node_modules/warning/warning.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */ var __DEV__ = ("TURBOPACK compile-time value", "development") !== 'production';
var warning = function() {};
if ("TURBOPACK compile-time truthy", 1) {
    var printWarning = function printWarning(format, args) {
        var len = arguments.length;
        args = new Array(len > 1 ? len - 1 : 0);
        for(var key = 1; key < len; key++){
            args[key - 1] = arguments[key];
        }
        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function() {
            return args[argIndex++];
        });
        if (typeof console !== 'undefined') {
            console.error(message);
        }
        try {
            // --- Welcome to debugging React ---
            // This error was thrown as a convenience so that you can use this stack
            // to find the callsite that caused this warning to fire.
            throw new Error(message);
        } catch (x) {}
    };
    warning = function(condition, format, args) {
        var len = arguments.length;
        args = new Array(len > 2 ? len - 2 : 0);
        for(var key = 2; key < len; key++){
            args[key - 2] = arguments[key];
        }
        if (format === undefined) {
            throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
        }
        if (!condition) {
            printWarning.apply(null, [
                format
            ].concat(args));
        }
    };
}
module.exports = warning;
}}),
"[project]/node_modules/.pnpm/exenv@1.2.2/node_modules/exenv/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
  Copyright (c) 2015 Jed Watson.
  Based on code that is Copyright 2013-2015, Facebook, Inc.
  All rights reserved.
*/ /* global define */ (function() {
    'use strict';
    var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
    var ExecutionEnvironment = {
        canUseDOM: canUseDOM,
        canUseWorkers: typeof Worker !== 'undefined',
        canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
        canUseViewport: canUseDOM && !!window.screen
    };
    if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return ExecutionEnvironment;
        }(__turbopack_context__.r, exports, module));
    } else if (("TURBOPACK compile-time value", "object") !== 'undefined' && module.exports) {
        module.exports = ExecutionEnvironment;
    } else {
        window.ExecutionEnvironment = ExecutionEnvironment;
    }
})();
}}),
"[project]/node_modules/.pnpm/react-lifecycles-compat@3.0.4/node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "polyfill": (()=>polyfill)
});
function componentWillMount() {
    // Call this.constructor.gDSFP to support sub-classes.
    var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
    if (state !== null && state !== undefined) {
        this.setState(state);
    }
}
function componentWillReceiveProps(nextProps) {
    // Call this.constructor.gDSFP to support sub-classes.
    // Use the setState() updater to ensure state isn't stale in certain edge cases.
    function updater(prevState) {
        var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
        return state !== null && state !== undefined ? state : null;
    }
    // Binding "this" is important for shallow renderer support.
    this.setState(updater.bind(this));
}
function componentWillUpdate(nextProps, nextState) {
    try {
        var prevProps = this.props;
        var prevState = this.state;
        this.props = nextProps;
        this.state = nextState;
        this.__reactInternalSnapshotFlag = true;
        this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(prevProps, prevState);
    } finally{
        this.props = prevProps;
        this.state = prevState;
    }
}
// React may warn about cWM/cWRP/cWU methods being deprecated.
// Add a flag to suppress these warnings for this special case.
componentWillMount.__suppressDeprecationWarning = true;
componentWillReceiveProps.__suppressDeprecationWarning = true;
componentWillUpdate.__suppressDeprecationWarning = true;
function polyfill(Component) {
    var prototype = Component.prototype;
    if (!prototype || !prototype.isReactComponent) {
        throw new Error('Can only polyfill class components');
    }
    if (typeof Component.getDerivedStateFromProps !== 'function' && typeof prototype.getSnapshotBeforeUpdate !== 'function') {
        return Component;
    }
    // If new component APIs are defined, "unsafe" lifecycles won't be called.
    // Error if any of these lifecycles are present,
    // Because they would work differently between older and newer (16.3+) versions of React.
    var foundWillMountName = null;
    var foundWillReceivePropsName = null;
    var foundWillUpdateName = null;
    if (typeof prototype.componentWillMount === 'function') {
        foundWillMountName = 'componentWillMount';
    } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {
        foundWillMountName = 'UNSAFE_componentWillMount';
    }
    if (typeof prototype.componentWillReceiveProps === 'function') {
        foundWillReceivePropsName = 'componentWillReceiveProps';
    } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {
        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
    }
    if (typeof prototype.componentWillUpdate === 'function') {
        foundWillUpdateName = 'componentWillUpdate';
    } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {
        foundWillUpdateName = 'UNSAFE_componentWillUpdate';
    }
    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
        var componentName = Component.displayName || Component.name;
        var newApiName = typeof Component.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';
        throw Error('Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' + componentName + ' uses ' + newApiName + ' but also contains the following legacy lifecycles:' + (foundWillMountName !== null ? '\n  ' + foundWillMountName : '') + (foundWillReceivePropsName !== null ? '\n  ' + foundWillReceivePropsName : '') + (foundWillUpdateName !== null ? '\n  ' + foundWillUpdateName : '') + '\n\nThe above lifecycles should be removed. Learn more about this warning here:\n' + 'https://fb.me/react-async-component-lifecycle-hooks');
    }
    // React <= 16.2 does not support static getDerivedStateFromProps.
    // As a workaround, use cWM and cWRP to invoke the new static lifecycle.
    // Newer versions of React will ignore these lifecycles if gDSFP exists.
    if (typeof Component.getDerivedStateFromProps === 'function') {
        prototype.componentWillMount = componentWillMount;
        prototype.componentWillReceiveProps = componentWillReceiveProps;
    }
    // React <= 16.2 does not support getSnapshotBeforeUpdate.
    // As a workaround, use cWU to invoke the new lifecycle.
    // Newer versions of React will ignore that lifecycle if gSBU exists.
    if (typeof prototype.getSnapshotBeforeUpdate === 'function') {
        if (typeof prototype.componentDidUpdate !== 'function') {
            throw new Error('Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype');
        }
        prototype.componentWillUpdate = componentWillUpdate;
        var componentDidUpdate = prototype.componentDidUpdate;
        prototype.componentDidUpdate = function componentDidUpdatePolyfill(prevProps, prevState, maybeSnapshot) {
            // 16.3+ will not execute our will-update method;
            // It will pass a snapshot value to did-update though.
            // Older versions will require our polyfilled will-update value.
            // We need to handle both cases, but can't just check for the presence of "maybeSnapshot",
            // Because for <= 15.x versions this might be a "prevContext" object.
            // We also can't just check "__reactInternalSnapshot",
            // Because get-snapshot might return a falsy value.
            // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.
            var snapshot = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : maybeSnapshot;
            componentDidUpdate.call(this, prevProps, prevState, snapshot);
        };
    }
    return Component;
}
;
}}),
"[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/mode.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = {
    MODE_NUMBER: 1 << 0,
    MODE_ALPHA_NUM: 1 << 1,
    MODE_8BIT_BYTE: 1 << 2,
    MODE_KANJI: 1 << 3
};
}}),
"[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/8BitByte.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var mode = __turbopack_context__.r("[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/mode.js [app-ssr] (ecmascript)");
function QR8bitByte(data) {
    this.mode = mode.MODE_8BIT_BYTE;
    this.data = data;
}
QR8bitByte.prototype = {
    getLength: function(buffer) {
        return this.data.length;
    },
    write: function(buffer) {
        for(var i = 0; i < this.data.length; i++){
            // not JIS ...
            buffer.put(this.data.charCodeAt(i), 8);
        }
    }
};
module.exports = QR8bitByte;
}}),
"[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/ErrorCorrectLevel.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = {
    L: 1,
    M: 0,
    Q: 3,
    H: 2
};
}}),
"[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/RSBlock.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// ErrorCorrectLevel
var ECL = __turbopack_context__.r("[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/ErrorCorrectLevel.js [app-ssr] (ecmascript)");
function QRRSBlock(totalCount, dataCount) {
    this.totalCount = totalCount;
    this.dataCount = dataCount;
}
QRRSBlock.RS_BLOCK_TABLE = [
    // L
    // M
    // Q
    // H
    // 1
    [
        1,
        26,
        19
    ],
    [
        1,
        26,
        16
    ],
    [
        1,
        26,
        13
    ],
    [
        1,
        26,
        9
    ],
    // 2
    [
        1,
        44,
        34
    ],
    [
        1,
        44,
        28
    ],
    [
        1,
        44,
        22
    ],
    [
        1,
        44,
        16
    ],
    // 3
    [
        1,
        70,
        55
    ],
    [
        1,
        70,
        44
    ],
    [
        2,
        35,
        17
    ],
    [
        2,
        35,
        13
    ],
    // 4		
    [
        1,
        100,
        80
    ],
    [
        2,
        50,
        32
    ],
    [
        2,
        50,
        24
    ],
    [
        4,
        25,
        9
    ],
    // 5
    [
        1,
        134,
        108
    ],
    [
        2,
        67,
        43
    ],
    [
        2,
        33,
        15,
        2,
        34,
        16
    ],
    [
        2,
        33,
        11,
        2,
        34,
        12
    ],
    // 6
    [
        2,
        86,
        68
    ],
    [
        4,
        43,
        27
    ],
    [
        4,
        43,
        19
    ],
    [
        4,
        43,
        15
    ],
    // 7		
    [
        2,
        98,
        78
    ],
    [
        4,
        49,
        31
    ],
    [
        2,
        32,
        14,
        4,
        33,
        15
    ],
    [
        4,
        39,
        13,
        1,
        40,
        14
    ],
    // 8
    [
        2,
        121,
        97
    ],
    [
        2,
        60,
        38,
        2,
        61,
        39
    ],
    [
        4,
        40,
        18,
        2,
        41,
        19
    ],
    [
        4,
        40,
        14,
        2,
        41,
        15
    ],
    // 9
    [
        2,
        146,
        116
    ],
    [
        3,
        58,
        36,
        2,
        59,
        37
    ],
    [
        4,
        36,
        16,
        4,
        37,
        17
    ],
    [
        4,
        36,
        12,
        4,
        37,
        13
    ],
    // 10		
    [
        2,
        86,
        68,
        2,
        87,
        69
    ],
    [
        4,
        69,
        43,
        1,
        70,
        44
    ],
    [
        6,
        43,
        19,
        2,
        44,
        20
    ],
    [
        6,
        43,
        15,
        2,
        44,
        16
    ],
    // 11
    [
        4,
        101,
        81
    ],
    [
        1,
        80,
        50,
        4,
        81,
        51
    ],
    [
        4,
        50,
        22,
        4,
        51,
        23
    ],
    [
        3,
        36,
        12,
        8,
        37,
        13
    ],
    // 12
    [
        2,
        116,
        92,
        2,
        117,
        93
    ],
    [
        6,
        58,
        36,
        2,
        59,
        37
    ],
    [
        4,
        46,
        20,
        6,
        47,
        21
    ],
    [
        7,
        42,
        14,
        4,
        43,
        15
    ],
    // 13
    [
        4,
        133,
        107
    ],
    [
        8,
        59,
        37,
        1,
        60,
        38
    ],
    [
        8,
        44,
        20,
        4,
        45,
        21
    ],
    [
        12,
        33,
        11,
        4,
        34,
        12
    ],
    // 14
    [
        3,
        145,
        115,
        1,
        146,
        116
    ],
    [
        4,
        64,
        40,
        5,
        65,
        41
    ],
    [
        11,
        36,
        16,
        5,
        37,
        17
    ],
    [
        11,
        36,
        12,
        5,
        37,
        13
    ],
    // 15
    [
        5,
        109,
        87,
        1,
        110,
        88
    ],
    [
        5,
        65,
        41,
        5,
        66,
        42
    ],
    [
        5,
        54,
        24,
        7,
        55,
        25
    ],
    [
        11,
        36,
        12
    ],
    // 16
    [
        5,
        122,
        98,
        1,
        123,
        99
    ],
    [
        7,
        73,
        45,
        3,
        74,
        46
    ],
    [
        15,
        43,
        19,
        2,
        44,
        20
    ],
    [
        3,
        45,
        15,
        13,
        46,
        16
    ],
    // 17
    [
        1,
        135,
        107,
        5,
        136,
        108
    ],
    [
        10,
        74,
        46,
        1,
        75,
        47
    ],
    [
        1,
        50,
        22,
        15,
        51,
        23
    ],
    [
        2,
        42,
        14,
        17,
        43,
        15
    ],
    // 18
    [
        5,
        150,
        120,
        1,
        151,
        121
    ],
    [
        9,
        69,
        43,
        4,
        70,
        44
    ],
    [
        17,
        50,
        22,
        1,
        51,
        23
    ],
    [
        2,
        42,
        14,
        19,
        43,
        15
    ],
    // 19
    [
        3,
        141,
        113,
        4,
        142,
        114
    ],
    [
        3,
        70,
        44,
        11,
        71,
        45
    ],
    [
        17,
        47,
        21,
        4,
        48,
        22
    ],
    [
        9,
        39,
        13,
        16,
        40,
        14
    ],
    // 20
    [
        3,
        135,
        107,
        5,
        136,
        108
    ],
    [
        3,
        67,
        41,
        13,
        68,
        42
    ],
    [
        15,
        54,
        24,
        5,
        55,
        25
    ],
    [
        15,
        43,
        15,
        10,
        44,
        16
    ],
    // 21
    [
        4,
        144,
        116,
        4,
        145,
        117
    ],
    [
        17,
        68,
        42
    ],
    [
        17,
        50,
        22,
        6,
        51,
        23
    ],
    [
        19,
        46,
        16,
        6,
        47,
        17
    ],
    // 22
    [
        2,
        139,
        111,
        7,
        140,
        112
    ],
    [
        17,
        74,
        46
    ],
    [
        7,
        54,
        24,
        16,
        55,
        25
    ],
    [
        34,
        37,
        13
    ],
    // 23
    [
        4,
        151,
        121,
        5,
        152,
        122
    ],
    [
        4,
        75,
        47,
        14,
        76,
        48
    ],
    [
        11,
        54,
        24,
        14,
        55,
        25
    ],
    [
        16,
        45,
        15,
        14,
        46,
        16
    ],
    // 24
    [
        6,
        147,
        117,
        4,
        148,
        118
    ],
    [
        6,
        73,
        45,
        14,
        74,
        46
    ],
    [
        11,
        54,
        24,
        16,
        55,
        25
    ],
    [
        30,
        46,
        16,
        2,
        47,
        17
    ],
    // 25
    [
        8,
        132,
        106,
        4,
        133,
        107
    ],
    [
        8,
        75,
        47,
        13,
        76,
        48
    ],
    [
        7,
        54,
        24,
        22,
        55,
        25
    ],
    [
        22,
        45,
        15,
        13,
        46,
        16
    ],
    // 26
    [
        10,
        142,
        114,
        2,
        143,
        115
    ],
    [
        19,
        74,
        46,
        4,
        75,
        47
    ],
    [
        28,
        50,
        22,
        6,
        51,
        23
    ],
    [
        33,
        46,
        16,
        4,
        47,
        17
    ],
    // 27
    [
        8,
        152,
        122,
        4,
        153,
        123
    ],
    [
        22,
        73,
        45,
        3,
        74,
        46
    ],
    [
        8,
        53,
        23,
        26,
        54,
        24
    ],
    [
        12,
        45,
        15,
        28,
        46,
        16
    ],
    // 28
    [
        3,
        147,
        117,
        10,
        148,
        118
    ],
    [
        3,
        73,
        45,
        23,
        74,
        46
    ],
    [
        4,
        54,
        24,
        31,
        55,
        25
    ],
    [
        11,
        45,
        15,
        31,
        46,
        16
    ],
    // 29
    [
        7,
        146,
        116,
        7,
        147,
        117
    ],
    [
        21,
        73,
        45,
        7,
        74,
        46
    ],
    [
        1,
        53,
        23,
        37,
        54,
        24
    ],
    [
        19,
        45,
        15,
        26,
        46,
        16
    ],
    // 30
    [
        5,
        145,
        115,
        10,
        146,
        116
    ],
    [
        19,
        75,
        47,
        10,
        76,
        48
    ],
    [
        15,
        54,
        24,
        25,
        55,
        25
    ],
    [
        23,
        45,
        15,
        25,
        46,
        16
    ],
    // 31
    [
        13,
        145,
        115,
        3,
        146,
        116
    ],
    [
        2,
        74,
        46,
        29,
        75,
        47
    ],
    [
        42,
        54,
        24,
        1,
        55,
        25
    ],
    [
        23,
        45,
        15,
        28,
        46,
        16
    ],
    // 32
    [
        17,
        145,
        115
    ],
    [
        10,
        74,
        46,
        23,
        75,
        47
    ],
    [
        10,
        54,
        24,
        35,
        55,
        25
    ],
    [
        19,
        45,
        15,
        35,
        46,
        16
    ],
    // 33
    [
        17,
        145,
        115,
        1,
        146,
        116
    ],
    [
        14,
        74,
        46,
        21,
        75,
        47
    ],
    [
        29,
        54,
        24,
        19,
        55,
        25
    ],
    [
        11,
        45,
        15,
        46,
        46,
        16
    ],
    // 34
    [
        13,
        145,
        115,
        6,
        146,
        116
    ],
    [
        14,
        74,
        46,
        23,
        75,
        47
    ],
    [
        44,
        54,
        24,
        7,
        55,
        25
    ],
    [
        59,
        46,
        16,
        1,
        47,
        17
    ],
    // 35
    [
        12,
        151,
        121,
        7,
        152,
        122
    ],
    [
        12,
        75,
        47,
        26,
        76,
        48
    ],
    [
        39,
        54,
        24,
        14,
        55,
        25
    ],
    [
        22,
        45,
        15,
        41,
        46,
        16
    ],
    // 36
    [
        6,
        151,
        121,
        14,
        152,
        122
    ],
    [
        6,
        75,
        47,
        34,
        76,
        48
    ],
    [
        46,
        54,
        24,
        10,
        55,
        25
    ],
    [
        2,
        45,
        15,
        64,
        46,
        16
    ],
    // 37
    [
        17,
        152,
        122,
        4,
        153,
        123
    ],
    [
        29,
        74,
        46,
        14,
        75,
        47
    ],
    [
        49,
        54,
        24,
        10,
        55,
        25
    ],
    [
        24,
        45,
        15,
        46,
        46,
        16
    ],
    // 38
    [
        4,
        152,
        122,
        18,
        153,
        123
    ],
    [
        13,
        74,
        46,
        32,
        75,
        47
    ],
    [
        48,
        54,
        24,
        14,
        55,
        25
    ],
    [
        42,
        45,
        15,
        32,
        46,
        16
    ],
    // 39
    [
        20,
        147,
        117,
        4,
        148,
        118
    ],
    [
        40,
        75,
        47,
        7,
        76,
        48
    ],
    [
        43,
        54,
        24,
        22,
        55,
        25
    ],
    [
        10,
        45,
        15,
        67,
        46,
        16
    ],
    // 40
    [
        19,
        148,
        118,
        6,
        149,
        119
    ],
    [
        18,
        75,
        47,
        31,
        76,
        48
    ],
    [
        34,
        54,
        24,
        34,
        55,
        25
    ],
    [
        20,
        45,
        15,
        61,
        46,
        16
    ]
];
QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
    var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
    if (rsBlock == undefined) {
        throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
    }
    var length = rsBlock.length / 3;
    var list = new Array();
    for(var i = 0; i < length; i++){
        var count = rsBlock[i * 3 + 0];
        var totalCount = rsBlock[i * 3 + 1];
        var dataCount = rsBlock[i * 3 + 2];
        for(var j = 0; j < count; j++){
            list.push(new QRRSBlock(totalCount, dataCount));
        }
    }
    return list;
};
QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
    switch(errorCorrectLevel){
        case ECL.L:
            return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
        case ECL.M:
            return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
        case ECL.Q:
            return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
        case ECL.H:
            return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
        default:
            return undefined;
    }
};
module.exports = QRRSBlock;
}}),
"[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/BitBuffer.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
function QRBitBuffer() {
    this.buffer = new Array();
    this.length = 0;
}
QRBitBuffer.prototype = {
    get: function(index) {
        var bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;
    },
    put: function(num, length) {
        for(var i = 0; i < length; i++){
            this.putBit((num >>> length - i - 1 & 1) == 1);
        }
    },
    getLengthInBits: function() {
        return this.length;
    },
    putBit: function(bit) {
        var bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
            this.buffer.push(0);
        }
        if (bit) {
            this.buffer[bufIndex] |= 0x80 >>> this.length % 8;
        }
        this.length++;
    }
};
module.exports = QRBitBuffer;
}}),
"[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/math.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var QRMath = {
    glog: function(n) {
        if (n < 1) {
            throw new Error("glog(" + n + ")");
        }
        return QRMath.LOG_TABLE[n];
    },
    gexp: function(n) {
        while(n < 0){
            n += 255;
        }
        while(n >= 256){
            n -= 255;
        }
        return QRMath.EXP_TABLE[n];
    },
    EXP_TABLE: new Array(256),
    LOG_TABLE: new Array(256)
};
for(var i = 0; i < 8; i++){
    QRMath.EXP_TABLE[i] = 1 << i;
}
for(var i = 8; i < 256; i++){
    QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
}
for(var i = 0; i < 255; i++){
    QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
}
module.exports = QRMath;
}}),
"[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/Polynomial.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var math = __turbopack_context__.r("[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/math.js [app-ssr] (ecmascript)");
function QRPolynomial(num, shift) {
    if (num.length == undefined) {
        throw new Error(num.length + "/" + shift);
    }
    var offset = 0;
    while(offset < num.length && num[offset] == 0){
        offset++;
    }
    this.num = new Array(num.length - offset + shift);
    for(var i = 0; i < num.length - offset; i++){
        this.num[i] = num[i + offset];
    }
}
QRPolynomial.prototype = {
    get: function(index) {
        return this.num[index];
    },
    getLength: function() {
        return this.num.length;
    },
    multiply: function(e) {
        var num = new Array(this.getLength() + e.getLength() - 1);
        for(var i = 0; i < this.getLength(); i++){
            for(var j = 0; j < e.getLength(); j++){
                num[i + j] ^= math.gexp(math.glog(this.get(i)) + math.glog(e.get(j)));
            }
        }
        return new QRPolynomial(num, 0);
    },
    mod: function(e) {
        if (this.getLength() - e.getLength() < 0) {
            return this;
        }
        var ratio = math.glog(this.get(0)) - math.glog(e.get(0));
        var num = new Array(this.getLength());
        for(var i = 0; i < this.getLength(); i++){
            num[i] = this.get(i);
        }
        for(var i = 0; i < e.getLength(); i++){
            num[i] ^= math.gexp(math.glog(e.get(i)) + ratio);
        }
        // recursive call
        return new QRPolynomial(num, 0).mod(e);
    }
};
module.exports = QRPolynomial;
}}),
"[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var Mode = __turbopack_context__.r("[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/mode.js [app-ssr] (ecmascript)");
var Polynomial = __turbopack_context__.r("[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/Polynomial.js [app-ssr] (ecmascript)");
var math = __turbopack_context__.r("[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/math.js [app-ssr] (ecmascript)");
var QRMaskPattern = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
};
var QRUtil = {
    PATTERN_POSITION_TABLE: [
        [],
        [
            6,
            18
        ],
        [
            6,
            22
        ],
        [
            6,
            26
        ],
        [
            6,
            30
        ],
        [
            6,
            34
        ],
        [
            6,
            22,
            38
        ],
        [
            6,
            24,
            42
        ],
        [
            6,
            26,
            46
        ],
        [
            6,
            28,
            50
        ],
        [
            6,
            30,
            54
        ],
        [
            6,
            32,
            58
        ],
        [
            6,
            34,
            62
        ],
        [
            6,
            26,
            46,
            66
        ],
        [
            6,
            26,
            48,
            70
        ],
        [
            6,
            26,
            50,
            74
        ],
        [
            6,
            30,
            54,
            78
        ],
        [
            6,
            30,
            56,
            82
        ],
        [
            6,
            30,
            58,
            86
        ],
        [
            6,
            34,
            62,
            90
        ],
        [
            6,
            28,
            50,
            72,
            94
        ],
        [
            6,
            26,
            50,
            74,
            98
        ],
        [
            6,
            30,
            54,
            78,
            102
        ],
        [
            6,
            28,
            54,
            80,
            106
        ],
        [
            6,
            32,
            58,
            84,
            110
        ],
        [
            6,
            30,
            58,
            86,
            114
        ],
        [
            6,
            34,
            62,
            90,
            118
        ],
        [
            6,
            26,
            50,
            74,
            98,
            122
        ],
        [
            6,
            30,
            54,
            78,
            102,
            126
        ],
        [
            6,
            26,
            52,
            78,
            104,
            130
        ],
        [
            6,
            30,
            56,
            82,
            108,
            134
        ],
        [
            6,
            34,
            60,
            86,
            112,
            138
        ],
        [
            6,
            30,
            58,
            86,
            114,
            142
        ],
        [
            6,
            34,
            62,
            90,
            118,
            146
        ],
        [
            6,
            30,
            54,
            78,
            102,
            126,
            150
        ],
        [
            6,
            24,
            50,
            76,
            102,
            128,
            154
        ],
        [
            6,
            28,
            54,
            80,
            106,
            132,
            158
        ],
        [
            6,
            32,
            58,
            84,
            110,
            136,
            162
        ],
        [
            6,
            26,
            54,
            82,
            110,
            138,
            166
        ],
        [
            6,
            30,
            58,
            86,
            114,
            142,
            170
        ]
    ],
    G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0,
    G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0,
    G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1,
    getBCHTypeInfo: function(data) {
        var d = data << 10;
        while(QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0){
            d ^= QRUtil.G15 << QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15);
        }
        return (data << 10 | d) ^ QRUtil.G15_MASK;
    },
    getBCHTypeNumber: function(data) {
        var d = data << 12;
        while(QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0){
            d ^= QRUtil.G18 << QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18);
        }
        return data << 12 | d;
    },
    getBCHDigit: function(data) {
        var digit = 0;
        while(data != 0){
            digit++;
            data >>>= 1;
        }
        return digit;
    },
    getPatternPosition: function(typeNumber) {
        return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
    },
    getMask: function(maskPattern, i, j) {
        switch(maskPattern){
            case QRMaskPattern.PATTERN000:
                return (i + j) % 2 == 0;
            case QRMaskPattern.PATTERN001:
                return i % 2 == 0;
            case QRMaskPattern.PATTERN010:
                return j % 3 == 0;
            case QRMaskPattern.PATTERN011:
                return (i + j) % 3 == 0;
            case QRMaskPattern.PATTERN100:
                return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
            case QRMaskPattern.PATTERN101:
                return i * j % 2 + i * j % 3 == 0;
            case QRMaskPattern.PATTERN110:
                return (i * j % 2 + i * j % 3) % 2 == 0;
            case QRMaskPattern.PATTERN111:
                return (i * j % 3 + (i + j) % 2) % 2 == 0;
            default:
                throw new Error("bad maskPattern:" + maskPattern);
        }
    },
    getErrorCorrectPolynomial: function(errorCorrectLength) {
        var a = new Polynomial([
            1
        ], 0);
        for(var i = 0; i < errorCorrectLength; i++){
            a = a.multiply(new Polynomial([
                1,
                math.gexp(i)
            ], 0));
        }
        return a;
    },
    getLengthInBits: function(mode, type) {
        if (1 <= type && type < 10) {
            // 1 - 9
            switch(mode){
                case Mode.MODE_NUMBER:
                    return 10;
                case Mode.MODE_ALPHA_NUM:
                    return 9;
                case Mode.MODE_8BIT_BYTE:
                    return 8;
                case Mode.MODE_KANJI:
                    return 8;
                default:
                    throw new Error("mode:" + mode);
            }
        } else if (type < 27) {
            // 10 - 26
            switch(mode){
                case Mode.MODE_NUMBER:
                    return 12;
                case Mode.MODE_ALPHA_NUM:
                    return 11;
                case Mode.MODE_8BIT_BYTE:
                    return 16;
                case Mode.MODE_KANJI:
                    return 10;
                default:
                    throw new Error("mode:" + mode);
            }
        } else if (type < 41) {
            // 27 - 40
            switch(mode){
                case Mode.MODE_NUMBER:
                    return 14;
                case Mode.MODE_ALPHA_NUM:
                    return 13;
                case Mode.MODE_8BIT_BYTE:
                    return 16;
                case Mode.MODE_KANJI:
                    return 12;
                default:
                    throw new Error("mode:" + mode);
            }
        } else {
            throw new Error("type:" + type);
        }
    },
    getLostPoint: function(qrCode) {
        var moduleCount = qrCode.getModuleCount();
        var lostPoint = 0;
        // LEVEL1
        for(var row = 0; row < moduleCount; row++){
            for(var col = 0; col < moduleCount; col++){
                var sameCount = 0;
                var dark = qrCode.isDark(row, col);
                for(var r = -1; r <= 1; r++){
                    if (row + r < 0 || moduleCount <= row + r) {
                        continue;
                    }
                    for(var c = -1; c <= 1; c++){
                        if (col + c < 0 || moduleCount <= col + c) {
                            continue;
                        }
                        if (r == 0 && c == 0) {
                            continue;
                        }
                        if (dark == qrCode.isDark(row + r, col + c)) {
                            sameCount++;
                        }
                    }
                }
                if (sameCount > 5) {
                    lostPoint += 3 + sameCount - 5;
                }
            }
        }
        // LEVEL2
        for(var row = 0; row < moduleCount - 1; row++){
            for(var col = 0; col < moduleCount - 1; col++){
                var count = 0;
                if (qrCode.isDark(row, col)) count++;
                if (qrCode.isDark(row + 1, col)) count++;
                if (qrCode.isDark(row, col + 1)) count++;
                if (qrCode.isDark(row + 1, col + 1)) count++;
                if (count == 0 || count == 4) {
                    lostPoint += 3;
                }
            }
        }
        // LEVEL3
        for(var row = 0; row < moduleCount; row++){
            for(var col = 0; col < moduleCount - 6; col++){
                if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
                    lostPoint += 40;
                }
            }
        }
        for(var col = 0; col < moduleCount; col++){
            for(var row = 0; row < moduleCount - 6; row++){
                if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
                    lostPoint += 40;
                }
            }
        }
        // LEVEL4
        var darkCount = 0;
        for(var col = 0; col < moduleCount; col++){
            for(var row = 0; row < moduleCount; row++){
                if (qrCode.isDark(row, col)) {
                    darkCount++;
                }
            }
        }
        var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
        lostPoint += ratio * 10;
        return lostPoint;
    }
};
module.exports = QRUtil;
}}),
"[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/QRCode.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var BitByte = __turbopack_context__.r("[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/8BitByte.js [app-ssr] (ecmascript)");
var RSBlock = __turbopack_context__.r("[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/RSBlock.js [app-ssr] (ecmascript)");
var BitBuffer = __turbopack_context__.r("[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/BitBuffer.js [app-ssr] (ecmascript)");
var util = __turbopack_context__.r("[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/util.js [app-ssr] (ecmascript)");
var Polynomial = __turbopack_context__.r("[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/Polynomial.js [app-ssr] (ecmascript)");
function QRCode(typeNumber, errorCorrectLevel) {
    this.typeNumber = typeNumber;
    this.errorCorrectLevel = errorCorrectLevel;
    this.modules = null;
    this.moduleCount = 0;
    this.dataCache = null;
    this.dataList = [];
}
// for client side minification
var proto = QRCode.prototype;
proto.addData = function(data) {
    var newData = new BitByte(data);
    this.dataList.push(newData);
    this.dataCache = null;
};
proto.isDark = function(row, col) {
    if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
        throw new Error(row + "," + col);
    }
    return this.modules[row][col];
};
proto.getModuleCount = function() {
    return this.moduleCount;
};
proto.make = function() {
    // Calculate automatically typeNumber if provided is < 1
    if (this.typeNumber < 1) {
        var typeNumber = 1;
        for(typeNumber = 1; typeNumber < 40; typeNumber++){
            var rsBlocks = RSBlock.getRSBlocks(typeNumber, this.errorCorrectLevel);
            var buffer = new BitBuffer();
            var totalDataCount = 0;
            for(var i = 0; i < rsBlocks.length; i++){
                totalDataCount += rsBlocks[i].dataCount;
            }
            for(var i = 0; i < this.dataList.length; i++){
                var data = this.dataList[i];
                buffer.put(data.mode, 4);
                buffer.put(data.getLength(), util.getLengthInBits(data.mode, typeNumber));
                data.write(buffer);
            }
            if (buffer.getLengthInBits() <= totalDataCount * 8) break;
        }
        this.typeNumber = typeNumber;
    }
    this.makeImpl(false, this.getBestMaskPattern());
};
proto.makeImpl = function(test, maskPattern) {
    this.moduleCount = this.typeNumber * 4 + 17;
    this.modules = new Array(this.moduleCount);
    for(var row = 0; row < this.moduleCount; row++){
        this.modules[row] = new Array(this.moduleCount);
        for(var col = 0; col < this.moduleCount; col++){
            this.modules[row][col] = null; //(col + row) % 3;
        }
    }
    this.setupPositionProbePattern(0, 0);
    this.setupPositionProbePattern(this.moduleCount - 7, 0);
    this.setupPositionProbePattern(0, this.moduleCount - 7);
    this.setupPositionAdjustPattern();
    this.setupTimingPattern();
    this.setupTypeInfo(test, maskPattern);
    if (this.typeNumber >= 7) {
        this.setupTypeNumber(test);
    }
    if (this.dataCache == null) {
        this.dataCache = QRCode.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
    }
    this.mapData(this.dataCache, maskPattern);
};
proto.setupPositionProbePattern = function(row, col) {
    for(var r = -1; r <= 7; r++){
        if (row + r <= -1 || this.moduleCount <= row + r) continue;
        for(var c = -1; c <= 7; c++){
            if (col + c <= -1 || this.moduleCount <= col + c) continue;
            if (0 <= r && r <= 6 && (c == 0 || c == 6) || 0 <= c && c <= 6 && (r == 0 || r == 6) || 2 <= r && r <= 4 && 2 <= c && c <= 4) {
                this.modules[row + r][col + c] = true;
            } else {
                this.modules[row + r][col + c] = false;
            }
        }
    }
};
proto.getBestMaskPattern = function() {
    var minLostPoint = 0;
    var pattern = 0;
    for(var i = 0; i < 8; i++){
        this.makeImpl(true, i);
        var lostPoint = util.getLostPoint(this);
        if (i == 0 || minLostPoint > lostPoint) {
            minLostPoint = lostPoint;
            pattern = i;
        }
    }
    return pattern;
};
proto.createMovieClip = function(target_mc, instance_name, depth) {
    var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
    var cs = 1;
    this.make();
    for(var row = 0; row < this.modules.length; row++){
        var y = row * cs;
        for(var col = 0; col < this.modules[row].length; col++){
            var x = col * cs;
            var dark = this.modules[row][col];
            if (dark) {
                qr_mc.beginFill(0, 100);
                qr_mc.moveTo(x, y);
                qr_mc.lineTo(x + cs, y);
                qr_mc.lineTo(x + cs, y + cs);
                qr_mc.lineTo(x, y + cs);
                qr_mc.endFill();
            }
        }
    }
    return qr_mc;
};
proto.setupTimingPattern = function() {
    for(var r = 8; r < this.moduleCount - 8; r++){
        if (this.modules[r][6] != null) {
            continue;
        }
        this.modules[r][6] = r % 2 == 0;
    }
    for(var c = 8; c < this.moduleCount - 8; c++){
        if (this.modules[6][c] != null) {
            continue;
        }
        this.modules[6][c] = c % 2 == 0;
    }
};
proto.setupPositionAdjustPattern = function() {
    var pos = util.getPatternPosition(this.typeNumber);
    for(var i = 0; i < pos.length; i++){
        for(var j = 0; j < pos.length; j++){
            var row = pos[i];
            var col = pos[j];
            if (this.modules[row][col] != null) {
                continue;
            }
            for(var r = -2; r <= 2; r++){
                for(var c = -2; c <= 2; c++){
                    if (r == -2 || r == 2 || c == -2 || c == 2 || r == 0 && c == 0) {
                        this.modules[row + r][col + c] = true;
                    } else {
                        this.modules[row + r][col + c] = false;
                    }
                }
            }
        }
    }
};
proto.setupTypeNumber = function(test) {
    var bits = util.getBCHTypeNumber(this.typeNumber);
    for(var i = 0; i < 18; i++){
        var mod = !test && (bits >> i & 1) == 1;
        this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod;
    }
    for(var i = 0; i < 18; i++){
        var mod = !test && (bits >> i & 1) == 1;
        this.modules[i % 3 + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
    }
};
proto.setupTypeInfo = function(test, maskPattern) {
    var data = this.errorCorrectLevel << 3 | maskPattern;
    var bits = util.getBCHTypeInfo(data);
    // vertical		
    for(var i = 0; i < 15; i++){
        var mod = !test && (bits >> i & 1) == 1;
        if (i < 6) {
            this.modules[i][8] = mod;
        } else if (i < 8) {
            this.modules[i + 1][8] = mod;
        } else {
            this.modules[this.moduleCount - 15 + i][8] = mod;
        }
    }
    // horizontal
    for(var i = 0; i < 15; i++){
        var mod = !test && (bits >> i & 1) == 1;
        if (i < 8) {
            this.modules[8][this.moduleCount - i - 1] = mod;
        } else if (i < 9) {
            this.modules[8][15 - i - 1 + 1] = mod;
        } else {
            this.modules[8][15 - i - 1] = mod;
        }
    }
    // fixed module
    this.modules[this.moduleCount - 8][8] = !test;
};
proto.mapData = function(data, maskPattern) {
    var inc = -1;
    var row = this.moduleCount - 1;
    var bitIndex = 7;
    var byteIndex = 0;
    for(var col = this.moduleCount - 1; col > 0; col -= 2){
        if (col == 6) col--;
        while(true){
            for(var c = 0; c < 2; c++){
                if (this.modules[row][col - c] == null) {
                    var dark = false;
                    if (byteIndex < data.length) {
                        dark = (data[byteIndex] >>> bitIndex & 1) == 1;
                    }
                    var mask = util.getMask(maskPattern, row, col - c);
                    if (mask) {
                        dark = !dark;
                    }
                    this.modules[row][col - c] = dark;
                    bitIndex--;
                    if (bitIndex == -1) {
                        byteIndex++;
                        bitIndex = 7;
                    }
                }
            }
            row += inc;
            if (row < 0 || this.moduleCount <= row) {
                row -= inc;
                inc = -inc;
                break;
            }
        }
    }
};
QRCode.PAD0 = 0xEC;
QRCode.PAD1 = 0x11;
QRCode.createData = function(typeNumber, errorCorrectLevel, dataList) {
    var rsBlocks = RSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
    var buffer = new BitBuffer();
    for(var i = 0; i < dataList.length; i++){
        var data = dataList[i];
        buffer.put(data.mode, 4);
        buffer.put(data.getLength(), util.getLengthInBits(data.mode, typeNumber));
        data.write(buffer);
    }
    // calc num max data.
    var totalDataCount = 0;
    for(var i = 0; i < rsBlocks.length; i++){
        totalDataCount += rsBlocks[i].dataCount;
    }
    if (buffer.getLengthInBits() > totalDataCount * 8) {
        throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")");
    }
    // end code
    if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
        buffer.put(0, 4);
    }
    // padding
    while(buffer.getLengthInBits() % 8 != 0){
        buffer.putBit(false);
    }
    // padding
    while(true){
        if (buffer.getLengthInBits() >= totalDataCount * 8) {
            break;
        }
        buffer.put(QRCode.PAD0, 8);
        if (buffer.getLengthInBits() >= totalDataCount * 8) {
            break;
        }
        buffer.put(QRCode.PAD1, 8);
    }
    return QRCode.createBytes(buffer, rsBlocks);
};
QRCode.createBytes = function(buffer, rsBlocks) {
    var offset = 0;
    var maxDcCount = 0;
    var maxEcCount = 0;
    var dcdata = new Array(rsBlocks.length);
    var ecdata = new Array(rsBlocks.length);
    for(var r = 0; r < rsBlocks.length; r++){
        var dcCount = rsBlocks[r].dataCount;
        var ecCount = rsBlocks[r].totalCount - dcCount;
        maxDcCount = Math.max(maxDcCount, dcCount);
        maxEcCount = Math.max(maxEcCount, ecCount);
        dcdata[r] = new Array(dcCount);
        for(var i = 0; i < dcdata[r].length; i++){
            dcdata[r][i] = 0xff & buffer.buffer[i + offset];
        }
        offset += dcCount;
        var rsPoly = util.getErrorCorrectPolynomial(ecCount);
        var rawPoly = new Polynomial(dcdata[r], rsPoly.getLength() - 1);
        var modPoly = rawPoly.mod(rsPoly);
        ecdata[r] = new Array(rsPoly.getLength() - 1);
        for(var i = 0; i < ecdata[r].length; i++){
            var modIndex = i + modPoly.getLength() - ecdata[r].length;
            ecdata[r][i] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
        }
    }
    var totalCodeCount = 0;
    for(var i = 0; i < rsBlocks.length; i++){
        totalCodeCount += rsBlocks[i].totalCount;
    }
    var data = new Array(totalCodeCount);
    var index = 0;
    for(var i = 0; i < maxDcCount; i++){
        for(var r = 0; r < rsBlocks.length; r++){
            if (i < dcdata[r].length) {
                data[index++] = dcdata[r][i];
            }
        }
    }
    for(var i = 0; i < maxEcCount; i++){
        for(var r = 0; r < rsBlocks.length; r++){
            if (i < ecdata[r].length) {
                data[index++] = ecdata[r][i];
            }
        }
    }
    return data;
};
module.exports = QRCode;
}}),
"[project]/node_modules/.pnpm/qrcode.react@1.0.1_react@19.0.0/node_modules/qrcode.react/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof(obj);
}
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys(source, true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys(source).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized(self);
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var React = __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.2.3_@babel+core@7.26.10_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var PropTypes = __turbopack_context__.r("[project]/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js [app-ssr] (ecmascript)"); // qr.js doesn't handle error level of zero (M) so we need to do it right,
// thus the deep require.
var QRCodeImpl = __turbopack_context__.r("[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/QRCode.js [app-ssr] (ecmascript)");
var ErrorCorrectLevel = __turbopack_context__.r("[project]/node_modules/.pnpm/qr.js@0.0.0/node_modules/qr.js/lib/ErrorCorrectLevel.js [app-ssr] (ecmascript)"); // TODO: pull this off of the QRCode class type so it matches.
// Convert from UTF-16, forcing the use of byte-mode encoding in our QR Code.
// This allows us to encode Hanji, Kanji, emoji, etc. Ideally we'd do more
// detection and not resort to byte-mode if possible, but we're trading off
// a smaller library for a smaller amount of data we can potentially encode.
// Based on http://jonisalonen.com/2012/from-utf-16-to-utf-8-in-javascript/
function convertStr(str) {
    var out = '';
    for(var i = 0; i < str.length; i++){
        var charcode = str.charCodeAt(i);
        if (charcode < 0x0080) {
            out += String.fromCharCode(charcode);
        } else if (charcode < 0x0800) {
            out += String.fromCharCode(0xc0 | charcode >> 6);
            out += String.fromCharCode(0x80 | charcode & 0x3f);
        } else if (charcode < 0xd800 || charcode >= 0xe000) {
            out += String.fromCharCode(0xe0 | charcode >> 12);
            out += String.fromCharCode(0x80 | charcode >> 6 & 0x3f);
            out += String.fromCharCode(0x80 | charcode & 0x3f);
        } else {
            // This is a surrogate pair, so we'll reconsitute the pieces and work
            // from that
            i++;
            charcode = 0x10000 + ((charcode & 0x3ff) << 10 | str.charCodeAt(i) & 0x3ff);
            out += String.fromCharCode(0xf0 | charcode >> 18);
            out += String.fromCharCode(0x80 | charcode >> 12 & 0x3f);
            out += String.fromCharCode(0x80 | charcode >> 6 & 0x3f);
            out += String.fromCharCode(0x80 | charcode & 0x3f);
        }
    }
    return out;
}
var DEFAULT_PROPS = {
    size: 128,
    level: 'L',
    bgColor: '#FFFFFF',
    fgColor: '#000000',
    includeMargin: false
};
var PROP_TYPES = ("TURBOPACK compile-time truthy", 1) ? {
    value: PropTypes.string.isRequired,
    size: PropTypes.number,
    level: PropTypes.oneOf([
        'L',
        'M',
        'Q',
        'H'
    ]),
    bgColor: PropTypes.string,
    fgColor: PropTypes.string,
    includeMargin: PropTypes.bool,
    imageSettings: PropTypes.shape({
        src: PropTypes.string.isRequired,
        height: PropTypes.number.isRequired,
        width: PropTypes.number.isRequired,
        excavate: PropTypes.bool,
        x: PropTypes.number,
        y: PropTypes.number
    })
} : ("TURBOPACK unreachable", undefined);
var MARGIN_SIZE = 4; // This is *very* rough estimate of max amount of QRCode allowed to be covered.
// It is "wrong" in a lot of ways (area is a terrible way to estimate, it
// really should be number of modules covered), but if for some reason we don't
// get an explicit height or width, I'd rather default to something than throw.
var DEFAULT_IMG_SCALE = 0.1;
function generatePath(modules) {
    var margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var ops = [];
    modules.forEach(function(row, y) {
        var start = null;
        row.forEach(function(cell, x) {
            if (!cell && start !== null) {
                // M0 0h7v1H0z injects the space with the move and drops the comma,
                // saving a char per operation
                ops.push("M".concat(start + margin, " ").concat(y + margin, "h").concat(x - start, "v1H").concat(start + margin, "z"));
                start = null;
                return;
            } // end of row, clean up or skip
            if (x === row.length - 1) {
                if (!cell) {
                    // We would have closed the op above already so this can only mean
                    // 2+ light modules in a row.
                    return;
                }
                if (start === null) {
                    // Just a single dark module.
                    ops.push("M".concat(x + margin, ",").concat(y + margin, " h1v1H").concat(x + margin, "z"));
                } else {
                    // Otherwise finish the current line.
                    ops.push("M".concat(start + margin, ",").concat(y + margin, " h").concat(x + 1 - start, "v1H").concat(start + margin, "z"));
                }
                return;
            }
            if (cell && start === null) {
                start = x;
            }
        });
    });
    return ops.join('');
} // We could just do this in generatePath, except that we want to support
// non-Path2D canvas, so we need to keep it an explicit step.
function excavateModules(modules, excavation) {
    return modules.slice().map(function(row, y) {
        if (y < excavation.y || y >= excavation.y + excavation.h) {
            return row;
        }
        return row.map(function(cell, x) {
            if (x < excavation.x || x >= excavation.x + excavation.w) {
                return cell;
            }
            return false;
        });
    });
}
function getImageSettings(props, cells) {
    var imageSettings = props.imageSettings, size = props.size, includeMargin = props.includeMargin;
    if (imageSettings == null) {
        return null;
    }
    var margin = includeMargin ? MARGIN_SIZE : 0;
    var numCells = cells.length + margin * 2;
    var defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
    var scale = numCells / size;
    var w = (imageSettings.width || defaultSize) * scale;
    var h = (imageSettings.height || defaultSize) * scale;
    var x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;
    var y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;
    var excavation = null;
    if (imageSettings.excavate) {
        var floorX = Math.floor(x);
        var floorY = Math.floor(y);
        var ceilW = Math.ceil(w + x - floorX);
        var ceilH = Math.ceil(h + y - floorY);
        excavation = {
            x: floorX,
            y: floorY,
            w: ceilW,
            h: ceilH
        };
    }
    return {
        x: x,
        y: y,
        h: h,
        w: w,
        excavation: excavation
    };
} // For canvas we're going to switch our drawing mode based on whether or not
// the environment supports Path2D. We only need the constructor to be
// supported, but Edge doesn't actually support the path (string) type
// argument. Luckily it also doesn't support the addPath() method. We can
// treat that as the same thing.
var SUPPORTS_PATH2D = function() {
    try {
        new Path2D().addPath(new Path2D());
    } catch (e) {
        return false;
    }
    return true;
}();
var QRCodeCanvas = /*#__PURE__*/ function(_React$PureComponent) {
    _inherits(QRCodeCanvas, _React$PureComponent);
    function QRCodeCanvas() {
        var _getPrototypeOf2;
        var _this;
        _classCallCheck(this, QRCodeCanvas);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(QRCodeCanvas)).call.apply(_getPrototypeOf2, [
            this
        ].concat(args)));
        _defineProperty(_assertThisInitialized(_this), "_canvas", void 0);
        _defineProperty(_assertThisInitialized(_this), "_image", void 0);
        _defineProperty(_assertThisInitialized(_this), "state", {
            imgLoaded: false
        });
        _defineProperty(_assertThisInitialized(_this), "handleImageLoad", function() {
            _this.setState({
                imgLoaded: true
            });
        });
        return _this;
    }
    _createClass(QRCodeCanvas, [
        {
            key: "componentDidMount",
            value: function componentDidMount() {
                if (this._image && this._image.complete) {
                    this.handleImageLoad();
                }
                this.update();
            }
        },
        {
            key: "componentWillReceiveProps",
            value: function componentWillReceiveProps(nextProps) {
                var _this$props$imageSett, _nextProps$imageSetti;
                var currentSrc = (_this$props$imageSett = this.props.imageSettings) === null || _this$props$imageSett === void 0 ? void 0 : _this$props$imageSett.src;
                var nextSrc = (_nextProps$imageSetti = nextProps.imageSettings) === null || _nextProps$imageSetti === void 0 ? void 0 : _nextProps$imageSetti.src;
                if (currentSrc !== nextSrc) {
                    this.setState({
                        imgLoaded: false
                    });
                }
            }
        },
        {
            key: "componentDidUpdate",
            value: function componentDidUpdate() {
                this.update();
            }
        },
        {
            key: "update",
            value: function update() {
                var _this$props = this.props, value = _this$props.value, size = _this$props.size, level = _this$props.level, bgColor = _this$props.bgColor, fgColor = _this$props.fgColor, includeMargin = _this$props.includeMargin, imageSettings = _this$props.imageSettings; // We'll use type===-1 to force QRCode to automatically pick the best type
                var qrcode = new QRCodeImpl(-1, ErrorCorrectLevel[level]);
                qrcode.addData(convertStr(value));
                qrcode.make();
                if (this._canvas != null) {
                    var canvas = this._canvas;
                    var ctx = canvas.getContext('2d');
                    if (!ctx) {
                        return;
                    }
                    var cells = qrcode.modules;
                    if (cells === null) {
                        return;
                    }
                    var margin = includeMargin ? MARGIN_SIZE : 0;
                    var numCells = cells.length + margin * 2;
                    var calculatedImageSettings = getImageSettings(this.props, cells);
                    if (imageSettings != null && calculatedImageSettings != null) {
                        if (calculatedImageSettings.excavation != null) {
                            cells = excavateModules(cells, calculatedImageSettings.excavation);
                        }
                    } // We're going to scale this so that the number of drawable units
                    // matches the number of cells. This avoids rounding issues, but does
                    // result in some potentially unwanted single pixel issues between
                    // blocks, only in environments that don't support Path2D.
                    var pixelRatio = window.devicePixelRatio || 1;
                    canvas.height = canvas.width = size * pixelRatio;
                    var scale = size / numCells * pixelRatio;
                    ctx.scale(scale, scale); // Draw solid background, only paint dark modules.
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(0, 0, numCells, numCells);
                    ctx.fillStyle = fgColor;
                    if (SUPPORTS_PATH2D) {
                        // $FlowFixMe: Path2D c'tor doesn't support args yet.
                        ctx.fill(new Path2D(generatePath(cells, margin)));
                    } else {
                        cells.forEach(function(row, rdx) {
                            row.forEach(function(cell, cdx) {
                                if (cell) {
                                    ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
                                }
                            });
                        });
                    }
                    if (this.state.imgLoaded && this._image && calculatedImageSettings != null) {
                        ctx.drawImage(this._image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);
                    }
                }
            }
        },
        {
            key: "render",
            value: function render() {
                var _this2 = this;
                var _this$props2 = this.props, value = _this$props2.value, size = _this$props2.size, level = _this$props2.level, bgColor = _this$props2.bgColor, fgColor = _this$props2.fgColor, style = _this$props2.style, includeMargin = _this$props2.includeMargin, imageSettings = _this$props2.imageSettings, otherProps = _objectWithoutProperties(_this$props2, [
                    "value",
                    "size",
                    "level",
                    "bgColor",
                    "fgColor",
                    "style",
                    "includeMargin",
                    "imageSettings"
                ]);
                var canvasStyle = _objectSpread({
                    height: size,
                    width: size
                }, style);
                var img = null;
                var imgSrc = imageSettings && imageSettings.src;
                if (imageSettings != null && imgSrc != null) {
                    img = React.createElement("img", {
                        src: imgSrc,
                        style: {
                            display: 'none'
                        },
                        onLoad: this.handleImageLoad,
                        ref: function ref(_ref) {
                            return _this2._image = _ref;
                        }
                    });
                }
                return React.createElement(React.Fragment, null, React.createElement("canvas", _extends({
                    style: canvasStyle,
                    height: size,
                    width: size,
                    ref: function ref(_ref2) {
                        return _this2._canvas = _ref2;
                    }
                }, otherProps)), img);
            }
        }
    ]);
    return QRCodeCanvas;
}(React.PureComponent);
_defineProperty(QRCodeCanvas, "defaultProps", DEFAULT_PROPS);
if ("TURBOPACK compile-time truthy", 1) {
    QRCodeCanvas.propTypes = PROP_TYPES;
}
var QRCodeSVG = /*#__PURE__*/ function(_React$PureComponent2) {
    _inherits(QRCodeSVG, _React$PureComponent2);
    function QRCodeSVG() {
        _classCallCheck(this, QRCodeSVG);
        return _possibleConstructorReturn(this, _getPrototypeOf(QRCodeSVG).apply(this, arguments));
    }
    _createClass(QRCodeSVG, [
        {
            key: "render",
            value: function render() {
                var _this$props3 = this.props, value = _this$props3.value, size = _this$props3.size, level = _this$props3.level, bgColor = _this$props3.bgColor, fgColor = _this$props3.fgColor, includeMargin = _this$props3.includeMargin, imageSettings = _this$props3.imageSettings, otherProps = _objectWithoutProperties(_this$props3, [
                    "value",
                    "size",
                    "level",
                    "bgColor",
                    "fgColor",
                    "includeMargin",
                    "imageSettings"
                ]); // We'll use type===-1 to force QRCode to automatically pick the best type
                var qrcode = new QRCodeImpl(-1, ErrorCorrectLevel[level]);
                qrcode.addData(convertStr(value));
                qrcode.make();
                var cells = qrcode.modules;
                if (cells === null) {
                    return null;
                }
                var margin = includeMargin ? MARGIN_SIZE : 0;
                var numCells = cells.length + margin * 2;
                var calculatedImageSettings = getImageSettings(this.props, cells);
                var image = null;
                if (imageSettings != null && calculatedImageSettings != null) {
                    if (calculatedImageSettings.excavation != null) {
                        cells = excavateModules(cells, calculatedImageSettings.excavation);
                    }
                    image = React.createElement("image", {
                        xlinkHref: imageSettings.src,
                        height: calculatedImageSettings.h,
                        width: calculatedImageSettings.w,
                        x: calculatedImageSettings.x + margin,
                        y: calculatedImageSettings.y + margin,
                        preserveAspectRatio: "none"
                    });
                } // Drawing strategy: instead of a rect per module, we're going to create a
                // single path for the dark modules and layer that on top of a light rect,
                // for a total of 2 DOM nodes. We pay a bit more in string concat but that's
                // way faster than DOM ops.
                // For level 1, 441 nodes -> 2
                // For level 40, 31329 -> 2
                var fgPath = generatePath(cells, margin);
                return React.createElement("svg", _extends({
                    shapeRendering: "crispEdges",
                    height: size,
                    width: size,
                    viewBox: "0 0 ".concat(numCells, " ").concat(numCells)
                }, otherProps), React.createElement("path", {
                    fill: bgColor,
                    d: "M0,0 h".concat(numCells, "v").concat(numCells, "H0z")
                }), React.createElement("path", {
                    fill: fgColor,
                    d: fgPath
                }), image);
            }
        }
    ]);
    return QRCodeSVG;
}(React.PureComponent);
_defineProperty(QRCodeSVG, "defaultProps", DEFAULT_PROPS);
if ("TURBOPACK compile-time truthy", 1) {
    QRCodeSVG.propTypes = PROP_TYPES;
}
var QRCode = function QRCode(props) {
    var renderAs = props.renderAs, otherProps = _objectWithoutProperties(props, [
        "renderAs"
    ]);
    var Component = renderAs === 'svg' ? QRCodeSVG : QRCodeCanvas;
    return React.createElement(Component, otherProps);
};
QRCode.defaultProps = _objectSpread({
    renderAs: 'canvas'
}, DEFAULT_PROPS);
module.exports = QRCode;
}}),
"[project]/node_modules/.pnpm/sdp@2.12.0/node_modules/sdp/sdp.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* eslint-env node */ 'use strict';
// SDP helpers.
var SDPUtils = {};
// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
    return Math.random().toString(36).substr(2, 10);
};
// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();
// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
    return blob.trim().split('\n').map(function(line) {
        return line.trim();
    });
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
    var parts = blob.split('\nm=');
    return parts.map(function(part, index) {
        return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
    });
};
// returns the session description.
SDPUtils.getDescription = function(blob) {
    var sections = SDPUtils.splitSections(blob);
    return sections && sections[0];
};
// returns the individual media sections.
SDPUtils.getMediaSections = function(blob) {
    var sections = SDPUtils.splitSections(blob);
    sections.shift();
    return sections;
};
// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
    return SDPUtils.splitLines(blob).filter(function(line) {
        return line.indexOf(prefix) === 0;
    });
};
// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
SDPUtils.parseCandidate = function(line) {
    var parts;
    // Parse both variants.
    if (line.indexOf('a=candidate:') === 0) {
        parts = line.substring(12).split(' ');
    } else {
        parts = line.substring(10).split(' ');
    }
    var candidate = {
        foundation: parts[0],
        component: parseInt(parts[1], 10),
        protocol: parts[2].toLowerCase(),
        priority: parseInt(parts[3], 10),
        ip: parts[4],
        address: parts[4],
        port: parseInt(parts[5], 10),
        // skip parts[6] == 'typ'
        type: parts[7]
    };
    for(var i = 8; i < parts.length; i += 2){
        switch(parts[i]){
            case 'raddr':
                candidate.relatedAddress = parts[i + 1];
                break;
            case 'rport':
                candidate.relatedPort = parseInt(parts[i + 1], 10);
                break;
            case 'tcptype':
                candidate.tcpType = parts[i + 1];
                break;
            case 'ufrag':
                candidate.ufrag = parts[i + 1]; // for backward compability.
                candidate.usernameFragment = parts[i + 1];
                break;
            default:
                candidate[parts[i]] = parts[i + 1];
                break;
        }
    }
    return candidate;
};
// Translates a candidate object into SDP candidate attribute.
SDPUtils.writeCandidate = function(candidate) {
    var sdp = [];
    sdp.push(candidate.foundation);
    sdp.push(candidate.component);
    sdp.push(candidate.protocol.toUpperCase());
    sdp.push(candidate.priority);
    sdp.push(candidate.address || candidate.ip);
    sdp.push(candidate.port);
    var type = candidate.type;
    sdp.push('typ');
    sdp.push(type);
    if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {
        sdp.push('raddr');
        sdp.push(candidate.relatedAddress);
        sdp.push('rport');
        sdp.push(candidate.relatedPort);
    }
    if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
        sdp.push('tcptype');
        sdp.push(candidate.tcpType);
    }
    if (candidate.usernameFragment || candidate.ufrag) {
        sdp.push('ufrag');
        sdp.push(candidate.usernameFragment || candidate.ufrag);
    }
    return 'candidate:' + sdp.join(' ');
};
// Parses an ice-options line, returns an array of option tags.
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
    return line.substr(14).split(' ');
};
// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
    var parts = line.substr(9).split(' ');
    var parsed = {
        payloadType: parseInt(parts.shift(), 10) // was: id
    };
    parts = parts[0].split('/');
    parsed.name = parts[0];
    parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
    parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
    // legacy alias, got renamed back to channels in ORTC.
    parsed.numChannels = parsed.channels;
    return parsed;
};
// Generate an a=rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
    var pt = codec.payloadType;
    if (codec.preferredPayloadType !== undefined) {
        pt = codec.preferredPayloadType;
    }
    var channels = codec.channels || codec.numChannels || 1;
    return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (channels !== 1 ? '/' + channels : '') + '\r\n';
};
// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
    var parts = line.substr(9).split(' ');
    return {
        id: parseInt(parts[0], 10),
        direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
        uri: parts[1]
    };
};
// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
    return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + '\r\n';
};
// Parses an ftmp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
    var parsed = {};
    var kv;
    var parts = line.substr(line.indexOf(' ') + 1).split(';');
    for(var j = 0; j < parts.length; j++){
        kv = parts[j].trim().split('=');
        parsed[kv[0].trim()] = kv[1];
    }
    return parsed;
};
// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
    var line = '';
    var pt = codec.payloadType;
    if (codec.preferredPayloadType !== undefined) {
        pt = codec.preferredPayloadType;
    }
    if (codec.parameters && Object.keys(codec.parameters).length) {
        var params = [];
        Object.keys(codec.parameters).forEach(function(param) {
            if (codec.parameters[param]) {
                params.push(param + '=' + codec.parameters[param]);
            } else {
                params.push(param);
            }
        });
        line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
    }
    return line;
};
// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
    var parts = line.substr(line.indexOf(' ') + 1).split(' ');
    return {
        type: parts.shift(),
        parameter: parts.join(' ')
    };
};
// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
    var lines = '';
    var pt = codec.payloadType;
    if (codec.preferredPayloadType !== undefined) {
        pt = codec.preferredPayloadType;
    }
    if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
        // FIXME: special handling for trr-int?
        codec.rtcpFeedback.forEach(function(fb) {
            lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') + '\r\n';
        });
    }
    return lines;
};
// Parses an RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
    var sp = line.indexOf(' ');
    var parts = {
        ssrc: parseInt(line.substr(7, sp - 7), 10)
    };
    var colon = line.indexOf(':', sp);
    if (colon > -1) {
        parts.attribute = line.substr(sp + 1, colon - sp - 1);
        parts.value = line.substr(colon + 1);
    } else {
        parts.attribute = line.substr(sp + 1);
    }
    return parts;
};
SDPUtils.parseSsrcGroup = function(line) {
    var parts = line.substr(13).split(' ');
    return {
        semantics: parts.shift(),
        ssrcs: parts.map(function(ssrc) {
            return parseInt(ssrc, 10);
        })
    };
};
// Extracts the MID (RFC 5888) from a media section.
// returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
    var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
    if (mid) {
        return mid.substr(6);
    }
};
SDPUtils.parseFingerprint = function(line) {
    var parts = line.substr(14).split(' ');
    return {
        algorithm: parts[0].toLowerCase(),
        value: parts[1]
    };
};
// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
    var lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:');
    // Note: a=setup line is ignored since we use the 'auto' role.
    // Note2: 'algorithm' is not case sensitive except in Edge.
    return {
        role: 'auto',
        fingerprints: lines.map(SDPUtils.parseFingerprint)
    };
};
// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
    var sdp = 'a=setup:' + setupType + '\r\n';
    params.fingerprints.forEach(function(fp) {
        sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
    });
    return sdp;
};
// Parses a=crypto lines into
//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members
SDPUtils.parseCryptoLine = function(line) {
    var parts = line.substr(9).split(' ');
    return {
        tag: parseInt(parts[0], 10),
        cryptoSuite: parts[1],
        keyParams: parts[2],
        sessionParams: parts.slice(3)
    };
};
SDPUtils.writeCryptoLine = function(parameters) {
    return 'a=crypto:' + parameters.tag + ' ' + parameters.cryptoSuite + ' ' + (typeof parameters.keyParams === 'object' ? SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') + '\r\n';
};
// Parses the crypto key parameters into
//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*
SDPUtils.parseCryptoKeyParams = function(keyParams) {
    if (keyParams.indexOf('inline:') !== 0) {
        return null;
    }
    var parts = keyParams.substr(7).split('|');
    return {
        keyMethod: 'inline',
        keySalt: parts[0],
        lifeTime: parts[1],
        mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,
        mkiLength: parts[2] ? parts[2].split(':')[1] : undefined
    };
};
SDPUtils.writeCryptoKeyParams = function(keyParams) {
    return keyParams.keyMethod + ':' + keyParams.keySalt + (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') + (keyParams.mkiValue && keyParams.mkiLength ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength : '');
};
// Extracts all SDES paramters.
SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {
    var lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=crypto:');
    return lines.map(SDPUtils.parseCryptoLine);
};
// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
    var ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-ufrag:')[0];
    var pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-pwd:')[0];
    if (!(ufrag && pwd)) {
        return null;
    }
    return {
        usernameFragment: ufrag.substr(12),
        password: pwd.substr(10)
    };
};
// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
    return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' + 'a=ice-pwd:' + params.password + '\r\n';
};
// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
    var description = {
        codecs: [],
        headerExtensions: [],
        fecMechanisms: [],
        rtcp: []
    };
    var lines = SDPUtils.splitLines(mediaSection);
    var mline = lines[0].split(' ');
    for(var i = 3; i < mline.length; i++){
        var pt = mline[i];
        var rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];
        if (rtpmapline) {
            var codec = SDPUtils.parseRtpMap(rtpmapline);
            var fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' ');
            // Only the first a=fmtp:<pt> is considered.
            codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
            codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ').map(SDPUtils.parseRtcpFb);
            description.codecs.push(codec);
            // parse FEC mechanisms from rtpmap lines.
            switch(codec.name.toUpperCase()){
                case 'RED':
                case 'ULPFEC':
                    description.fecMechanisms.push(codec.name.toUpperCase());
                    break;
                default:
                    break;
            }
        }
    }
    SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
        description.headerExtensions.push(SDPUtils.parseExtmap(line));
    });
    // FIXME: parse rtcp.
    return description;
};
// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
    var sdp = '';
    // Build the mline.
    sdp += 'm=' + kind + ' ';
    sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
    sdp += ' UDP/TLS/RTP/SAVPF ';
    sdp += caps.codecs.map(function(codec) {
        if (codec.preferredPayloadType !== undefined) {
            return codec.preferredPayloadType;
        }
        return codec.payloadType;
    }).join(' ') + '\r\n';
    sdp += 'c=IN IP4 0.0.0.0\r\n';
    sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';
    // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
    caps.codecs.forEach(function(codec) {
        sdp += SDPUtils.writeRtpMap(codec);
        sdp += SDPUtils.writeFmtp(codec);
        sdp += SDPUtils.writeRtcpFb(codec);
    });
    var maxptime = 0;
    caps.codecs.forEach(function(codec) {
        if (codec.maxptime > maxptime) {
            maxptime = codec.maxptime;
        }
    });
    if (maxptime > 0) {
        sdp += 'a=maxptime:' + maxptime + '\r\n';
    }
    sdp += 'a=rtcp-mux\r\n';
    if (caps.headerExtensions) {
        caps.headerExtensions.forEach(function(extension) {
            sdp += SDPUtils.writeExtmap(extension);
        });
    }
    // FIXME: write fecMechanisms.
    return sdp;
};
// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
    var encodingParameters = [];
    var description = SDPUtils.parseRtpParameters(mediaSection);
    var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
    var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;
    // filter a=ssrc:... cname:, ignore PlanB-msid
    var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function(line) {
        return SDPUtils.parseSsrcMedia(line);
    }).filter(function(parts) {
        return parts.attribute === 'cname';
    });
    var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
    var secondarySsrc;
    var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID').map(function(line) {
        var parts = line.substr(17).split(' ');
        return parts.map(function(part) {
            return parseInt(part, 10);
        });
    });
    if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
        secondarySsrc = flows[0][1];
    }
    description.codecs.forEach(function(codec) {
        if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
            var encParam = {
                ssrc: primarySsrc,
                codecPayloadType: parseInt(codec.parameters.apt, 10)
            };
            if (primarySsrc && secondarySsrc) {
                encParam.rtx = {
                    ssrc: secondarySsrc
                };
            }
            encodingParameters.push(encParam);
            if (hasRed) {
                encParam = JSON.parse(JSON.stringify(encParam));
                encParam.fec = {
                    ssrc: primarySsrc,
                    mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
                };
                encodingParameters.push(encParam);
            }
        }
    });
    if (encodingParameters.length === 0 && primarySsrc) {
        encodingParameters.push({
            ssrc: primarySsrc
        });
    }
    // we support both b=AS and b=TIAS but interpret AS as TIAS.
    var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
    if (bandwidth.length) {
        if (bandwidth[0].indexOf('b=TIAS:') === 0) {
            bandwidth = parseInt(bandwidth[0].substr(7), 10);
        } else if (bandwidth[0].indexOf('b=AS:') === 0) {
            // use formula from JSEP to convert b=AS to TIAS value.
            bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95 - 50 * 40 * 8;
        } else {
            bandwidth = undefined;
        }
        encodingParameters.forEach(function(params) {
            params.maxBitrate = bandwidth;
        });
    }
    return encodingParameters;
};
// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
    var rtcpParameters = {};
    // Gets the first SSRC. Note tha with RTX there might be multiple
    // SSRCs.
    var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function(line) {
        return SDPUtils.parseSsrcMedia(line);
    }).filter(function(obj) {
        return obj.attribute === 'cname';
    })[0];
    if (remoteSsrc) {
        rtcpParameters.cname = remoteSsrc.value;
        rtcpParameters.ssrc = remoteSsrc.ssrc;
    }
    // Edge uses the compound attribute instead of reducedSize
    // compound is !reducedSize
    var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
    rtcpParameters.reducedSize = rsize.length > 0;
    rtcpParameters.compound = rsize.length === 0;
    // parses the rtcp-mux attrіbute.
    // Note that Edge does not support unmuxed RTCP.
    var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
    rtcpParameters.mux = mux.length > 0;
    return rtcpParameters;
};
// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
    var parts;
    var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
    if (spec.length === 1) {
        parts = spec[0].substr(7).split(' ');
        return {
            stream: parts[0],
            track: parts[1]
        };
    }
    var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function(line) {
        return SDPUtils.parseSsrcMedia(line);
    }).filter(function(msidParts) {
        return msidParts.attribute === 'msid';
    });
    if (planB.length > 0) {
        parts = planB[0].value.split(' ');
        return {
            stream: parts[0],
            track: parts[1]
        };
    }
};
// SCTP
// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
// to draft-ietf-mmusic-sctp-sdp-05
SDPUtils.parseSctpDescription = function(mediaSection) {
    var mline = SDPUtils.parseMLine(mediaSection);
    var maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');
    var maxMessageSize;
    if (maxSizeLine.length > 0) {
        maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);
    }
    if (isNaN(maxMessageSize)) {
        maxMessageSize = 65536;
    }
    var sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');
    if (sctpPort.length > 0) {
        return {
            port: parseInt(sctpPort[0].substr(12), 10),
            protocol: mline.fmt,
            maxMessageSize: maxMessageSize
        };
    }
    var sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');
    if (sctpMapLines.length > 0) {
        var parts = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:')[0].substr(10).split(' ');
        return {
            port: parseInt(parts[0], 10),
            protocol: parts[1],
            maxMessageSize: maxMessageSize
        };
    }
};
// SCTP
// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
// support by now receiving in this format, unless we originally parsed
// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
// protocol of DTLS/SCTP -- without UDP/ or TCP/)
SDPUtils.writeSctpDescription = function(media, sctp) {
    var output = [];
    if (media.protocol !== 'DTLS/SCTP') {
        output = [
            'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\r\n',
            'c=IN IP4 0.0.0.0\r\n',
            'a=sctp-port:' + sctp.port + '\r\n'
        ];
    } else {
        output = [
            'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\r\n',
            'c=IN IP4 0.0.0.0\r\n',
            'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\r\n'
        ];
    }
    if (sctp.maxMessageSize !== undefined) {
        output.push('a=max-message-size:' + sctp.maxMessageSize + '\r\n');
    }
    return output.join('');
};
// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
    return Math.random().toString().substr(2, 21);
};
// Write boilder plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
// sessUser is optional and defaults to 'thisisadapterortc'
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
    var sessionId;
    var version = sessVer !== undefined ? sessVer : 2;
    if (sessId) {
        sessionId = sessId;
    } else {
        sessionId = SDPUtils.generateSessionId();
    }
    var user = sessUser || 'thisisadapterortc';
    // FIXME: sess-id should be an NTP timestamp.
    return 'v=0\r\n' + 'o=' + user + ' ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\r\n' + 's=-\r\n' + 't=0 0\r\n';
};
SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
    var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);
    // Map ICE parameters (ufrag, pwd) to SDP.
    sdp += SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters());
    // Map DTLS parameters to SDP.
    sdp += SDPUtils.writeDtlsParameters(transceiver.dtlsTransport.getLocalParameters(), type === 'offer' ? 'actpass' : 'active');
    sdp += 'a=mid:' + transceiver.mid + '\r\n';
    if (transceiver.direction) {
        sdp += 'a=' + transceiver.direction + '\r\n';
    } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
        sdp += 'a=sendrecv\r\n';
    } else if (transceiver.rtpSender) {
        sdp += 'a=sendonly\r\n';
    } else if (transceiver.rtpReceiver) {
        sdp += 'a=recvonly\r\n';
    } else {
        sdp += 'a=inactive\r\n';
    }
    if (transceiver.rtpSender) {
        // spec.
        var msid = 'msid:' + stream.id + ' ' + transceiver.rtpSender.track.id + '\r\n';
        sdp += 'a=' + msid;
        // for Chrome.
        sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' ' + msid;
        if (transceiver.sendEncodingParameters[0].rtx) {
            sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' ' + msid;
            sdp += 'a=ssrc-group:FID ' + transceiver.sendEncodingParameters[0].ssrc + ' ' + transceiver.sendEncodingParameters[0].rtx.ssrc + '\r\n';
        }
    }
    // FIXME: this should be written by writeRtpDescription.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' cname:' + SDPUtils.localCName + '\r\n';
    if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
        sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' cname:' + SDPUtils.localCName + '\r\n';
    }
    return sdp;
};
// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
    // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
    var lines = SDPUtils.splitLines(mediaSection);
    for(var i = 0; i < lines.length; i++){
        switch(lines[i]){
            case 'a=sendrecv':
            case 'a=sendonly':
            case 'a=recvonly':
            case 'a=inactive':
                return lines[i].substr(2);
            default:
        }
    }
    if (sessionpart) {
        return SDPUtils.getDirection(sessionpart);
    }
    return 'sendrecv';
};
SDPUtils.getKind = function(mediaSection) {
    var lines = SDPUtils.splitLines(mediaSection);
    var mline = lines[0].split(' ');
    return mline[0].substr(2);
};
SDPUtils.isRejected = function(mediaSection) {
    return mediaSection.split(' ', 2)[1] === '0';
};
SDPUtils.parseMLine = function(mediaSection) {
    var lines = SDPUtils.splitLines(mediaSection);
    var parts = lines[0].substr(2).split(' ');
    return {
        kind: parts[0],
        port: parseInt(parts[1], 10),
        protocol: parts[2],
        fmt: parts.slice(3).join(' ')
    };
};
SDPUtils.parseOLine = function(mediaSection) {
    var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
    var parts = line.substr(2).split(' ');
    return {
        username: parts[0],
        sessionId: parts[1],
        sessionVersion: parseInt(parts[2], 10),
        netType: parts[3],
        addressType: parts[4],
        address: parts[5]
    };
};
// a very naive interpretation of a valid SDP.
SDPUtils.isValidSDP = function(blob) {
    if (typeof blob !== 'string' || blob.length === 0) {
        return false;
    }
    var lines = SDPUtils.splitLines(blob);
    for(var i = 0; i < lines.length; i++){
        if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
            return false;
        }
    // TODO: check the modifier a bit more.
    }
    return true;
};
// Expose public methods.
if ("TURBOPACK compile-time truthy", 1) {
    module.exports = SDPUtils;
}
}}),
"[project]/node_modules/.pnpm/rtcpeerconnection-shim@1.2.15/node_modules/rtcpeerconnection-shim/rtcpeerconnection.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */ /* eslint-env node */ 'use strict';
var SDPUtils = __turbopack_context__.r("[project]/node_modules/.pnpm/sdp@2.12.0/node_modules/sdp/sdp.js [app-ssr] (ecmascript)");
function fixStatsType(stat) {
    return ({
        inboundrtp: 'inbound-rtp',
        outboundrtp: 'outbound-rtp',
        candidatepair: 'candidate-pair',
        localcandidate: 'local-candidate',
        remotecandidate: 'remote-candidate'
    })[stat.type] || stat.type;
}
function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
    var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);
    // Map ICE parameters (ufrag, pwd) to SDP.
    sdp += SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters());
    // Map DTLS parameters to SDP.
    sdp += SDPUtils.writeDtlsParameters(transceiver.dtlsTransport.getLocalParameters(), type === 'offer' ? 'actpass' : dtlsRole || 'active');
    sdp += 'a=mid:' + transceiver.mid + '\r\n';
    if (transceiver.rtpSender && transceiver.rtpReceiver) {
        sdp += 'a=sendrecv\r\n';
    } else if (transceiver.rtpSender) {
        sdp += 'a=sendonly\r\n';
    } else if (transceiver.rtpReceiver) {
        sdp += 'a=recvonly\r\n';
    } else {
        sdp += 'a=inactive\r\n';
    }
    if (transceiver.rtpSender) {
        var trackId = transceiver.rtpSender._initialTrackId || transceiver.rtpSender.track.id;
        transceiver.rtpSender._initialTrackId = trackId;
        // spec.
        var msid = 'msid:' + (stream ? stream.id : '-') + ' ' + trackId + '\r\n';
        sdp += 'a=' + msid;
        // for Chrome. Legacy should no longer be required.
        sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' ' + msid;
        // RTX
        if (transceiver.sendEncodingParameters[0].rtx) {
            sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' ' + msid;
            sdp += 'a=ssrc-group:FID ' + transceiver.sendEncodingParameters[0].ssrc + ' ' + transceiver.sendEncodingParameters[0].rtx.ssrc + '\r\n';
        }
    }
    // FIXME: this should be written by writeRtpDescription.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' cname:' + SDPUtils.localCName + '\r\n';
    if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
        sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' cname:' + SDPUtils.localCName + '\r\n';
    }
    return sdp;
}
// Edge does not like
// 1) stun: filtered after 14393 unless ?transport=udp is present
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
function filterIceServers(iceServers, edgeVersion) {
    var hasTurn = false;
    iceServers = JSON.parse(JSON.stringify(iceServers));
    return iceServers.filter(function(server) {
        if (server && (server.urls || server.url)) {
            var urls = server.urls || server.url;
            if (server.url && !server.urls) {
                console.warn('RTCIceServer.url is deprecated! Use urls instead.');
            }
            var isString = typeof urls === 'string';
            if (isString) {
                urls = [
                    urls
                ];
            }
            urls = urls.filter(function(url) {
                var validTurn = url.indexOf('turn:') === 0 && url.indexOf('transport=udp') !== -1 && url.indexOf('turn:[') === -1 && !hasTurn;
                if (validTurn) {
                    hasTurn = true;
                    return true;
                }
                return url.indexOf('stun:') === 0 && edgeVersion >= 14393 && url.indexOf('?transport=udp') === -1;
            });
            delete server.url;
            server.urls = isString ? urls[0] : urls;
            return !!urls.length;
        }
    });
}
// Determines the intersection of local and remote capabilities.
function getCommonCapabilities(localCapabilities, remoteCapabilities) {
    var commonCapabilities = {
        codecs: [],
        headerExtensions: [],
        fecMechanisms: []
    };
    var findCodecByPayloadType = function(pt, codecs) {
        pt = parseInt(pt, 10);
        for(var i = 0; i < codecs.length; i++){
            if (codecs[i].payloadType === pt || codecs[i].preferredPayloadType === pt) {
                return codecs[i];
            }
        }
    };
    var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {
        var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
        var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
        return lCodec && rCodec && lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
    };
    localCapabilities.codecs.forEach(function(lCodec) {
        for(var i = 0; i < remoteCapabilities.codecs.length; i++){
            var rCodec = remoteCapabilities.codecs[i];
            if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() && lCodec.clockRate === rCodec.clockRate) {
                if (lCodec.name.toLowerCase() === 'rtx' && lCodec.parameters && rCodec.parameters.apt) {
                    // for RTX we need to find the local rtx that has a apt
                    // which points to the same local codec as the remote one.
                    if (!rtxCapabilityMatches(lCodec, rCodec, localCapabilities.codecs, remoteCapabilities.codecs)) {
                        continue;
                    }
                }
                rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
                // number of channels is the highest common number of channels
                rCodec.numChannels = Math.min(lCodec.numChannels, rCodec.numChannels);
                // push rCodec so we reply with offerer payload type
                commonCapabilities.codecs.push(rCodec);
                // determine common feedback mechanisms
                rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
                    for(var j = 0; j < lCodec.rtcpFeedback.length; j++){
                        if (lCodec.rtcpFeedback[j].type === fb.type && lCodec.rtcpFeedback[j].parameter === fb.parameter) {
                            return true;
                        }
                    }
                    return false;
                });
                break;
            }
        }
    });
    localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
        for(var i = 0; i < remoteCapabilities.headerExtensions.length; i++){
            var rHeaderExtension = remoteCapabilities.headerExtensions[i];
            if (lHeaderExtension.uri === rHeaderExtension.uri) {
                commonCapabilities.headerExtensions.push(rHeaderExtension);
                break;
            }
        }
    });
    // FIXME: fecMechanisms
    return commonCapabilities;
}
// is action=setLocalDescription with type allowed in signalingState
function isActionAllowedInSignalingState(action, type, signalingState) {
    return ({
        offer: {
            setLocalDescription: [
                'stable',
                'have-local-offer'
            ],
            setRemoteDescription: [
                'stable',
                'have-remote-offer'
            ]
        },
        answer: {
            setLocalDescription: [
                'have-remote-offer',
                'have-local-pranswer'
            ],
            setRemoteDescription: [
                'have-local-offer',
                'have-remote-pranswer'
            ]
        }
    })[type][action].indexOf(signalingState) !== -1;
}
function maybeAddCandidate(iceTransport, candidate) {
    // Edge's internal representation adds some fields therefore
    // not all fieldѕ are taken into account.
    var alreadyAdded = iceTransport.getRemoteCandidates().find(function(remoteCandidate) {
        return candidate.foundation === remoteCandidate.foundation && candidate.ip === remoteCandidate.ip && candidate.port === remoteCandidate.port && candidate.priority === remoteCandidate.priority && candidate.protocol === remoteCandidate.protocol && candidate.type === remoteCandidate.type;
    });
    if (!alreadyAdded) {
        iceTransport.addRemoteCandidate(candidate);
    }
    return !alreadyAdded;
}
function makeError(name, description) {
    var e = new Error(description);
    e.name = name;
    // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names
    e.code = ({
        NotSupportedError: 9,
        InvalidStateError: 11,
        InvalidAccessError: 15,
        TypeError: undefined,
        OperationError: undefined
    })[name];
    return e;
}
module.exports = function(window, edgeVersion) {
    // https://w3c.github.io/mediacapture-main/#mediastream
    // Helper function to add the track to the stream and
    // dispatch the event ourselves.
    function addTrackToStreamAndFireEvent(track, stream) {
        stream.addTrack(track);
        stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack', {
            track: track
        }));
    }
    function removeTrackFromStreamAndFireEvent(track, stream) {
        stream.removeTrack(track);
        stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack', {
            track: track
        }));
    }
    function fireAddTrack(pc, track, receiver, streams) {
        var trackEvent = new Event('track');
        trackEvent.track = track;
        trackEvent.receiver = receiver;
        trackEvent.transceiver = {
            receiver: receiver
        };
        trackEvent.streams = streams;
        window.setTimeout(function() {
            pc._dispatchEvent('track', trackEvent);
        });
    }
    var RTCPeerConnection = function(config) {
        var pc = this;
        var _eventTarget = document.createDocumentFragment();
        [
            'addEventListener',
            'removeEventListener',
            'dispatchEvent'
        ].forEach(function(method) {
            pc[method] = _eventTarget[method].bind(_eventTarget);
        });
        this.canTrickleIceCandidates = null;
        this.needNegotiation = false;
        this.localStreams = [];
        this.remoteStreams = [];
        this._localDescription = null;
        this._remoteDescription = null;
        this.signalingState = 'stable';
        this.iceConnectionState = 'new';
        this.connectionState = 'new';
        this.iceGatheringState = 'new';
        config = JSON.parse(JSON.stringify(config || {}));
        this.usingBundle = config.bundlePolicy === 'max-bundle';
        if (config.rtcpMuxPolicy === 'negotiate') {
            throw makeError('NotSupportedError', 'rtcpMuxPolicy \'negotiate\' is not supported');
        } else if (!config.rtcpMuxPolicy) {
            config.rtcpMuxPolicy = 'require';
        }
        switch(config.iceTransportPolicy){
            case 'all':
            case 'relay':
                break;
            default:
                config.iceTransportPolicy = 'all';
                break;
        }
        switch(config.bundlePolicy){
            case 'balanced':
            case 'max-compat':
            case 'max-bundle':
                break;
            default:
                config.bundlePolicy = 'balanced';
                break;
        }
        config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);
        this._iceGatherers = [];
        if (config.iceCandidatePoolSize) {
            for(var i = config.iceCandidatePoolSize; i > 0; i--){
                this._iceGatherers.push(new window.RTCIceGatherer({
                    iceServers: config.iceServers,
                    gatherPolicy: config.iceTransportPolicy
                }));
            }
        } else {
            config.iceCandidatePoolSize = 0;
        }
        this._config = config;
        // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
        // everything that is needed to describe a SDP m-line.
        this.transceivers = [];
        this._sdpSessionId = SDPUtils.generateSessionId();
        this._sdpSessionVersion = 0;
        this._dtlsRole = undefined; // role for a=setup to use in answers.
        this._isClosed = false;
    };
    Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {
        configurable: true,
        get: function() {
            return this._localDescription;
        }
    });
    Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {
        configurable: true,
        get: function() {
            return this._remoteDescription;
        }
    });
    // set up event handlers on prototype
    RTCPeerConnection.prototype.onicecandidate = null;
    RTCPeerConnection.prototype.onaddstream = null;
    RTCPeerConnection.prototype.ontrack = null;
    RTCPeerConnection.prototype.onremovestream = null;
    RTCPeerConnection.prototype.onsignalingstatechange = null;
    RTCPeerConnection.prototype.oniceconnectionstatechange = null;
    RTCPeerConnection.prototype.onconnectionstatechange = null;
    RTCPeerConnection.prototype.onicegatheringstatechange = null;
    RTCPeerConnection.prototype.onnegotiationneeded = null;
    RTCPeerConnection.prototype.ondatachannel = null;
    RTCPeerConnection.prototype._dispatchEvent = function(name, event) {
        if (this._isClosed) {
            return;
        }
        this.dispatchEvent(event);
        if (typeof this['on' + name] === 'function') {
            this['on' + name](event);
        }
    };
    RTCPeerConnection.prototype._emitGatheringStateChange = function() {
        var event = new Event('icegatheringstatechange');
        this._dispatchEvent('icegatheringstatechange', event);
    };
    RTCPeerConnection.prototype.getConfiguration = function() {
        return this._config;
    };
    RTCPeerConnection.prototype.getLocalStreams = function() {
        return this.localStreams;
    };
    RTCPeerConnection.prototype.getRemoteStreams = function() {
        return this.remoteStreams;
    };
    // internal helper to create a transceiver object.
    // (which is not yet the same as the WebRTC 1.0 transceiver)
    RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {
        var hasBundleTransport = this.transceivers.length > 0;
        var transceiver = {
            track: null,
            iceGatherer: null,
            iceTransport: null,
            dtlsTransport: null,
            localCapabilities: null,
            remoteCapabilities: null,
            rtpSender: null,
            rtpReceiver: null,
            kind: kind,
            mid: null,
            sendEncodingParameters: null,
            recvEncodingParameters: null,
            stream: null,
            associatedRemoteMediaStreams: [],
            wantReceive: true
        };
        if (this.usingBundle && hasBundleTransport) {
            transceiver.iceTransport = this.transceivers[0].iceTransport;
            transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
        } else {
            var transports = this._createIceAndDtlsTransports();
            transceiver.iceTransport = transports.iceTransport;
            transceiver.dtlsTransport = transports.dtlsTransport;
        }
        if (!doNotAdd) {
            this.transceivers.push(transceiver);
        }
        return transceiver;
    };
    RTCPeerConnection.prototype.addTrack = function(track, stream) {
        if (this._isClosed) {
            throw makeError('InvalidStateError', 'Attempted to call addTrack on a closed peerconnection.');
        }
        var alreadyExists = this.transceivers.find(function(s) {
            return s.track === track;
        });
        if (alreadyExists) {
            throw makeError('InvalidAccessError', 'Track already exists.');
        }
        var transceiver;
        for(var i = 0; i < this.transceivers.length; i++){
            if (!this.transceivers[i].track && this.transceivers[i].kind === track.kind) {
                transceiver = this.transceivers[i];
            }
        }
        if (!transceiver) {
            transceiver = this._createTransceiver(track.kind);
        }
        this._maybeFireNegotiationNeeded();
        if (this.localStreams.indexOf(stream) === -1) {
            this.localStreams.push(stream);
        }
        transceiver.track = track;
        transceiver.stream = stream;
        transceiver.rtpSender = new window.RTCRtpSender(track, transceiver.dtlsTransport);
        return transceiver.rtpSender;
    };
    RTCPeerConnection.prototype.addStream = function(stream) {
        var pc = this;
        if (edgeVersion >= 15025) {
            stream.getTracks().forEach(function(track) {
                pc.addTrack(track, stream);
            });
        } else {
            // Clone is necessary for local demos mostly, attaching directly
            // to two different senders does not work (build 10547).
            // Fixed in 15025 (or earlier)
            var clonedStream = stream.clone();
            stream.getTracks().forEach(function(track, idx) {
                var clonedTrack = clonedStream.getTracks()[idx];
                track.addEventListener('enabled', function(event) {
                    clonedTrack.enabled = event.enabled;
                });
            });
            clonedStream.getTracks().forEach(function(track) {
                pc.addTrack(track, clonedStream);
            });
        }
    };
    RTCPeerConnection.prototype.removeTrack = function(sender) {
        if (this._isClosed) {
            throw makeError('InvalidStateError', 'Attempted to call removeTrack on a closed peerconnection.');
        }
        if (!(sender instanceof window.RTCRtpSender)) {
            throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.');
        }
        var transceiver = this.transceivers.find(function(t) {
            return t.rtpSender === sender;
        });
        if (!transceiver) {
            throw makeError('InvalidAccessError', 'Sender was not created by this connection.');
        }
        var stream = transceiver.stream;
        transceiver.rtpSender.stop();
        transceiver.rtpSender = null;
        transceiver.track = null;
        transceiver.stream = null;
        // remove the stream from the set of local streams
        var localStreams = this.transceivers.map(function(t) {
            return t.stream;
        });
        if (localStreams.indexOf(stream) === -1 && this.localStreams.indexOf(stream) > -1) {
            this.localStreams.splice(this.localStreams.indexOf(stream), 1);
        }
        this._maybeFireNegotiationNeeded();
    };
    RTCPeerConnection.prototype.removeStream = function(stream) {
        var pc = this;
        stream.getTracks().forEach(function(track) {
            var sender = pc.getSenders().find(function(s) {
                return s.track === track;
            });
            if (sender) {
                pc.removeTrack(sender);
            }
        });
    };
    RTCPeerConnection.prototype.getSenders = function() {
        return this.transceivers.filter(function(transceiver) {
            return !!transceiver.rtpSender;
        }).map(function(transceiver) {
            return transceiver.rtpSender;
        });
    };
    RTCPeerConnection.prototype.getReceivers = function() {
        return this.transceivers.filter(function(transceiver) {
            return !!transceiver.rtpReceiver;
        }).map(function(transceiver) {
            return transceiver.rtpReceiver;
        });
    };
    RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex, usingBundle) {
        var pc = this;
        if (usingBundle && sdpMLineIndex > 0) {
            return this.transceivers[0].iceGatherer;
        } else if (this._iceGatherers.length) {
            return this._iceGatherers.shift();
        }
        var iceGatherer = new window.RTCIceGatherer({
            iceServers: this._config.iceServers,
            gatherPolicy: this._config.iceTransportPolicy
        });
        Object.defineProperty(iceGatherer, 'state', {
            value: 'new',
            writable: true
        });
        this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
        this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {
            var end = !event.candidate || Object.keys(event.candidate).length === 0;
            // polyfill since RTCIceGatherer.state is not implemented in
            // Edge 10547 yet.
            iceGatherer.state = end ? 'completed' : 'gathering';
            if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {
                pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
            }
        };
        iceGatherer.addEventListener('localcandidate', this.transceivers[sdpMLineIndex].bufferCandidates);
        return iceGatherer;
    };
    // start gathering from an RTCIceGatherer.
    RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {
        var pc = this;
        var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
        if (iceGatherer.onlocalcandidate) {
            return;
        }
        var bufferedCandidateEvents = this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
        this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
        iceGatherer.removeEventListener('localcandidate', this.transceivers[sdpMLineIndex].bufferCandidates);
        iceGatherer.onlocalcandidate = function(evt) {
            if (pc.usingBundle && sdpMLineIndex > 0) {
                // if we know that we use bundle we can drop candidates with
                // ѕdpMLineIndex > 0. If we don't do this then our state gets
                // confused since we dispose the extra ice gatherer.
                return;
            }
            var event = new Event('icecandidate');
            event.candidate = {
                sdpMid: mid,
                sdpMLineIndex: sdpMLineIndex
            };
            var cand = evt.candidate;
            // Edge emits an empty object for RTCIceCandidateComplete‥
            var end = !cand || Object.keys(cand).length === 0;
            if (end) {
                // polyfill since RTCIceGatherer.state is not implemented in
                // Edge 10547 yet.
                if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
                    iceGatherer.state = 'completed';
                }
            } else {
                if (iceGatherer.state === 'new') {
                    iceGatherer.state = 'gathering';
                }
                // RTCIceCandidate doesn't have a component, needs to be added
                cand.component = 1;
                // also the usernameFragment. TODO: update SDP to take both variants.
                cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;
                var serializedCandidate = SDPUtils.writeCandidate(cand);
                event.candidate = Object.assign(event.candidate, SDPUtils.parseCandidate(serializedCandidate));
                event.candidate.candidate = serializedCandidate;
                event.candidate.toJSON = function() {
                    return {
                        candidate: event.candidate.candidate,
                        sdpMid: event.candidate.sdpMid,
                        sdpMLineIndex: event.candidate.sdpMLineIndex,
                        usernameFragment: event.candidate.usernameFragment
                    };
                };
            }
            // update local description.
            var sections = SDPUtils.getMediaSections(pc._localDescription.sdp);
            if (!end) {
                sections[event.candidate.sdpMLineIndex] += 'a=' + event.candidate.candidate + '\r\n';
            } else {
                sections[event.candidate.sdpMLineIndex] += 'a=end-of-candidates\r\n';
            }
            pc._localDescription.sdp = SDPUtils.getDescription(pc._localDescription.sdp) + sections.join('');
            var complete = pc.transceivers.every(function(transceiver) {
                return transceiver.iceGatherer && transceiver.iceGatherer.state === 'completed';
            });
            if (pc.iceGatheringState !== 'gathering') {
                pc.iceGatheringState = 'gathering';
                pc._emitGatheringStateChange();
            }
            // Emit candidate. Also emit null candidate when all gatherers are
            // complete.
            if (!end) {
                pc._dispatchEvent('icecandidate', event);
            }
            if (complete) {
                pc._dispatchEvent('icecandidate', new Event('icecandidate'));
                pc.iceGatheringState = 'complete';
                pc._emitGatheringStateChange();
            }
        };
        // emit already gathered candidates.
        window.setTimeout(function() {
            bufferedCandidateEvents.forEach(function(e) {
                iceGatherer.onlocalcandidate(e);
            });
        }, 0);
    };
    // Create ICE transport and DTLS transport.
    RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {
        var pc = this;
        var iceTransport = new window.RTCIceTransport(null);
        iceTransport.onicestatechange = function() {
            pc._updateIceConnectionState();
            pc._updateConnectionState();
        };
        var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
        dtlsTransport.ondtlsstatechange = function() {
            pc._updateConnectionState();
        };
        dtlsTransport.onerror = function() {
            // onerror does not set state to failed by itself.
            Object.defineProperty(dtlsTransport, 'state', {
                value: 'failed',
                writable: true
            });
            pc._updateConnectionState();
        };
        return {
            iceTransport: iceTransport,
            dtlsTransport: dtlsTransport
        };
    };
    // Destroy ICE gatherer, ICE transport and DTLS transport.
    // Without triggering the callbacks.
    RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(sdpMLineIndex) {
        var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
        if (iceGatherer) {
            delete iceGatherer.onlocalcandidate;
            delete this.transceivers[sdpMLineIndex].iceGatherer;
        }
        var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
        if (iceTransport) {
            delete iceTransport.onicestatechange;
            delete this.transceivers[sdpMLineIndex].iceTransport;
        }
        var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
        if (dtlsTransport) {
            delete dtlsTransport.ondtlsstatechange;
            delete dtlsTransport.onerror;
            delete this.transceivers[sdpMLineIndex].dtlsTransport;
        }
    };
    // Start the RTP Sender and Receiver for a transceiver.
    RTCPeerConnection.prototype._transceive = function(transceiver, send, recv) {
        var params = getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities);
        if (send && transceiver.rtpSender) {
            params.encodings = transceiver.sendEncodingParameters;
            params.rtcp = {
                cname: SDPUtils.localCName,
                compound: transceiver.rtcpParameters.compound
            };
            if (transceiver.recvEncodingParameters.length) {
                params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
            }
            transceiver.rtpSender.send(params);
        }
        if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
            // remove RTX field in Edge 14942
            if (transceiver.kind === 'video' && transceiver.recvEncodingParameters && edgeVersion < 15019) {
                transceiver.recvEncodingParameters.forEach(function(p) {
                    delete p.rtx;
                });
            }
            if (transceiver.recvEncodingParameters.length) {
                params.encodings = transceiver.recvEncodingParameters;
            } else {
                params.encodings = [
                    {}
                ];
            }
            params.rtcp = {
                compound: transceiver.rtcpParameters.compound
            };
            if (transceiver.rtcpParameters.cname) {
                params.rtcp.cname = transceiver.rtcpParameters.cname;
            }
            if (transceiver.sendEncodingParameters.length) {
                params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
            }
            transceiver.rtpReceiver.receive(params);
        }
    };
    RTCPeerConnection.prototype.setLocalDescription = function(description) {
        var pc = this;
        // Note: pranswer is not supported.
        if ([
            'offer',
            'answer'
        ].indexOf(description.type) === -1) {
            return Promise.reject(makeError('TypeError', 'Unsupported type "' + description.type + '"'));
        }
        if (!isActionAllowedInSignalingState('setLocalDescription', description.type, pc.signalingState) || pc._isClosed) {
            return Promise.reject(makeError('InvalidStateError', 'Can not set local ' + description.type + ' in state ' + pc.signalingState));
        }
        var sections;
        var sessionpart;
        if (description.type === 'offer') {
            // VERY limited support for SDP munging. Limited to:
            // * changing the order of codecs
            sections = SDPUtils.splitSections(description.sdp);
            sessionpart = sections.shift();
            sections.forEach(function(mediaSection, sdpMLineIndex) {
                var caps = SDPUtils.parseRtpParameters(mediaSection);
                pc.transceivers[sdpMLineIndex].localCapabilities = caps;
            });
            pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
                pc._gather(transceiver.mid, sdpMLineIndex);
            });
        } else if (description.type === 'answer') {
            sections = SDPUtils.splitSections(pc._remoteDescription.sdp);
            sessionpart = sections.shift();
            var isIceLite = SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length > 0;
            sections.forEach(function(mediaSection, sdpMLineIndex) {
                var transceiver = pc.transceivers[sdpMLineIndex];
                var iceGatherer = transceiver.iceGatherer;
                var iceTransport = transceiver.iceTransport;
                var dtlsTransport = transceiver.dtlsTransport;
                var localCapabilities = transceiver.localCapabilities;
                var remoteCapabilities = transceiver.remoteCapabilities;
                // treat bundle-only as not-rejected.
                var rejected = SDPUtils.isRejected(mediaSection) && SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
                if (!rejected && !transceiver.rejected) {
                    var remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart);
                    var remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart);
                    if (isIceLite) {
                        remoteDtlsParameters.role = 'server';
                    }
                    if (!pc.usingBundle || sdpMLineIndex === 0) {
                        pc._gather(transceiver.mid, sdpMLineIndex);
                        if (iceTransport.state === 'new') {
                            iceTransport.start(iceGatherer, remoteIceParameters, isIceLite ? 'controlling' : 'controlled');
                        }
                        if (dtlsTransport.state === 'new') {
                            dtlsTransport.start(remoteDtlsParameters);
                        }
                    }
                    // Calculate intersection of capabilities.
                    var params = getCommonCapabilities(localCapabilities, remoteCapabilities);
                    // Start the RTCRtpSender. The RTCRtpReceiver for this
                    // transceiver has already been started in setRemoteDescription.
                    pc._transceive(transceiver, params.codecs.length > 0, false);
                }
            });
        }
        pc._localDescription = {
            type: description.type,
            sdp: description.sdp
        };
        if (description.type === 'offer') {
            pc._updateSignalingState('have-local-offer');
        } else {
            pc._updateSignalingState('stable');
        }
        return Promise.resolve();
    };
    RTCPeerConnection.prototype.setRemoteDescription = function(description) {
        var pc = this;
        // Note: pranswer is not supported.
        if ([
            'offer',
            'answer'
        ].indexOf(description.type) === -1) {
            return Promise.reject(makeError('TypeError', 'Unsupported type "' + description.type + '"'));
        }
        if (!isActionAllowedInSignalingState('setRemoteDescription', description.type, pc.signalingState) || pc._isClosed) {
            return Promise.reject(makeError('InvalidStateError', 'Can not set remote ' + description.type + ' in state ' + pc.signalingState));
        }
        var streams = {};
        pc.remoteStreams.forEach(function(stream) {
            streams[stream.id] = stream;
        });
        var receiverList = [];
        var sections = SDPUtils.splitSections(description.sdp);
        var sessionpart = sections.shift();
        var isIceLite = SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length > 0;
        var usingBundle = SDPUtils.matchPrefix(sessionpart, 'a=group:BUNDLE ').length > 0;
        pc.usingBundle = usingBundle;
        var iceOptions = SDPUtils.matchPrefix(sessionpart, 'a=ice-options:')[0];
        if (iceOptions) {
            pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ').indexOf('trickle') >= 0;
        } else {
            pc.canTrickleIceCandidates = false;
        }
        sections.forEach(function(mediaSection, sdpMLineIndex) {
            var lines = SDPUtils.splitLines(mediaSection);
            var kind = SDPUtils.getKind(mediaSection);
            // treat bundle-only as not-rejected.
            var rejected = SDPUtils.isRejected(mediaSection) && SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
            var protocol = lines[0].substr(2).split(' ')[2];
            var direction = SDPUtils.getDirection(mediaSection, sessionpart);
            var remoteMsid = SDPUtils.parseMsid(mediaSection);
            var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();
            // Reject datachannels which are not implemented yet.
            if (rejected || kind === 'application' && (protocol === 'DTLS/SCTP' || protocol === 'UDP/DTLS/SCTP')) {
                // TODO: this is dangerous in the case where a non-rejected m-line
                //     becomes rejected.
                pc.transceivers[sdpMLineIndex] = {
                    mid: mid,
                    kind: kind,
                    protocol: protocol,
                    rejected: true
                };
                return;
            }
            if (!rejected && pc.transceivers[sdpMLineIndex] && pc.transceivers[sdpMLineIndex].rejected) {
                // recycle a rejected transceiver.
                pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
            }
            var transceiver;
            var iceGatherer;
            var iceTransport;
            var dtlsTransport;
            var rtpReceiver;
            var sendEncodingParameters;
            var recvEncodingParameters;
            var localCapabilities;
            var track;
            // FIXME: ensure the mediaSection has rtcp-mux set.
            var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
            var remoteIceParameters;
            var remoteDtlsParameters;
            if (!rejected) {
                remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart);
                remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart);
                remoteDtlsParameters.role = 'client';
            }
            recvEncodingParameters = SDPUtils.parseRtpEncodingParameters(mediaSection);
            var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);
            var isComplete = SDPUtils.matchPrefix(mediaSection, 'a=end-of-candidates', sessionpart).length > 0;
            var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:').map(function(cand) {
                return SDPUtils.parseCandidate(cand);
            }).filter(function(cand) {
                return cand.component === 1;
            });
            // Check if we can use BUNDLE and dispose transports.
            if ((description.type === 'offer' || description.type === 'answer') && !rejected && usingBundle && sdpMLineIndex > 0 && pc.transceivers[sdpMLineIndex]) {
                pc._disposeIceAndDtlsTransports(sdpMLineIndex);
                pc.transceivers[sdpMLineIndex].iceGatherer = pc.transceivers[0].iceGatherer;
                pc.transceivers[sdpMLineIndex].iceTransport = pc.transceivers[0].iceTransport;
                pc.transceivers[sdpMLineIndex].dtlsTransport = pc.transceivers[0].dtlsTransport;
                if (pc.transceivers[sdpMLineIndex].rtpSender) {
                    pc.transceivers[sdpMLineIndex].rtpSender.setTransport(pc.transceivers[0].dtlsTransport);
                }
                if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
                    pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(pc.transceivers[0].dtlsTransport);
                }
            }
            if (description.type === 'offer' && !rejected) {
                transceiver = pc.transceivers[sdpMLineIndex] || pc._createTransceiver(kind);
                transceiver.mid = mid;
                if (!transceiver.iceGatherer) {
                    transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex, usingBundle);
                }
                if (cands.length && transceiver.iceTransport.state === 'new') {
                    if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
                        transceiver.iceTransport.setRemoteCandidates(cands);
                    } else {
                        cands.forEach(function(candidate) {
                            maybeAddCandidate(transceiver.iceTransport, candidate);
                        });
                    }
                }
                localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);
                // filter RTX until additional stuff needed for RTX is implemented
                // in adapter.js
                if (edgeVersion < 15019) {
                    localCapabilities.codecs = localCapabilities.codecs.filter(function(codec) {
                        return codec.name !== 'rtx';
                    });
                }
                sendEncodingParameters = transceiver.sendEncodingParameters || [
                    {
                        ssrc: (2 * sdpMLineIndex + 2) * 1001
                    }
                ];
                // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
                var isNewTrack = false;
                if (direction === 'sendrecv' || direction === 'sendonly') {
                    isNewTrack = !transceiver.rtpReceiver;
                    rtpReceiver = transceiver.rtpReceiver || new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);
                    if (isNewTrack) {
                        var stream;
                        track = rtpReceiver.track;
                        // FIXME: does not work with Plan B.
                        if (remoteMsid && remoteMsid.stream === '-') {
                        // no-op. a stream id of '-' means: no associated stream.
                        } else if (remoteMsid) {
                            if (!streams[remoteMsid.stream]) {
                                streams[remoteMsid.stream] = new window.MediaStream();
                                Object.defineProperty(streams[remoteMsid.stream], 'id', {
                                    get: function() {
                                        return remoteMsid.stream;
                                    }
                                });
                            }
                            Object.defineProperty(track, 'id', {
                                get: function() {
                                    return remoteMsid.track;
                                }
                            });
                            stream = streams[remoteMsid.stream];
                        } else {
                            if (!streams.default) {
                                streams.default = new window.MediaStream();
                            }
                            stream = streams.default;
                        }
                        if (stream) {
                            addTrackToStreamAndFireEvent(track, stream);
                            transceiver.associatedRemoteMediaStreams.push(stream);
                        }
                        receiverList.push([
                            track,
                            rtpReceiver,
                            stream
                        ]);
                    }
                } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
                    transceiver.associatedRemoteMediaStreams.forEach(function(s) {
                        var nativeTrack = s.getTracks().find(function(t) {
                            return t.id === transceiver.rtpReceiver.track.id;
                        });
                        if (nativeTrack) {
                            removeTrackFromStreamAndFireEvent(nativeTrack, s);
                        }
                    });
                    transceiver.associatedRemoteMediaStreams = [];
                }
                transceiver.localCapabilities = localCapabilities;
                transceiver.remoteCapabilities = remoteCapabilities;
                transceiver.rtpReceiver = rtpReceiver;
                transceiver.rtcpParameters = rtcpParameters;
                transceiver.sendEncodingParameters = sendEncodingParameters;
                transceiver.recvEncodingParameters = recvEncodingParameters;
                // Start the RTCRtpReceiver now. The RTPSender is started in
                // setLocalDescription.
                pc._transceive(pc.transceivers[sdpMLineIndex], false, isNewTrack);
            } else if (description.type === 'answer' && !rejected) {
                transceiver = pc.transceivers[sdpMLineIndex];
                iceGatherer = transceiver.iceGatherer;
                iceTransport = transceiver.iceTransport;
                dtlsTransport = transceiver.dtlsTransport;
                rtpReceiver = transceiver.rtpReceiver;
                sendEncodingParameters = transceiver.sendEncodingParameters;
                localCapabilities = transceiver.localCapabilities;
                pc.transceivers[sdpMLineIndex].recvEncodingParameters = recvEncodingParameters;
                pc.transceivers[sdpMLineIndex].remoteCapabilities = remoteCapabilities;
                pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;
                if (cands.length && iceTransport.state === 'new') {
                    if ((isIceLite || isComplete) && (!usingBundle || sdpMLineIndex === 0)) {
                        iceTransport.setRemoteCandidates(cands);
                    } else {
                        cands.forEach(function(candidate) {
                            maybeAddCandidate(transceiver.iceTransport, candidate);
                        });
                    }
                }
                if (!usingBundle || sdpMLineIndex === 0) {
                    if (iceTransport.state === 'new') {
                        iceTransport.start(iceGatherer, remoteIceParameters, 'controlling');
                    }
                    if (dtlsTransport.state === 'new') {
                        dtlsTransport.start(remoteDtlsParameters);
                    }
                }
                // If the offer contained RTX but the answer did not,
                // remove RTX from sendEncodingParameters.
                var commonCapabilities = getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities);
                var hasRtx = commonCapabilities.codecs.filter(function(c) {
                    return c.name.toLowerCase() === 'rtx';
                }).length;
                if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
                    delete transceiver.sendEncodingParameters[0].rtx;
                }
                pc._transceive(transceiver, direction === 'sendrecv' || direction === 'recvonly', direction === 'sendrecv' || direction === 'sendonly');
                // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
                if (rtpReceiver && (direction === 'sendrecv' || direction === 'sendonly')) {
                    track = rtpReceiver.track;
                    if (remoteMsid) {
                        if (!streams[remoteMsid.stream]) {
                            streams[remoteMsid.stream] = new window.MediaStream();
                        }
                        addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
                        receiverList.push([
                            track,
                            rtpReceiver,
                            streams[remoteMsid.stream]
                        ]);
                    } else {
                        if (!streams.default) {
                            streams.default = new window.MediaStream();
                        }
                        addTrackToStreamAndFireEvent(track, streams.default);
                        receiverList.push([
                            track,
                            rtpReceiver,
                            streams.default
                        ]);
                    }
                } else {
                    // FIXME: actually the receiver should be created later.
                    delete transceiver.rtpReceiver;
                }
            }
        });
        if (pc._dtlsRole === undefined) {
            pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
        }
        pc._remoteDescription = {
            type: description.type,
            sdp: description.sdp
        };
        if (description.type === 'offer') {
            pc._updateSignalingState('have-remote-offer');
        } else {
            pc._updateSignalingState('stable');
        }
        Object.keys(streams).forEach(function(sid) {
            var stream = streams[sid];
            if (stream.getTracks().length) {
                if (pc.remoteStreams.indexOf(stream) === -1) {
                    pc.remoteStreams.push(stream);
                    var event = new Event('addstream');
                    event.stream = stream;
                    window.setTimeout(function() {
                        pc._dispatchEvent('addstream', event);
                    });
                }
                receiverList.forEach(function(item) {
                    var track = item[0];
                    var receiver = item[1];
                    if (stream.id !== item[2].id) {
                        return;
                    }
                    fireAddTrack(pc, track, receiver, [
                        stream
                    ]);
                });
            }
        });
        receiverList.forEach(function(item) {
            if (item[2]) {
                return;
            }
            fireAddTrack(pc, item[0], item[1], []);
        });
        // check whether addIceCandidate({}) was called within four seconds after
        // setRemoteDescription.
        window.setTimeout(function() {
            if (!(pc && pc.transceivers)) {
                return;
            }
            pc.transceivers.forEach(function(transceiver) {
                if (transceiver.iceTransport && transceiver.iceTransport.state === 'new' && transceiver.iceTransport.getRemoteCandidates().length > 0) {
                    console.warn('Timeout for addRemoteCandidate. Consider sending ' + 'an end-of-candidates notification');
                    transceiver.iceTransport.addRemoteCandidate({});
                }
            });
        }, 4000);
        return Promise.resolve();
    };
    RTCPeerConnection.prototype.close = function() {
        this.transceivers.forEach(function(transceiver) {
            /* not yet
      if (transceiver.iceGatherer) {
        transceiver.iceGatherer.close();
      }
      */ if (transceiver.iceTransport) {
                transceiver.iceTransport.stop();
            }
            if (transceiver.dtlsTransport) {
                transceiver.dtlsTransport.stop();
            }
            if (transceiver.rtpSender) {
                transceiver.rtpSender.stop();
            }
            if (transceiver.rtpReceiver) {
                transceiver.rtpReceiver.stop();
            }
        });
        // FIXME: clean up tracks, local streams, remote streams, etc
        this._isClosed = true;
        this._updateSignalingState('closed');
    };
    // Update the signaling state.
    RTCPeerConnection.prototype._updateSignalingState = function(newState) {
        this.signalingState = newState;
        var event = new Event('signalingstatechange');
        this._dispatchEvent('signalingstatechange', event);
    };
    // Determine whether to fire the negotiationneeded event.
    RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
        var pc = this;
        if (this.signalingState !== 'stable' || this.needNegotiation === true) {
            return;
        }
        this.needNegotiation = true;
        window.setTimeout(function() {
            if (pc.needNegotiation) {
                pc.needNegotiation = false;
                var event = new Event('negotiationneeded');
                pc._dispatchEvent('negotiationneeded', event);
            }
        }, 0);
    };
    // Update the ice connection state.
    RTCPeerConnection.prototype._updateIceConnectionState = function() {
        var newState;
        var states = {
            'new': 0,
            closed: 0,
            checking: 0,
            connected: 0,
            completed: 0,
            disconnected: 0,
            failed: 0
        };
        this.transceivers.forEach(function(transceiver) {
            if (transceiver.iceTransport && !transceiver.rejected) {
                states[transceiver.iceTransport.state]++;
            }
        });
        newState = 'new';
        if (states.failed > 0) {
            newState = 'failed';
        } else if (states.checking > 0) {
            newState = 'checking';
        } else if (states.disconnected > 0) {
            newState = 'disconnected';
        } else if (states.new > 0) {
            newState = 'new';
        } else if (states.connected > 0) {
            newState = 'connected';
        } else if (states.completed > 0) {
            newState = 'completed';
        }
        if (newState !== this.iceConnectionState) {
            this.iceConnectionState = newState;
            var event = new Event('iceconnectionstatechange');
            this._dispatchEvent('iceconnectionstatechange', event);
        }
    };
    // Update the connection state.
    RTCPeerConnection.prototype._updateConnectionState = function() {
        var newState;
        var states = {
            'new': 0,
            closed: 0,
            connecting: 0,
            connected: 0,
            completed: 0,
            disconnected: 0,
            failed: 0
        };
        this.transceivers.forEach(function(transceiver) {
            if (transceiver.iceTransport && transceiver.dtlsTransport && !transceiver.rejected) {
                states[transceiver.iceTransport.state]++;
                states[transceiver.dtlsTransport.state]++;
            }
        });
        // ICETransport.completed and connected are the same for this purpose.
        states.connected += states.completed;
        newState = 'new';
        if (states.failed > 0) {
            newState = 'failed';
        } else if (states.connecting > 0) {
            newState = 'connecting';
        } else if (states.disconnected > 0) {
            newState = 'disconnected';
        } else if (states.new > 0) {
            newState = 'new';
        } else if (states.connected > 0) {
            newState = 'connected';
        }
        if (newState !== this.connectionState) {
            this.connectionState = newState;
            var event = new Event('connectionstatechange');
            this._dispatchEvent('connectionstatechange', event);
        }
    };
    RTCPeerConnection.prototype.createOffer = function() {
        var pc = this;
        if (pc._isClosed) {
            return Promise.reject(makeError('InvalidStateError', 'Can not call createOffer after close'));
        }
        var numAudioTracks = pc.transceivers.filter(function(t) {
            return t.kind === 'audio';
        }).length;
        var numVideoTracks = pc.transceivers.filter(function(t) {
            return t.kind === 'video';
        }).length;
        // Determine number of audio and video tracks we need to send/recv.
        var offerOptions = arguments[0];
        if (offerOptions) {
            // Reject Chrome legacy constraints.
            if (offerOptions.mandatory || offerOptions.optional) {
                throw new TypeError('Legacy mandatory/optional constraints not supported.');
            }
            if (offerOptions.offerToReceiveAudio !== undefined) {
                if (offerOptions.offerToReceiveAudio === true) {
                    numAudioTracks = 1;
                } else if (offerOptions.offerToReceiveAudio === false) {
                    numAudioTracks = 0;
                } else {
                    numAudioTracks = offerOptions.offerToReceiveAudio;
                }
            }
            if (offerOptions.offerToReceiveVideo !== undefined) {
                if (offerOptions.offerToReceiveVideo === true) {
                    numVideoTracks = 1;
                } else if (offerOptions.offerToReceiveVideo === false) {
                    numVideoTracks = 0;
                } else {
                    numVideoTracks = offerOptions.offerToReceiveVideo;
                }
            }
        }
        pc.transceivers.forEach(function(transceiver) {
            if (transceiver.kind === 'audio') {
                numAudioTracks--;
                if (numAudioTracks < 0) {
                    transceiver.wantReceive = false;
                }
            } else if (transceiver.kind === 'video') {
                numVideoTracks--;
                if (numVideoTracks < 0) {
                    transceiver.wantReceive = false;
                }
            }
        });
        // Create M-lines for recvonly streams.
        while(numAudioTracks > 0 || numVideoTracks > 0){
            if (numAudioTracks > 0) {
                pc._createTransceiver('audio');
                numAudioTracks--;
            }
            if (numVideoTracks > 0) {
                pc._createTransceiver('video');
                numVideoTracks--;
            }
        }
        var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId, pc._sdpSessionVersion++);
        pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
            // For each track, create an ice gatherer, ice transport,
            // dtls transport, potentially rtpsender and rtpreceiver.
            var track = transceiver.track;
            var kind = transceiver.kind;
            var mid = transceiver.mid || SDPUtils.generateIdentifier();
            transceiver.mid = mid;
            if (!transceiver.iceGatherer) {
                transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex, pc.usingBundle);
            }
            var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
            // filter RTX until additional stuff needed for RTX is implemented
            // in adapter.js
            if (edgeVersion < 15019) {
                localCapabilities.codecs = localCapabilities.codecs.filter(function(codec) {
                    return codec.name !== 'rtx';
                });
            }
            localCapabilities.codecs.forEach(function(codec) {
                // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
                // by adding level-asymmetry-allowed=1
                if (codec.name === 'H264' && codec.parameters['level-asymmetry-allowed'] === undefined) {
                    codec.parameters['level-asymmetry-allowed'] = '1';
                }
                // for subsequent offers, we might have to re-use the payload
                // type of the last offer.
                if (transceiver.remoteCapabilities && transceiver.remoteCapabilities.codecs) {
                    transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {
                        if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() && codec.clockRate === remoteCodec.clockRate) {
                            codec.preferredPayloadType = remoteCodec.payloadType;
                        }
                    });
                }
            });
            localCapabilities.headerExtensions.forEach(function(hdrExt) {
                var remoteExtensions = transceiver.remoteCapabilities && transceiver.remoteCapabilities.headerExtensions || [];
                remoteExtensions.forEach(function(rHdrExt) {
                    if (hdrExt.uri === rHdrExt.uri) {
                        hdrExt.id = rHdrExt.id;
                    }
                });
            });
            // generate an ssrc now, to be used later in rtpSender.send
            var sendEncodingParameters = transceiver.sendEncodingParameters || [
                {
                    ssrc: (2 * sdpMLineIndex + 1) * 1001
                }
            ];
            if (track) {
                // add RTX
                if (edgeVersion >= 15019 && kind === 'video' && !sendEncodingParameters[0].rtx) {
                    sendEncodingParameters[0].rtx = {
                        ssrc: sendEncodingParameters[0].ssrc + 1
                    };
                }
            }
            if (transceiver.wantReceive) {
                transceiver.rtpReceiver = new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);
            }
            transceiver.localCapabilities = localCapabilities;
            transceiver.sendEncodingParameters = sendEncodingParameters;
        });
        // always offer BUNDLE and dispose on return if not supported.
        if (pc._config.bundlePolicy !== 'max-compat') {
            sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
                return t.mid;
            }).join(' ') + '\r\n';
        }
        sdp += 'a=ice-options:trickle\r\n';
        pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
            sdp += writeMediaSection(transceiver, transceiver.localCapabilities, 'offer', transceiver.stream, pc._dtlsRole);
            sdp += 'a=rtcp-rsize\r\n';
            if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' && (sdpMLineIndex === 0 || !pc.usingBundle)) {
                transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {
                    cand.component = 1;
                    sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\r\n';
                });
                if (transceiver.iceGatherer.state === 'completed') {
                    sdp += 'a=end-of-candidates\r\n';
                }
            }
        });
        var desc = new window.RTCSessionDescription({
            type: 'offer',
            sdp: sdp
        });
        return Promise.resolve(desc);
    };
    RTCPeerConnection.prototype.createAnswer = function() {
        var pc = this;
        if (pc._isClosed) {
            return Promise.reject(makeError('InvalidStateError', 'Can not call createAnswer after close'));
        }
        if (!(pc.signalingState === 'have-remote-offer' || pc.signalingState === 'have-local-pranswer')) {
            return Promise.reject(makeError('InvalidStateError', 'Can not call createAnswer in signalingState ' + pc.signalingState));
        }
        var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId, pc._sdpSessionVersion++);
        if (pc.usingBundle) {
            sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
                return t.mid;
            }).join(' ') + '\r\n';
        }
        sdp += 'a=ice-options:trickle\r\n';
        var mediaSectionsInOffer = SDPUtils.getMediaSections(pc._remoteDescription.sdp).length;
        pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
            if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
                return;
            }
            if (transceiver.rejected) {
                if (transceiver.kind === 'application') {
                    if (transceiver.protocol === 'DTLS/SCTP') {
                        sdp += 'm=application 0 DTLS/SCTP 5000\r\n';
                    } else {
                        sdp += 'm=application 0 ' + transceiver.protocol + ' webrtc-datachannel\r\n';
                    }
                } else if (transceiver.kind === 'audio') {
                    sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\r\n' + 'a=rtpmap:0 PCMU/8000\r\n';
                } else if (transceiver.kind === 'video') {
                    sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\r\n' + 'a=rtpmap:120 VP8/90000\r\n';
                }
                sdp += 'c=IN IP4 0.0.0.0\r\n' + 'a=inactive\r\n' + 'a=mid:' + transceiver.mid + '\r\n';
                return;
            }
            // FIXME: look at direction.
            if (transceiver.stream) {
                var localTrack;
                if (transceiver.kind === 'audio') {
                    localTrack = transceiver.stream.getAudioTracks()[0];
                } else if (transceiver.kind === 'video') {
                    localTrack = transceiver.stream.getVideoTracks()[0];
                }
                if (localTrack) {
                    // add RTX
                    if (edgeVersion >= 15019 && transceiver.kind === 'video' && !transceiver.sendEncodingParameters[0].rtx) {
                        transceiver.sendEncodingParameters[0].rtx = {
                            ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
                        };
                    }
                }
            }
            // Calculate intersection of capabilities.
            var commonCapabilities = getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities);
            var hasRtx = commonCapabilities.codecs.filter(function(c) {
                return c.name.toLowerCase() === 'rtx';
            }).length;
            if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
                delete transceiver.sendEncodingParameters[0].rtx;
            }
            sdp += writeMediaSection(transceiver, commonCapabilities, 'answer', transceiver.stream, pc._dtlsRole);
            if (transceiver.rtcpParameters && transceiver.rtcpParameters.reducedSize) {
                sdp += 'a=rtcp-rsize\r\n';
            }
        });
        var desc = new window.RTCSessionDescription({
            type: 'answer',
            sdp: sdp
        });
        return Promise.resolve(desc);
    };
    RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
        var pc = this;
        var sections;
        if (candidate && !(candidate.sdpMLineIndex !== undefined || candidate.sdpMid)) {
            return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));
        }
        // TODO: needs to go into ops queue.
        return new Promise(function(resolve, reject) {
            if (!pc._remoteDescription) {
                return reject(makeError('InvalidStateError', 'Can not add ICE candidate without a remote description'));
            } else if (!candidate || candidate.candidate === '') {
                for(var j = 0; j < pc.transceivers.length; j++){
                    if (pc.transceivers[j].rejected) {
                        continue;
                    }
                    pc.transceivers[j].iceTransport.addRemoteCandidate({});
                    sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
                    sections[j] += 'a=end-of-candidates\r\n';
                    pc._remoteDescription.sdp = SDPUtils.getDescription(pc._remoteDescription.sdp) + sections.join('');
                    if (pc.usingBundle) {
                        break;
                    }
                }
            } else {
                var sdpMLineIndex = candidate.sdpMLineIndex;
                if (candidate.sdpMid) {
                    for(var i = 0; i < pc.transceivers.length; i++){
                        if (pc.transceivers[i].mid === candidate.sdpMid) {
                            sdpMLineIndex = i;
                            break;
                        }
                    }
                }
                var transceiver = pc.transceivers[sdpMLineIndex];
                if (transceiver) {
                    if (transceiver.rejected) {
                        return resolve();
                    }
                    var cand = Object.keys(candidate.candidate).length > 0 ? SDPUtils.parseCandidate(candidate.candidate) : {};
                    // Ignore Chrome's invalid candidates since Edge does not like them.
                    if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
                        return resolve();
                    }
                    // Ignore RTCP candidates, we assume RTCP-MUX.
                    if (cand.component && cand.component !== 1) {
                        return resolve();
                    }
                    // when using bundle, avoid adding candidates to the wrong
                    // ice transport. And avoid adding candidates added in the SDP.
                    if (sdpMLineIndex === 0 || sdpMLineIndex > 0 && transceiver.iceTransport !== pc.transceivers[0].iceTransport) {
                        if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
                            return reject(makeError('OperationError', 'Can not add ICE candidate'));
                        }
                    }
                    // update the remoteDescription.
                    var candidateString = candidate.candidate.trim();
                    if (candidateString.indexOf('a=') === 0) {
                        candidateString = candidateString.substr(2);
                    }
                    sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
                    sections[sdpMLineIndex] += 'a=' + (cand.type ? candidateString : 'end-of-candidates') + '\r\n';
                    pc._remoteDescription.sdp = SDPUtils.getDescription(pc._remoteDescription.sdp) + sections.join('');
                } else {
                    return reject(makeError('OperationError', 'Can not add ICE candidate'));
                }
            }
            resolve();
        });
    };
    RTCPeerConnection.prototype.getStats = function(selector) {
        if (selector && selector instanceof window.MediaStreamTrack) {
            var senderOrReceiver = null;
            this.transceivers.forEach(function(transceiver) {
                if (transceiver.rtpSender && transceiver.rtpSender.track === selector) {
                    senderOrReceiver = transceiver.rtpSender;
                } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track === selector) {
                    senderOrReceiver = transceiver.rtpReceiver;
                }
            });
            if (!senderOrReceiver) {
                throw makeError('InvalidAccessError', 'Invalid selector.');
            }
            return senderOrReceiver.getStats();
        }
        var promises = [];
        this.transceivers.forEach(function(transceiver) {
            [
                'rtpSender',
                'rtpReceiver',
                'iceGatherer',
                'iceTransport',
                'dtlsTransport'
            ].forEach(function(method) {
                if (transceiver[method]) {
                    promises.push(transceiver[method].getStats());
                }
            });
        });
        return Promise.all(promises).then(function(allStats) {
            var results = new Map();
            allStats.forEach(function(stats) {
                stats.forEach(function(stat) {
                    results.set(stat.id, stat);
                });
            });
            return results;
        });
    };
    // fix low-level stat names and return Map instead of object.
    var ortcObjects = [
        'RTCRtpSender',
        'RTCRtpReceiver',
        'RTCIceGatherer',
        'RTCIceTransport',
        'RTCDtlsTransport'
    ];
    ortcObjects.forEach(function(ortcObjectName) {
        var obj = window[ortcObjectName];
        if (obj && obj.prototype && obj.prototype.getStats) {
            var nativeGetstats = obj.prototype.getStats;
            obj.prototype.getStats = function() {
                return nativeGetstats.apply(this).then(function(nativeStats) {
                    var mapStats = new Map();
                    Object.keys(nativeStats).forEach(function(id) {
                        nativeStats[id].type = fixStatsType(nativeStats[id]);
                        mapStats.set(id, nativeStats[id]);
                    });
                    return mapStats;
                });
            };
        }
    });
    // legacy callback shims. Should be moved to adapter.js some days.
    var methods = [
        'createOffer',
        'createAnswer'
    ];
    methods.forEach(function(method) {
        var nativeMethod = RTCPeerConnection.prototype[method];
        RTCPeerConnection.prototype[method] = function() {
            var args = arguments;
            if (typeof args[0] === 'function' || typeof args[1] === 'function') {
                return nativeMethod.apply(this, [
                    arguments[2]
                ]).then(function(description) {
                    if (typeof args[0] === 'function') {
                        args[0].apply(null, [
                            description
                        ]);
                    }
                }, function(error) {
                    if (typeof args[1] === 'function') {
                        args[1].apply(null, [
                            error
                        ]);
                    }
                });
            }
            return nativeMethod.apply(this, arguments);
        };
    });
    methods = [
        'setLocalDescription',
        'setRemoteDescription',
        'addIceCandidate'
    ];
    methods.forEach(function(method) {
        var nativeMethod = RTCPeerConnection.prototype[method];
        RTCPeerConnection.prototype[method] = function() {
            var args = arguments;
            if (typeof args[1] === 'function' || typeof args[2] === 'function') {
                return nativeMethod.apply(this, arguments).then(function() {
                    if (typeof args[1] === 'function') {
                        args[1].apply(null);
                    }
                }, function(error) {
                    if (typeof args[2] === 'function') {
                        args[2].apply(null, [
                            error
                        ]);
                    }
                });
            }
            return nativeMethod.apply(this, arguments);
        };
    });
    // getStats is special. It doesn't have a spec legacy method yet we support
    // getStats(something, cb) without error callbacks.
    [
        'getStats'
    ].forEach(function(method) {
        var nativeMethod = RTCPeerConnection.prototype[method];
        RTCPeerConnection.prototype[method] = function() {
            var args = arguments;
            if (typeof args[1] === 'function') {
                return nativeMethod.apply(this, arguments).then(function() {
                    if (typeof args[1] === 'function') {
                        args[1].apply(null);
                    }
                });
            }
            return nativeMethod.apply(this, arguments);
        };
    });
    return RTCPeerConnection;
};
}}),
"[project]/node_modules/.pnpm/@keystonehq+sdk@0.19.2_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@keystonehq/sdk/dist/sdk.cjs.development.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
function _interopDefault(ex) {
    return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}
function _interopNamespace(e) {
    if (e && e.__esModule) {
        return e;
    } else {
        var n = {};
        if (e) {
            Object.keys(e).forEach(function(k) {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function() {
                        return e[k];
                    }
                });
            });
        }
        n['default'] = e;
        return n;
    }
}
var ReactDOM = _interopDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/next@15.2.3_@babel+core@7.26.10_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js [app-ssr] (ecmascript)"));
var React = __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.2.3_@babel+core@7.26.10_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var React__default = _interopDefault(React);
var Modal = _interopDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/react-modal@3.16.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-modal/lib/index.js [app-ssr] (ecmascript)"));
var events = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
var rxjs = __turbopack_context__.r("[project]/node_modules/.pnpm/rxjs@6.6.7/node_modules/rxjs/_esm5/index.js [app-ssr] (ecmascript)");
var QRCode = _interopDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/qrcode.react@1.0.1_react@19.0.0/node_modules/qrcode.react/lib/index.js [app-ssr] (ecmascript)"));
var bcUr = __turbopack_context__.r("[project]/node_modules/.pnpm/@ngraveio+bc-ur@1.1.13/node_modules/@ngraveio/bc-ur/dist/index.js [app-ssr] (ecmascript)");
const BaseQRCode = ({ size = 200, data = "", ecl = "L" })=>{
    return React__default.createElement(QRCode, {
        value: data,
        size: size,
        level: ecl
    });
};
(function(ReadStatus) {
    ReadStatus["canceled"] = "canceled";
    ReadStatus["success"] = "success";
})(exports.ReadStatus || (exports.ReadStatus = {}));
(function(PlayStatus) {
    PlayStatus["canceled"] = "canceled";
    PlayStatus["success"] = "success";
})(exports.PlayStatus || (exports.PlayStatus = {}));
(function(SupportedResult) {
    SupportedResult["UR_BYTES"] = "bytes";
    SupportedResult["UR_CRYPTO_HDKEY"] = "crypto-hdkey";
    SupportedResult["UR_CRYPTO_ACCOUNT"] = "crypto-account";
    SupportedResult["UR_ETH_SIGN_REQUEST"] = "eth-sign-request";
    SupportedResult["UR_ETH_SIGNATURE"] = "eth-signature";
    SupportedResult["UR_CRYPTO_MULTI_ACCOUNTS"] = "crypto-multi-accounts";
    SupportedResult["UR_SOL_SIGN_REQUEST"] = "sol-sign-request";
    SupportedResult["UR_SOL_SIGNATURE"] = "sol-signature";
    SupportedResult["UR_APTOS_SIGN_REQUEST"] = "aptos-sign-request";
    SupportedResult["UR_APTOS_SIGNATURE"] = "aptos-signature";
    SupportedResult["UR_ARWEAVE_SIGN_REQUEST"] = "arweave-sign-request";
    SupportedResult["UR_ARWEAVE_SIGNATURE"] = "arweave-signature";
    SupportedResult["UR_ARWEAVE_CRYPTO_ACCOUNT"] = "arweave-crypto-account";
    SupportedResult["UR_COSMOS_SIGN_REQUEST"] = "cosmos-sign-request";
    SupportedResult["UR_COSMOS_SIGNATURE"] = "cosmos-signature";
})(exports.SupportedResult || (exports.SupportedResult = {}));
const styleBase = {
    minWidth: "16rem",
    height: "3rem",
    background: "#784FFE",
    borderColor: "grey",
    borderRadius: "8px",
    borderWidth: 1,
    color: "white",
    outline: "none",
    margin: 2
};
const Button = (props)=>{
    const { onClick, children } = props;
    return React__default.createElement("button", {
        onClick: onClick,
        style: styleBase
    }, children);
};
const ButtonGroup = (props)=>{
    return React__default.createElement("div", {
        style: {
            width: "100%",
            marginTop: "1rem",
            display: "flex",
            flexDirection: "row-reverse",
            alignItems: "center",
            justifyContent: "center"
        }
    }, props.children);
};
const DEFAULT_SPEED = 100;
const DEFAULT_MAX_FRAGMENT_LENGTH = 400;
const DEFAULT_UR = /*#__PURE__*/ new bcUr.UR(/*#__PURE__*/ Buffer.from("NO DATA", "utf-8"));
const useAnimatedQRCodePlayer = ()=>{
    const [data, setData] = React.useState(DEFAULT_UR);
    const [shouldShow, setShouldShow] = React.useState(false);
    const [refreshSpeed, setRefreshSpeed] = React.useState(DEFAULT_SPEED);
    const [maxFragmentLength, setMaxFragmentLength] = React.useState(DEFAULT_MAX_FRAGMENT_LENGTH);
    const [hasNext, setHasNext] = React.useState(false);
    const [title, setTitle] = React.useState(null);
    const [description, setDescription] = React.useState(null);
    const urEncoder = React.useMemo(()=>new bcUr.UREncoder(data, maxFragmentLength), [
        data
    ]);
    const [qr, setQR] = React.useState(urEncoder.nextPart());
    const ee = React.useMemo(()=>new events.EventEmitter(), []);
    const reset = ()=>{
        setData(DEFAULT_UR);
        setShouldShow(false);
        setRefreshSpeed(DEFAULT_SPEED);
    };
    React.useEffect(()=>{
        if (urEncoder.cbor.toString("hex") !== DEFAULT_UR.cbor.toString("hex")) {
            setShouldShow(true);
        }
    }, [
        urEncoder
    ]);
    React.useEffect(()=>{
        const subscribe = rxjs.interval(refreshSpeed).subscribe(()=>{
            setQR(urEncoder.nextPart());
        });
        return ()=>{
            subscribe.unsubscribe();
        };
    }, [
        refreshSpeed,
        urEncoder
    ]);
    const finish = ()=>{
        ee.emit("finish", true);
    };
    const element = shouldShow ? React__default.createElement("div", {
        style: {
            display: "flex",
            flexDirection: "column",
            alignItems: "center"
        }
    }, title && React__default.createElement("p", {
        style: {
            fontSize: "1.25rem",
            fontWeight: "bold"
        }
    }, title), React__default.createElement(BaseQRCode, {
        size: 288,
        data: qr
    }), description && React__default.createElement("p", {
        style: {
            fontSize: "1rem",
            textAlign: "center"
        }
    }, description), React__default.createElement(ButtonGroup, null, React__default.createElement(Button, {
        onClick: finish
    }, hasNext ? "Scan Keystone" : "Finish"))) : React__default.createElement("div", null);
    return [
        element,
        {
            play: (data, options)=>{
                return new Promise((resolve)=>{
                    setData(data);
                    if (options) {
                        options.refreshSpeed && setRefreshSpeed(options.refreshSpeed);
                        options.hasNext && setHasNext(options.hasNext);
                        options.title && setTitle(options.title);
                        options.description && setDescription(options.description);
                        options.maxFragmentLength && setMaxFragmentLength(options.maxFragmentLength);
                    }
                    ee.once("finish", ()=>{
                        reset();
                        resolve(exports.PlayStatus.success);
                    });
                });
            }
        }
    ];
};
class URTypeError extends Error {
    constructor(msg){
        super(msg); // Set the prototype explicitly.
        Object.setPrototypeOf(this, URTypeError.prototype);
    }
}
const LoadingSpinner = ()=>{
    return React__default.createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        style: {
            margin: "auto",
            display: "block",
            shapeRendering: "auto",
            animationPlayState: "running",
            animationDelay: "0s"
        },
        width: "200px",
        height: "200px",
        viewBox: "0 0 100 100",
        preserveAspectRatio: "xMidYMid"
    }, React__default.createElement("circle", {
        cx: "50",
        cy: "50",
        fill: "none",
        stroke: "#9b9b9b",
        strokeWidth: "7",
        r: "35",
        strokeDasharray: "164.93361431346415 56.97787143782138",
        style: {
            animationPlayState: "running",
            animationDelay: "0s"
        }
    }, React__default.createElement("animateTransform", {
        attributeName: "transform",
        type: "rotate",
        repeatCount: "indefinite",
        dur: "1s",
        values: "0 50 50;360 50 50",
        keyTimes: "0;1",
        style: {
            animationPlayState: "running",
            animationDelay: "0s"
        }
    })));
};
const QrReader = /*#__PURE__*/ React__default.lazy(()=>new Promise(function(resolve) {
        resolve(_interopNamespace(__turbopack_context__.r("[project]/node_modules/.pnpm/react-qr-reader@2.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-qr-reader/lib/index.js [app-ssr] (ecmascript)")));
    }));
let URTypeErrorMessage = "";
const useAnimatedQRCodeReader = ()=>{
    const [cameraReady, setCameraReady] = React.useState(false);
    const [expectTypes, setExpectTypes] = React.useState([]);
    const [urDecoder, setURDecoder] = React.useState(new bcUr.URDecoder());
    const [error, setError] = React.useState("");
    const ee = React.useMemo(()=>new events.EventEmitter(), []);
    const [title, setTitle] = React.useState(null);
    const [progress, setProgress] = React.useState(0);
    const [description, setDescription] = React.useState(null);
    const reset = ()=>{
        setURDecoder(new bcUr.URDecoder());
        setError("");
    };
    const processQRCode = (qr, errorMessgeOnURType)=>{
        processUR(qr, errorMessgeOnURType);
    };
    const handleStop = ()=>{
        ee.emit("read", {
            status: "canceled"
        });
    };
    const handleRetry = ()=>{
        reset();
    };
    const processUR = (ur, errorMessgeOnURType)=>{
        try {
            if (!urDecoder.isComplete()) {
                urDecoder.receivePart(ur);
                setProgress(urDecoder.getProgress());
            } else {
                const result = urDecoder.resultUR();
                let foundExpected = false;
                expectTypes.forEach((et)=>{
                    if (et === result.type) {
                        foundExpected = true;
                        ee.emit("read", {
                            result,
                            status: "success"
                        });
                        return;
                    }
                });
                if (!foundExpected) throw new URTypeError(`received ur type ${result.type}, but expected [${expectTypes.join(",")}]`);
            }
        } catch (e) {
            if (e instanceof URTypeError) {
                setError(errorMessgeOnURType);
            } else {
                setError(e.message);
            }
        }
    };
    const element = React__default.createElement("div", {
        style: {
            display: "flex",
            flexDirection: "column",
            alignItems: "center"
        }
    }, title && React__default.createElement("p", {
        style: {
            fontSize: "1.25rem",
            fontWeight: "bold"
        }
    }, title), description && React__default.createElement("p", {
        style: {
            fontSize: "1rem",
            textAlign: "center"
        }
    }, description), React__default.createElement(React.Suspense, {
        fallback: React__default.createElement("div", null)
    }, React__default.createElement("div", {
        style: {
            position: "relative",
            width: "100%"
        }
    }, !cameraReady ? React__default.createElement("div", {
        style: {
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)"
        }
    }, React__default.createElement(LoadingSpinner, null)) : null, React__default.createElement(QrReader, {
        onScan: (data)=>{
            if (data) {
                setCameraReady(true);
                processQRCode(data, URTypeErrorMessage);
            }
        },
        delay: 100,
        style: {
            width: "100%"
        },
        onError: (e)=>{
            setError(e.message);
        }
    }))), React__default.createElement("p", null, (progress * 100).toFixed(0), " %"), error && React__default.createElement("p", {
        style: {
            color: "red",
            fontSize: "1rem"
        }
    }, error), React__default.createElement(ButtonGroup, null, React__default.createElement(Button, {
        onClick: handleStop
    }, "Close"), error && React__default.createElement(Button, {
        onClick: handleRetry
    }, "Retry")));
    return [
        element,
        {
            read: (expect, options)=>{
                return new Promise((resolve)=>{
                    setExpectTypes(expect);
                    if (options) {
                        options.title && setTitle(options.title);
                        options.description && setDescription(options.description);
                        URTypeErrorMessage = options.URTypeErrorMessage ? options.URTypeErrorMessage : "";
                    }
                    ee.once("read", (result)=>{
                        reset();
                        resolve(result);
                    });
                });
            },
            cameraReady
        }
    ];
};
const InitialPage = (props)=>{
    return React__default.createElement("div", {
        style: {
            paddingLeft: "1rem"
        }
    }, React__default.createElement("div", {
        style: {
            display: "flex",
            alignItems: "center",
            padding: 0
        }
    }, React__default.createElement("img", {
        style: {
            display: "inline-block"
        },
        src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAoCAYAAACfKfiZAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAKAAAAACc9ikyAAAD+ElEQVRYCb1WbWiNURw/Z9caY5SyrKzVhuUtZcYoJdZ8kMywGClG+WK+eJsPmogNKfZBxBbmAyPyEgvtA8UUX9inbVeb8AGTd8t2j9/vdp91ntPzPPd57h3/+t1z/uf/ev7nnP9zhUiMsmH2BOgF9ifmIjmrVpgrDWuScxfMeqUW2EqiB2sjgrlJTDsNZmHACqyP2xJzGcyq2iU4E7kTzFVw7fEw+Qbou9bn94K7FCIlgNFh6I7y0E8oAQ9/NlEBuAig71ifv4VspM1iiJnHHsGZyPohjmdzxzeu79acsyFJm8UQMnzbfONmUIvnsRTG4g3DWAM8B24DM4GkaR88WMGcxkYtQr2h+wl8niYPPJ0Aix+AU2Cu8UlmASRe0gHA1L1JYaLUBEPToc7v1hx7XdISTc/3tAiaXs+uE3K2ZdJaQE/MnLdDzvvhm3ij2wDTkc4vj3lLx/gmji7tqmL6voYNcRze17zwv4CemNuc/xt8NSoqsau5OfoD2TSAxDb+EXDTNdeX0igeHYSCaajzfGoWZWDidU90O84XWIZuYw4EvwDT0OK527GG8VUPfcuO4wPAsVvqt/MolIYDbsSmxLPUiS+gEpgBOH1Z+7HOC90MMBFXYnn0jM35S8hDrtZJCFgBluZEHB/bIWenc6XVV1Qo/MCxCoM2ucUi0lwubX4YfBng1TKvQ1426MWY1NSolAs94jJKVoYaOh2DbqGw3ddQqutqkGcooEG5rmHM+8DvMNZs7KVuUaiUWOUjOO0k9HIjSpzOq1RRv0xgus2jnTkONhxbKsZ4A7gFlMbWRChddMLtZ4v3O0YiojZvq8rkEbwCrOai278Dkw98BxYBLYD+anaB58sREzerosiAaMExjCbvl0KpooAV6HIx2IN1Bk8FTgF6cLDiCLCTk86z8mlKSCzBbr6S90NSooumiXYm8MjBgG+3KbZehXGygw6XmAQrEU0C77TETxII3ofA6zrrZR+PIAvoBrhTEnvAPIBJZAIdQLzS8r8BkxGTNqq5AxLHocQY8iYxOIKuwCu4Sxkr8B7g5bLoIiYMTjoExAtOvTqASYiORtmmJCohxRfyBv3GeqkVnDJWgLQQaAV45iw3k5oKsAMySb9UDcVaKuduUYWiX1xDObPJI/AHDBXhBsnvwiBZCXChAuA/nWdkQLxg0bJGOf8/tDtG9fxNKqNfisX4ZKamC/Gw/Zzs9e9GiL1Q5n0ICn6A5gQJ5KY7C4Ig33s90WibdXOsr3ud7wsoshcwiaAUPfegRm76syHgBylINaIX0c1hout8FecB/i/Uy23OedvZP/4Z5cDzSeAnYAZnK54P/BcahygHAD5dNh12tilAIPoLD0OnpwCV000AAAAASUVORK5CYII=",
        alt: ""
    }), React__default.createElement("div", {
        style: {
            fontSize: "1.25rem",
            fontWeight: "bold",
            marginLeft: "1rem"
        }
    }, "Sync Keystone")), React__default.createElement("ul", {
        style: {
            marginTop: "2rem",
            listStyleType: "none",
            padding: 0,
            fontSize: "1rem"
        }
    }, React__default.createElement("li", {
        style: {
            marginBottom: "0.75rem"
        }
    }, "1. Turn on your Keystone hardware device"), React__default.createElement("li", {
        style: {
            marginBottom: "0.75rem"
        }
    }, `2. Select your "${props.walletMode}" as your Watch-only wallet(Companion App)`), React__default.createElement("li", {
        style: {
            marginBottom: "0.75rem"
        }
    }, " ", "3. Press the \"Scan Keystone\" button and scan the QR Code displayed on your Keystone hardware wallet"), React__default.createElement("li", {
        style: {
            marginBottom: "0.75rem"
        }
    }, " ", "4. Select account and check your watch-only wallet")), React__default.createElement("div", {
        style: {
            marginBottom: "1rem"
        }
    }, React__default.createElement("a", {
        style: {
            marginTop: "1.25rem",
            color: "#784FFE",
            textDecoration: "none"
        },
        href: props.link,
        target: "_blank",
        rel: "noreferrer"
    }, "Click here to view detailed tutorial")), React__default.createElement(Button, {
        onClick: props.onButtonClick
    }, "Sync Keystone"));
};
const customStyles = {
    overlay: {
        zIndex: 999
    },
    content: {
        top: "50%",
        left: "50%",
        right: "auto",
        bottom: "auto",
        borderRadius: "10px",
        width: "37rem",
        marginRight: "-50%",
        transform: "translate(-50%, -50%)",
        postion: "relative"
    }
};
const useController = ()=>{
    const ee = React.useMemo(()=>new events.EventEmitter(), []);
    const [visible, setVisible] = React.useState(false);
    const [walletMode, setWalltMode] = React.useState("");
    const [link, setLink] = React.useState("");
    const [mode, setMode] = React.useState(null);
    const [AnimatedQRCodePlayer, { play }] = useAnimatedQRCodePlayer();
    const [AnimatedQRCodeReader, { read, cameraReady }] = useAnimatedQRCodeReader();
    const close = ()=>{
        ee.emit("close");
        reset();
    };
    const reset = ()=>{
        setMode(null);
        setLink("");
        setWalltMode("");
        setVisible(false);
    };
    const goToRead = ()=>{
        setMode("read");
    };
    const renderPannel = (pageMode)=>{
        if (pageMode === "initial") {
            return React__default.createElement(InitialPage, {
                walletMode: walletMode,
                link: link,
                onButtonClick: goToRead
            });
        } else if (pageMode === "read") {
            return AnimatedQRCodeReader;
        } else if (pageMode === "play") {
            return AnimatedQRCodePlayer;
        } else {
            return null;
        }
    };
    const element = React__default.createElement(Modal, {
        isOpen: visible,
        style: customStyles
    }, React__default.createElement("div", {
        onClick: close
    }, React__default.createElement("img", {
        style: {
            position: "absolute",
            top: "1rem",
            right: "1rem"
        },
        src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAADKADAAQAAAABAAAADAAAAAATDPpdAAAAmklEQVQoFZWRwQ3DIAwAa4brJPBP80hnaD/lD5N0iYxEfRVBxBGRwsvgO2PZklJaReTrvX/eTk7O+VVKuTtgDRYVPyOeHAysAFV40jCGEB69aHN/YSRZGK4JVuKu5/DrToDoqnI9tOh4vXJ2Qlc96kSY2lTfWs0m9DCT0r3MSkUrXR9r3eBCNbuDrY/td23z7Vg3wQhGIgcD+wPGY2fPvHuWagAAAABJRU5ErkJggg=="
    })), React__default.createElement("div", {
        style: {
            width: "35rem",
            padding: 18,
            flex: 1,
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            color: "#002237"
        }
    }, renderPannel(mode)));
    return [
        element,
        {
            play: (data, options)=>{
                return new Promise((resolve)=>{
                    ee.once("close", ()=>{
                        resolve(exports.PlayStatus.canceled);
                    });
                    setVisible(true);
                    setMode("play");
                    play(data, options).then(()=>{
                        reset();
                        resolve(exports.PlayStatus.success);
                    });
                });
            },
            read: async (expect, options)=>{
                return new Promise((resolve)=>{
                    ee.once("close", ()=>{
                        reset();
                        resolve({
                            status: exports.ReadStatus.canceled
                        });
                    });
                    if (options.renderInitial) {
                        setWalltMode(options.renderInitial.walletMode);
                        setLink(options.renderInitial.link);
                        setMode("initial");
                        setVisible(true);
                        read(expect, options).then((result)=>{
                            reset();
                            resolve(result);
                        });
                    } else {
                        setMode("read");
                        setVisible(true);
                        read(expect, options).then((result)=>{
                            reset();
                            resolve(result);
                        });
                    }
                });
            },
            cameraReady
        }
    ];
};
var Root = ()=>{
    const [Controller, { read, play, cameraReady }] = useController();
    setupSdk(read, play, cameraReady);
    return Controller;
};
let initialized = false;
let read;
let play;
let cameraReady;
const bootstrap = ()=>{
    const htmlBody = document.getElementsByTagName("body").item(0);
    const sdkDiv = document.createElement("div");
    sdkDiv.id = "kv_sdk_container";
    htmlBody.appendChild(sdkDiv);
    Modal.setAppElement("#kv_sdk_container");
    ReactDOM.render(React__default.createElement(Root), sdkDiv);
};
const setupSdk = (r, p, status)=>{
    initialized = true;
    read = r;
    play = p;
    cameraReady = status;
};
const sdk = {
    bootstrap,
    getSdk: ()=>{
        if (initialized) {
            return {
                read,
                play,
                cameraReady
            };
        } else {
            throw new Error("SDK is not initialized");
        }
    }
};
exports.default = sdk; //# sourceMappingURL=sdk.cjs.development.js.map
}}),
"[project]/node_modules/.pnpm/@keystonehq+sdk@0.19.2_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@keystonehq/sdk/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/@keystonehq+sdk@0.19.2_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@keystonehq/sdk/dist/sdk.cjs.development.js [app-ssr] (ecmascript)");
}
}}),
"[project]/node_modules/.pnpm/@keystonehq+sol-keyring@0.20.0_bufferutil@4.0.9_encoding@0.1.13_react-dom@19.0.0_react@_b64222afa22fd53cf24b8a4ef3f25392/node_modules/@keystonehq/sol-keyring/dist/sol-keyring.cjs.development.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
function _interopDefault(ex) {
    return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}
var bcUrRegistrySol = __turbopack_context__.r("[project]/node_modules/.pnpm/@keystonehq+bc-ur-registry-sol@0.9.5/node_modules/@keystonehq/bc-ur-registry-sol/dist/index.js [app-ssr] (ecmascript)");
var sdk = __turbopack_context__.r("[project]/node_modules/.pnpm/@keystonehq+sdk@0.19.2_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@keystonehq/sdk/dist/index.js [app-ssr] (ecmascript)");
var sdk__default = _interopDefault(sdk);
var bcUrRegistry = __turbopack_context__.r("[project]/node_modules/.pnpm/@keystonehq+bc-ur-registry@0.5.4/node_modules/@keystonehq/bc-ur-registry/dist/index.js [app-ssr] (ecmascript)");
var bs58 = _interopDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/bs58@5.0.0/node_modules/bs58/index.js [app-ssr] (ecmascript)"));
var uuid = __turbopack_context__.r("[project]/node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/index.js [app-ssr] (ecmascript)");
var web3_js = __turbopack_context__.r("[project]/node_modules/.pnpm/@solana+web3.js@1.98.0_bufferutil@4.0.9_encoding@0.1.13_utf-8-validate@5.0.10/node_modules/@solana/web3.js/lib/index.esm.js [app-ssr] (ecmascript)");
class DefaultInteractionProvider {
    constructor(){
        this.keystoneSDK = undefined;
        this.readCryptoMultiAccounts = async ()=>{
            const decodedResult = await this.keystoneSDK.read([
                sdk.SupportedResult.UR_CRYPTO_MULTI_ACCOUNTS
            ], {
                title: "Sync Keystone",
                description: "Please scan the QR code displayed on your Keystone",
                renderInitial: {
                    walletMode: "Solflare",
                    link: "https://keyst.one/defi"
                },
                URTypeErrorMessage: "The scanned QR code is not the sync code from the Keystone hardware wallet. Please verify the code and try again"
            });
            if (decodedResult.status === sdk.ReadStatus.success) {
                const { result } = decodedResult;
                return bcUrRegistry.CryptoMultiAccounts.fromCBOR(result.cbor);
            } else {
                throw new Error("Reading canceled");
            }
        };
        this.requestSignature = async (solSignRequest, requestTitle, requestDescription)=>{
            const status = await this.keystoneSDK.play(solSignRequest.toUR(), {
                hasNext: true,
                title: requestTitle,
                description: requestDescription,
                maxFragmentLength: 400
            });
            if (status === sdk.PlayStatus.canceled) throw new Error("#ktek_error[play-cancel]: play canceled");
            const result = await this.keystoneSDK.read([
                sdk.SupportedResult.UR_SOL_SIGNATURE
            ], {
                title: "Scan Keystone",
                description: "Please scan the QR code displayed on your Keystone"
            });
            if (result.status === sdk.ReadStatus.canceled) {
                throw new Error("#ktek_error[read-cancel]: read signature canceled");
            } else {
                return bcUrRegistrySol.SolSignature.fromCBOR(result.result.cbor);
            }
        };
        if (DefaultInteractionProvider.instance) {
            return DefaultInteractionProvider.instance;
        }
        sdk__default.bootstrap();
        this.keystoneSDK = sdk__default.getSdk();
        DefaultInteractionProvider.instance = this;
    }
}
const keyringType = "QR Hardware Wallet Device";
class BaseKeyring {
    constructor(){
        this.getInteraction = ()=>{
            throw new Error("KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.");
        };
        this.type = keyringType;
        this.requestSignature = async (_requestId, signRequest, requestTitle, requestDescription)=>{
            const solSignature = await this.getInteraction().requestSignature(signRequest, requestTitle, requestDescription);
            const requestIdBuffer = solSignature.getRequestId();
            const signature = solSignature.getSignature();
            if (requestIdBuffer) {
                const requestId = uuid.stringify(requestIdBuffer);
                if (requestId !== _requestId) {
                    throw new Error("KeystoneError#invalid_data: read signature error: mismatched requestId");
                }
            }
            return signature;
        };
        this.getName = ()=>{
            return this.name;
        };
        //common props
        this.keys = [];
        this.name = "QR Hardware";
        this.initialized = false;
        this.device = "";
        this.xfp = "";
    }
    //initial read
    async readKeyring() {
        const result = await this.getInteraction().readCryptoMultiAccounts();
        this.syncKeyring(result);
    }
    syncKeyring(data) {
        var _data$getKeys$0$getOr;
        const keys = data.getKeys();
        this.device = data.getDevice();
        this.xfp = (_data$getKeys$0$getOr = data.getKeys()[0].getOrigin().getSourceFingerprint()) === null || _data$getKeys$0$getOr === void 0 ? void 0 : _data$getKeys$0$getOr.toString("hex");
        this.name = data.getKeys()[0].getName();
        this.keys = keys.map((each, index)=>({
                hdPath: each.getOrigin().getPath(),
                pubKey: bs58.encode(each.getKey()),
                index
            }));
        this.initialized = true;
    }
    syncKeyringData({ xfp, keys, name = "QR Hardware", device }) {
        this.xfp = xfp;
        this.name = name;
        this.keys = keys;
        this.device = device;
        this.initialized = true;
    }
    getAccounts() {
        if (!this.initialized) {
            return [];
        }
        return this.keys;
    }
    async signTransaction(pubKey, txHex) {
        const signature = await this._getSignature(pubKey, Buffer.from(txHex), bcUrRegistrySol.SignType.Transaction);
        return signature;
    }
    async signMessage(pubKey, messageHex) {
        return await this._getSignature(pubKey, Buffer.from(messageHex), bcUrRegistrySol.SignType.Message);
    }
    async createSignature(pubKey, messageHex) {
        try {
            const messageInstance = web3_js.Message.from(messageHex);
            const transaction = web3_js.Transaction.populate(messageInstance, []);
            if (transaction) {
                return this._getSignature(pubKey, Buffer.from(messageHex), bcUrRegistrySol.SignType.Transaction);
            }
        } catch (e) {
            console.error(e);
        }
        return this.signMessage(pubKey, messageHex);
    }
    async _getSignature(pubKey, messageHex, signType) {
        const requestId = uuid.v4();
        const account = this.getAccounts().find((account)=>account.pubKey == pubKey);
        const solSignRequest = bcUrRegistrySol.SolSignRequest.constructSOLRequest(messageHex, account.hdPath, this.xfp, signType, requestId);
        return this.requestSignature(requestId, solSignRequest, "Scan with your Keystone", 'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature');
    }
}
BaseKeyring.type = keyringType;
class DefaultKeyring extends BaseKeyring {
    constructor(){
        super();
        this.getInteraction = ()=>{
            return new DefaultInteractionProvider();
        };
    }
    static getEmptyKeyring() {
        return new DefaultKeyring();
    }
}
DefaultKeyring.type = BaseKeyring.type;
exports.BaseKeyring = BaseKeyring;
exports.DefaultKeyring = DefaultKeyring; //# sourceMappingURL=sol-keyring.cjs.development.js.map
}}),
"[project]/node_modules/.pnpm/@keystonehq+sol-keyring@0.20.0_bufferutil@4.0.9_encoding@0.1.13_react-dom@19.0.0_react@_b64222afa22fd53cf24b8a4ef3f25392/node_modules/@keystonehq/sol-keyring/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/@keystonehq+sol-keyring@0.20.0_bufferutil@4.0.9_encoding@0.1.13_react-dom@19.0.0_react@_b64222afa22fd53cf24b8a4ef3f25392/node_modules/@keystonehq/sol-keyring/dist/sol-keyring.cjs.development.js [app-ssr] (ecmascript)");
}
}}),

};

//# sourceMappingURL=node_modules__pnpm_55bbe666._.js.map